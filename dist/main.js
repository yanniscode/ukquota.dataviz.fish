(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./node_modules/moment/locale sync recursive ^\\.\\/.*$":
/*!**************************************************!*\
  !*** ./node_modules/moment/locale sync ^\.\/.*$ ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": "./node_modules/moment/locale/af.js",
	"./af.js": "./node_modules/moment/locale/af.js",
	"./ar": "./node_modules/moment/locale/ar.js",
	"./ar-dz": "./node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "./node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "./node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "./node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "./node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "./node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "./node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "./node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "./node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "./node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "./node_modules/moment/locale/ar-tn.js",
	"./ar.js": "./node_modules/moment/locale/ar.js",
	"./az": "./node_modules/moment/locale/az.js",
	"./az.js": "./node_modules/moment/locale/az.js",
	"./be": "./node_modules/moment/locale/be.js",
	"./be.js": "./node_modules/moment/locale/be.js",
	"./bg": "./node_modules/moment/locale/bg.js",
	"./bg.js": "./node_modules/moment/locale/bg.js",
	"./bm": "./node_modules/moment/locale/bm.js",
	"./bm.js": "./node_modules/moment/locale/bm.js",
	"./bn": "./node_modules/moment/locale/bn.js",
	"./bn.js": "./node_modules/moment/locale/bn.js",
	"./bo": "./node_modules/moment/locale/bo.js",
	"./bo.js": "./node_modules/moment/locale/bo.js",
	"./br": "./node_modules/moment/locale/br.js",
	"./br.js": "./node_modules/moment/locale/br.js",
	"./bs": "./node_modules/moment/locale/bs.js",
	"./bs.js": "./node_modules/moment/locale/bs.js",
	"./ca": "./node_modules/moment/locale/ca.js",
	"./ca.js": "./node_modules/moment/locale/ca.js",
	"./cs": "./node_modules/moment/locale/cs.js",
	"./cs.js": "./node_modules/moment/locale/cs.js",
	"./cv": "./node_modules/moment/locale/cv.js",
	"./cv.js": "./node_modules/moment/locale/cv.js",
	"./cy": "./node_modules/moment/locale/cy.js",
	"./cy.js": "./node_modules/moment/locale/cy.js",
	"./da": "./node_modules/moment/locale/da.js",
	"./da.js": "./node_modules/moment/locale/da.js",
	"./de": "./node_modules/moment/locale/de.js",
	"./de-at": "./node_modules/moment/locale/de-at.js",
	"./de-at.js": "./node_modules/moment/locale/de-at.js",
	"./de-ch": "./node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "./node_modules/moment/locale/de-ch.js",
	"./de.js": "./node_modules/moment/locale/de.js",
	"./dv": "./node_modules/moment/locale/dv.js",
	"./dv.js": "./node_modules/moment/locale/dv.js",
	"./el": "./node_modules/moment/locale/el.js",
	"./el.js": "./node_modules/moment/locale/el.js",
	"./en-SG": "./node_modules/moment/locale/en-SG.js",
	"./en-SG.js": "./node_modules/moment/locale/en-SG.js",
	"./en-au": "./node_modules/moment/locale/en-au.js",
	"./en-au.js": "./node_modules/moment/locale/en-au.js",
	"./en-ca": "./node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "./node_modules/moment/locale/en-ca.js",
	"./en-gb": "./node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "./node_modules/moment/locale/en-gb.js",
	"./en-ie": "./node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "./node_modules/moment/locale/en-ie.js",
	"./en-il": "./node_modules/moment/locale/en-il.js",
	"./en-il.js": "./node_modules/moment/locale/en-il.js",
	"./en-nz": "./node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "./node_modules/moment/locale/en-nz.js",
	"./eo": "./node_modules/moment/locale/eo.js",
	"./eo.js": "./node_modules/moment/locale/eo.js",
	"./es": "./node_modules/moment/locale/es.js",
	"./es-do": "./node_modules/moment/locale/es-do.js",
	"./es-do.js": "./node_modules/moment/locale/es-do.js",
	"./es-us": "./node_modules/moment/locale/es-us.js",
	"./es-us.js": "./node_modules/moment/locale/es-us.js",
	"./es.js": "./node_modules/moment/locale/es.js",
	"./et": "./node_modules/moment/locale/et.js",
	"./et.js": "./node_modules/moment/locale/et.js",
	"./eu": "./node_modules/moment/locale/eu.js",
	"./eu.js": "./node_modules/moment/locale/eu.js",
	"./fa": "./node_modules/moment/locale/fa.js",
	"./fa.js": "./node_modules/moment/locale/fa.js",
	"./fi": "./node_modules/moment/locale/fi.js",
	"./fi.js": "./node_modules/moment/locale/fi.js",
	"./fo": "./node_modules/moment/locale/fo.js",
	"./fo.js": "./node_modules/moment/locale/fo.js",
	"./fr": "./node_modules/moment/locale/fr.js",
	"./fr-ca": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "./node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "./node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "./node_modules/moment/locale/fr-ch.js",
	"./fr.js": "./node_modules/moment/locale/fr.js",
	"./fy": "./node_modules/moment/locale/fy.js",
	"./fy.js": "./node_modules/moment/locale/fy.js",
	"./ga": "./node_modules/moment/locale/ga.js",
	"./ga.js": "./node_modules/moment/locale/ga.js",
	"./gd": "./node_modules/moment/locale/gd.js",
	"./gd.js": "./node_modules/moment/locale/gd.js",
	"./gl": "./node_modules/moment/locale/gl.js",
	"./gl.js": "./node_modules/moment/locale/gl.js",
	"./gom-latn": "./node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "./node_modules/moment/locale/gom-latn.js",
	"./gu": "./node_modules/moment/locale/gu.js",
	"./gu.js": "./node_modules/moment/locale/gu.js",
	"./he": "./node_modules/moment/locale/he.js",
	"./he.js": "./node_modules/moment/locale/he.js",
	"./hi": "./node_modules/moment/locale/hi.js",
	"./hi.js": "./node_modules/moment/locale/hi.js",
	"./hr": "./node_modules/moment/locale/hr.js",
	"./hr.js": "./node_modules/moment/locale/hr.js",
	"./hu": "./node_modules/moment/locale/hu.js",
	"./hu.js": "./node_modules/moment/locale/hu.js",
	"./hy-am": "./node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "./node_modules/moment/locale/hy-am.js",
	"./id": "./node_modules/moment/locale/id.js",
	"./id.js": "./node_modules/moment/locale/id.js",
	"./is": "./node_modules/moment/locale/is.js",
	"./is.js": "./node_modules/moment/locale/is.js",
	"./it": "./node_modules/moment/locale/it.js",
	"./it-ch": "./node_modules/moment/locale/it-ch.js",
	"./it-ch.js": "./node_modules/moment/locale/it-ch.js",
	"./it.js": "./node_modules/moment/locale/it.js",
	"./ja": "./node_modules/moment/locale/ja.js",
	"./ja.js": "./node_modules/moment/locale/ja.js",
	"./jv": "./node_modules/moment/locale/jv.js",
	"./jv.js": "./node_modules/moment/locale/jv.js",
	"./ka": "./node_modules/moment/locale/ka.js",
	"./ka.js": "./node_modules/moment/locale/ka.js",
	"./kk": "./node_modules/moment/locale/kk.js",
	"./kk.js": "./node_modules/moment/locale/kk.js",
	"./km": "./node_modules/moment/locale/km.js",
	"./km.js": "./node_modules/moment/locale/km.js",
	"./kn": "./node_modules/moment/locale/kn.js",
	"./kn.js": "./node_modules/moment/locale/kn.js",
	"./ko": "./node_modules/moment/locale/ko.js",
	"./ko.js": "./node_modules/moment/locale/ko.js",
	"./ku": "./node_modules/moment/locale/ku.js",
	"./ku.js": "./node_modules/moment/locale/ku.js",
	"./ky": "./node_modules/moment/locale/ky.js",
	"./ky.js": "./node_modules/moment/locale/ky.js",
	"./lb": "./node_modules/moment/locale/lb.js",
	"./lb.js": "./node_modules/moment/locale/lb.js",
	"./lo": "./node_modules/moment/locale/lo.js",
	"./lo.js": "./node_modules/moment/locale/lo.js",
	"./lt": "./node_modules/moment/locale/lt.js",
	"./lt.js": "./node_modules/moment/locale/lt.js",
	"./lv": "./node_modules/moment/locale/lv.js",
	"./lv.js": "./node_modules/moment/locale/lv.js",
	"./me": "./node_modules/moment/locale/me.js",
	"./me.js": "./node_modules/moment/locale/me.js",
	"./mi": "./node_modules/moment/locale/mi.js",
	"./mi.js": "./node_modules/moment/locale/mi.js",
	"./mk": "./node_modules/moment/locale/mk.js",
	"./mk.js": "./node_modules/moment/locale/mk.js",
	"./ml": "./node_modules/moment/locale/ml.js",
	"./ml.js": "./node_modules/moment/locale/ml.js",
	"./mn": "./node_modules/moment/locale/mn.js",
	"./mn.js": "./node_modules/moment/locale/mn.js",
	"./mr": "./node_modules/moment/locale/mr.js",
	"./mr.js": "./node_modules/moment/locale/mr.js",
	"./ms": "./node_modules/moment/locale/ms.js",
	"./ms-my": "./node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "./node_modules/moment/locale/ms-my.js",
	"./ms.js": "./node_modules/moment/locale/ms.js",
	"./mt": "./node_modules/moment/locale/mt.js",
	"./mt.js": "./node_modules/moment/locale/mt.js",
	"./my": "./node_modules/moment/locale/my.js",
	"./my.js": "./node_modules/moment/locale/my.js",
	"./nb": "./node_modules/moment/locale/nb.js",
	"./nb.js": "./node_modules/moment/locale/nb.js",
	"./ne": "./node_modules/moment/locale/ne.js",
	"./ne.js": "./node_modules/moment/locale/ne.js",
	"./nl": "./node_modules/moment/locale/nl.js",
	"./nl-be": "./node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "./node_modules/moment/locale/nl-be.js",
	"./nl.js": "./node_modules/moment/locale/nl.js",
	"./nn": "./node_modules/moment/locale/nn.js",
	"./nn.js": "./node_modules/moment/locale/nn.js",
	"./pa-in": "./node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "./node_modules/moment/locale/pa-in.js",
	"./pl": "./node_modules/moment/locale/pl.js",
	"./pl.js": "./node_modules/moment/locale/pl.js",
	"./pt": "./node_modules/moment/locale/pt.js",
	"./pt-br": "./node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "./node_modules/moment/locale/pt-br.js",
	"./pt.js": "./node_modules/moment/locale/pt.js",
	"./ro": "./node_modules/moment/locale/ro.js",
	"./ro.js": "./node_modules/moment/locale/ro.js",
	"./ru": "./node_modules/moment/locale/ru.js",
	"./ru.js": "./node_modules/moment/locale/ru.js",
	"./sd": "./node_modules/moment/locale/sd.js",
	"./sd.js": "./node_modules/moment/locale/sd.js",
	"./se": "./node_modules/moment/locale/se.js",
	"./se.js": "./node_modules/moment/locale/se.js",
	"./si": "./node_modules/moment/locale/si.js",
	"./si.js": "./node_modules/moment/locale/si.js",
	"./sk": "./node_modules/moment/locale/sk.js",
	"./sk.js": "./node_modules/moment/locale/sk.js",
	"./sl": "./node_modules/moment/locale/sl.js",
	"./sl.js": "./node_modules/moment/locale/sl.js",
	"./sq": "./node_modules/moment/locale/sq.js",
	"./sq.js": "./node_modules/moment/locale/sq.js",
	"./sr": "./node_modules/moment/locale/sr.js",
	"./sr-cyrl": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "./node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "./node_modules/moment/locale/sr.js",
	"./ss": "./node_modules/moment/locale/ss.js",
	"./ss.js": "./node_modules/moment/locale/ss.js",
	"./sv": "./node_modules/moment/locale/sv.js",
	"./sv.js": "./node_modules/moment/locale/sv.js",
	"./sw": "./node_modules/moment/locale/sw.js",
	"./sw.js": "./node_modules/moment/locale/sw.js",
	"./ta": "./node_modules/moment/locale/ta.js",
	"./ta.js": "./node_modules/moment/locale/ta.js",
	"./te": "./node_modules/moment/locale/te.js",
	"./te.js": "./node_modules/moment/locale/te.js",
	"./tet": "./node_modules/moment/locale/tet.js",
	"./tet.js": "./node_modules/moment/locale/tet.js",
	"./tg": "./node_modules/moment/locale/tg.js",
	"./tg.js": "./node_modules/moment/locale/tg.js",
	"./th": "./node_modules/moment/locale/th.js",
	"./th.js": "./node_modules/moment/locale/th.js",
	"./tl-ph": "./node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "./node_modules/moment/locale/tl-ph.js",
	"./tlh": "./node_modules/moment/locale/tlh.js",
	"./tlh.js": "./node_modules/moment/locale/tlh.js",
	"./tr": "./node_modules/moment/locale/tr.js",
	"./tr.js": "./node_modules/moment/locale/tr.js",
	"./tzl": "./node_modules/moment/locale/tzl.js",
	"./tzl.js": "./node_modules/moment/locale/tzl.js",
	"./tzm": "./node_modules/moment/locale/tzm.js",
	"./tzm-latn": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "./node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "./node_modules/moment/locale/tzm.js",
	"./ug-cn": "./node_modules/moment/locale/ug-cn.js",
	"./ug-cn.js": "./node_modules/moment/locale/ug-cn.js",
	"./uk": "./node_modules/moment/locale/uk.js",
	"./uk.js": "./node_modules/moment/locale/uk.js",
	"./ur": "./node_modules/moment/locale/ur.js",
	"./ur.js": "./node_modules/moment/locale/ur.js",
	"./uz": "./node_modules/moment/locale/uz.js",
	"./uz-latn": "./node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "./node_modules/moment/locale/uz-latn.js",
	"./uz.js": "./node_modules/moment/locale/uz.js",
	"./vi": "./node_modules/moment/locale/vi.js",
	"./vi.js": "./node_modules/moment/locale/vi.js",
	"./x-pseudo": "./node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "./node_modules/moment/locale/x-pseudo.js",
	"./yo": "./node_modules/moment/locale/yo.js",
	"./yo.js": "./node_modules/moment/locale/yo.js",
	"./zh-cn": "./node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "./node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "./node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "./node_modules/moment/locale/zh-hk.js",
	"./zh-tw": "./node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "./node_modules/moment/locale/zh-tw.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./node_modules/moment/locale sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html":
/*!**************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div>\r\n  <h2 class=\"subtitle_logo\">Statistiques de Pêche</h2>\r\n</div>\r\n\r\n<div class=\"gallery\">\r\n\r\n  <mat-tab-group>\r\n\r\n    <mat-tab label=\"Graphiques et Carte\">\r\n\r\n      <!-- formulaire de connexion (membre) pour accès aux graphiques, carte... -->\r\n      <app-form-connexion></app-form-connexion>\r\n\r\n      <!-- tableau de données -->\r\n      <app-data-table></app-data-table>\r\n\r\n    </mat-tab>\r\n    <mat-tab label=\"Administrateur\">\r\n\r\n      <!-- partie administrateur : gestion des membres (ajout, suppression, modification) -->\r\n      <app-form-admin-connexion></app-form-admin-connexion>\r\n    </mat-tab>\r\n\r\n  </mat-tab-group>\r\n\r\n  <!-- <app-tabs></app-tabs> -->\r\n  <!-- ************************* -->\r\n\r\n  <!-- <app-form-connexion></app-form-connexion> -->\r\n  <!-- <app-reactive-form-connexion></app-reactive-form-connexion> -->\r\n  <!-- <app-hero-form-reactive></app-hero-form-reactive> -->\r\n\r\n  <!-- <app-modales></app-modales> -->\r\n  \r\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-class/chart-update/chart-update.component.html":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-class/chart-update/chart-update.component.html ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- \n<div class=\"container\" style=\"position: relative; height:40vh; width:60vw\">\n    <canvas class=\"chart-canvas\"  id=\"chart\"></canvas>\n</div> \n-->");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/config/config.component.html":
/*!***************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/config/config.component.html ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<h3>Get configuration from JSON file</h3>\n<div>\n  <button (click)=\"clear(); showConfig()\">get</button>\n  <button (click)=\"clear(); showConfigResponse()\">getResponse</button>\n  <button (click)=\"clear()\">clear</button>\n  <button (click)=\"clear(); makeError()\">error</button>\n  <span *ngIf=\"config\">\n    <p>Heroes API URL is \"{{config.heroesUrl}}\"</p>\n    <p>Textfile URL is \"{{config.textfile}}\"</p>\n    <div *ngIf=\"headers\">\n      Response headers:\n      <ul>\n        <li *ngFor=\"let header of headers\">{{header}}</li>\n      </ul>\n    </div>\n  </span>\n</div>\n<p *ngIf=\"error\" class=\"error\">{{error | json}}</p>\n\n\n<!-- \nCopyright Google LLC. All Rights Reserved.\nUse of this source code is governed by an MIT-style license that\ncan be found in the LICENSE file at http://angular.io/license\n-->");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.html":
/*!******************************************************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.html ***!
  \******************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div class=\"container\">\n\n  <form [formGroup]=\"inscriptionForm\">\n\n\n    <h1>Inscription (auto-complete form-test)</h1>\n\n    <div>\n    <!-- <div class=\"cross-validation\" [class.cross-validation-error]=\"(inscriptionForm.touched || inscriptionForm.dirty)\"> -->\n    <!-- <div class=\"form-group\"> -->\n\n      <div class=\"row row-cols-1 row-cols-lg-2 row-cols-xl-2\">\n\n\n        <div class=\"col align-self-center\">\n          \n          <!-- TEST VERSION AVEC onUpdate() - MARCHE GLOBALEMENT -->\n          <mat-form-field (click)=\"onEdit(user);\">\n\n            <mat-label for=\"login\">Login</mat-label>\n            \n            <!-- DIV *ngFor en TEST : MARCHE PAS bien car repère pas l'id_user > appel à l'api nécessaire ??-->\n            <!-- <div *ngFor=\"let id_user of idUserFilteredOptions | async\">\n              <span class=\"badge\">{{ id_user || -1 }}</span>\n            </div> -->\n            <!-- span *ngIf=\"user!==editUser\">{{ user.login }} </span --> <!--PLUS UTILE ?? : MARCHE SANS ET SI EST PRÉSENT : PB = LOGIN APPARAIT 2 FOIS -->\n            \n            <input matInput type=\"text\" placeholder=\"Login\" [formControl]=\"login\" [(ngModel)]=\"user.login\" aria-label=\"Number\" [matAutocomplete]=\"autoLogin\" #userLogin required>\n            <!-- (blur)=\"onPreUpdate(user);\": pas nécessaire ici / (keyup.enter)=\"onPreUpdate(user);\": semble pas marcher, submit d'un nouveau membre à la place... -->\n            <!-- (keyup.enter)=\"onUpdate()\" / ngIf=\"user!==editUser\" = ENLEVÉ sinon erreur de mat-form-field-control (Material Angular) : mais plus d'alternative avec *ngIf, donc nouveau problème : 'login' apparait 2 fois... -->\n\n            <mat-autocomplete #autoLogin=\"matAutocomplete\">\n              <mat-option *ngFor=\"let login of loginFilteredOptions | async\" [value]=\"login\" (click)=\"onLoginSelect(login)\">\n                <button class=\"delete\" title=\"delete user by login\" (click)=\"onDelete(login)\"><!-- x -->\n                  <svg class=\"bi bi-x-circle\" width=\"32\" height=\"32\" viewBox=\"0 0 20 20\" fill=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n                    <path fill-rule=\"evenodd\" d=\"M10 17a7 7 0 100-14 7 7 0 000 14zm0 1a8 8 0 100-16 8 8 0 000 16z\" clip-rule=\"evenodd\"></path>\n                    <path fill-rule=\"evenodd\" d=\"M12.646 13.354l-6-6 .708-.708 6 6-.708.708z\" clip-rule=\"evenodd\"></path>\n                    <path fill-rule=\"evenodd\" d=\"M7.354 13.354l6-6-.708-.708-6 6 .708.708z\" clip-rule=\"evenodd\"></path>\n                  </svg>\n                </button><span> </span><span>{{ login }}</span>\n              </mat-option>\n            </mat-autocomplete>\n            \n            <mat-error *ngIf=\"login.invalid\">Saisir un Login</mat-error>\n\n          </mat-form-field>\n\n          <!-- </div> -->\n\n          <!-- <mat-form-field class=\"col align-self-center\">\n\n            <mat-label for=\"login\">Login</mat-label>\n            <input matInput type=\"text\" placeholder=\"Login\" aria-label=\"Number\" [formControl]=\"login\" [matAutocomplete]=\"autoLogin\" #userLogin required>\n            <mat-autocomplete #autoLogin=\"matAutocomplete\">\n              <mat-option *ngFor=\"let login of loginFilteredOptions | async\" [value]=\"login\">\n                <button class=\"delete\" title=\"delete user by login\" (click)=\"delete(login)\">x</button>{{ login }}\n              </mat-option>\n            </mat-autocomplete>\n\n          </mat-form-field> -->\n\n          <hr />\n          \n          <div *ngIf=\"login.invalid && (login.dirty || login.touched)\" class=\"alert alert-danger\">\n\n            <div *ngIf=\"login.errors.required\">\n                Le login est requis.\n            </div>           \n            <div *ngIf=\"login.errors.minlength\">\n                le login doit être d'au moins 4 caractères.\n            </div>\n\n          </div>\n\n        </div><!-- fin de div 'col' -->\n        \n\n        <!-- <div class=\"form-group\"> -->\n\n        <div class=\"col align-self-center\">\n          \n          <!-- TEST VERSION AVEC onUpdate() : EN TEST -->\n          <mat-form-field>\n\n            <mat-label for=\"mail\">Mail</mat-label>\n            \n            <!-- DIV *ngFor en TEST : MARCHE PAS bien car repère pas l'id_user > appel à l'api nécessaire ??-->\n            <!-- <div *ngFor=\"let id_user of idUserFilteredOptions | async\">\n              <span class=\"badge\">{{ id_user || -1 }}</span>\n            </div> -->\n            <!-- span *ngIf=\"user!==editUser\">{{ user.login }} </span --> <!--PLUS UTILE ?? : MARCHE SANS ET SI EST PRÉSENT : PB = LOGIN APPARAIT 2 FOIS -->\n            \n            <input matInput type=\"text\" placeholder=\"Mail\" [formControl]=\"mail\" [(ngModel)]=\"user.mail\" aria-label=\"Number\" [matAutocomplete]=\"autoMail\" #userMail required (click)=\"onEdit(user)\">\n            <!-- (blur)=\"onPreUpdate(user);\": pas nécessaire ici / (keyup.enter)=\"onPreUpdate(user);\": semble pas marcher, submit d'un nouveau membre à la place...  -->\n            <!-- (keyup.enter)=\"onUpdate()\" / ngIf=\"user!==editUser\" = ENLEVÉ sinon erreur de mat-form-field-control (Material Angular) : mais plus d'alternative avec *ngIf, donc nouveau problème : 'login' apparait 2 fois... -->\n\n            <mat-autocomplete #autoMail=\"matAutocomplete\">\n              <mat-option *ngFor=\"let mail of mailFilteredOptions | async\" [value]=\"mail\" (click)=\"onMailSelect(mail)\">{{ mail }}</mat-option>\n                <!-- <button class=\"delete\" title=\"delete user by login\" (click)=\"onDelete(login)\">x</button> -->\n                <!-- {{ mail }} -->\n              <!-- </mat-option> -->\n            </mat-autocomplete>\n            \n            <mat-error *ngIf=\"mail.invalid\">Saisir un Mail</mat-error>\n\n          </mat-form-field>\n\n          <hr />\n\n        <!-- </div> -->\n\n\n          <!-- <mat-form-field class=\"col align-self-center\">\n          \n            <mat-label for=\"mail\">Mail</mat-label>\n            <br/>\n            <input matInput type=\"text\" placeholder=\"Mail\" aria-label=\"Number\"  [formControl]=\"mail\" [matAutocomplete]=\"autoMail\" #userMail required>\n            <mat-autocomplete #autoMail=\"matAutocomplete\">\n              <mat-option *ngFor=\"let mail of mailFilteredOptions | async\" [value]=\"mail\">{{ mail }}\n              </mat-option>\n            </mat-autocomplete>\n\n          </mat-form-field> -->\n\n          <!-- <br /> --><!-- déplace le champs mail vers le bas -->\n          \n          <div *ngIf=\"mail.invalid && (mail.dirty || mail.touched)\" class=\"alert alert-danger\">\n\n            <div *ngIf=\"mail.errors.required\">\n                Le mail est requis.\n            </div>           \n            <div *ngIf=\"mail.errors.minlength\">\n                le mail doit être d'au moins 4 caractères.\n            </div>\n\n          </div>\n\n        </div><!-- fin de div 'col' -->\n\n\n      </div><!-- fin de div 'row' -->\n\n\n    </div>\n  \n    <br /><br />\n\n    <div class=\"submit\">\n\n      <span><button *ngIf=\"showUserInscriptionButton\" type=\"submit\" (click)=\"onInscriptionSubmit(userLogin.value, userMail.value); userLogin.value=''; userMail.value='';\" class=\"btn btn-primary\" [disabled]=\"inscriptionForm.invalid\">Inscrire un nouveau membre</button></span>\n      \n      <!-- BOUTON D'UPDATE (SI L'ON VEUT UNE PRÉVALIDATION): MÉTHODE UNIQUE APPELÉE : onEdit(user) : (ON DOIT PASSER 2 FOIS DANS LA MÉTHODE AVANT DE VALIDER L'UPDATE AVEC LE BOUTON DE VALIDATION) -->\n      <span><button *ngIf=\"showPreUpdateUserButton\" type=\"submit\" (click)=\"onPreUpdate(user);\" class=\"btn btn-warning\" [disabled]=\"inscriptionForm.invalid\">Mettre à jour le membre</button></span>\n      \n      <!-- VERSION 2 DU BOUTON DE VALIDATION (SI L'ON NE VEUT PAS DE PRÉVALIDATION): les deux méthodes sur le même bouton de validation : onEdit(user) et onUpdate() : -->\n      <!-- (PROBLÈME: ON DOIT PASSER 2 FOIS DANS LA MÉTHODE (le champs 'login', ou 'mail' par exemple) AVANT DE VALIDER L'UPDATE) -->\n      <!-- <span><button *ngIf=\"showUpdateUserButton\" type=\"submit\" (click)=\"onEdit(user); onUpdate();\" class=\"btn btn-success\" [disabled]=\"inscriptionForm.invalid\">Modifier le profil</button></span> -->\n\n      <!-- VERSION 1 DU BOUTON DE VALIDATION (SI L'ON VEUT UNE PRÉVALIDATION): MÉTHODE UNIQUE APPELÉE : onEdit(user) : -->\n      <span><button *ngIf=\"showUpdateUserButton\" type=\"submit\" (click)=\"onUpdate();\" class=\"btn btn-success\" [disabled]=\"inscriptionForm.invalid\">Confirmer la modification</button></span>\n\n      <span><button *ngIf=\"showCancelButton\" type=\"submit\" (click)=\"onResetAction();\" class=\"btn btn-dark\">Annuler</button></span>\n      <!-- <span><button  type=\"submit\" (click)=\"onDelete(login)\" class=\"btn btn-danger\">Supprimer le membre</button></span> -->\n\n    </div>\n\n  \n  </form>\n\n  <!-- TABLEAU DES MEMBRES (UPDATE ET SUPPRESSION POSSIBLE) - A OPTIMISER -->\n  <app-members-list></app-members-list>\n\n</div>\n\n<!-- <hr> -->\n      \n  <!-- DIVS DE TEST DES DONNÉES DU FORMULAIRE -->\n\n  <!-- <div class=\"submit-form\" align=\"center\"> -->\n\n    <!-- <p>\n      Form Values: {{ login.value | json }}\n    </p>\n      \n    <p>\n      Form Status: {{ login.status }}\n    </p> -->\n    \n    <!-- <p>\n      Form Values: {{ inscriptionForm.value | json }}\n    </p>\n      \n    <p>\n      Form Status: {{ inscriptionForm.status }}\n    </p>\n    \n  </div>\n\n</div> -->");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/data-table/data-table.component.html":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/data-table/data-table.component.html ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- <div class=\"submit\"> -->\n  <!-- <button mat-button class=\"button\" (click)=\"getSelectedRows()\">Lignes sélectionnées</button> -->\n  <!-- <button class=\"mat-button\" style=\"margin-right: 20px;\" (click)=\"getSelectedRows()\">Get Selected Rows</button> -->\n<!-- </div> -->\n\n<h1 class=\"stats\">TABLEAU</h1>\n<br><br>\n<h2>Dernières données</h2>\n<br>\n\n<div align =\"center\" class=\"table_container\">\n  <ag-grid-angular\n    id=\"agGrid\"\n    class=\"ag-theme-balham\"\n    [enableSorting]=\"false\"\n    [enableFilter]=\"true\"\n    [rowData]=\"rowData | async\"\n    [columnDefs]=\"columnDefs\"\n    rowSelection=\"multiple\"\n  >\n  </ag-grid-angular>\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/dates-chart/dates-chart.component.html":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/dates-chart/dates-chart.component.html ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- pour TEST : import composant parent > enfant -->\n\n<!-- \n    <p>\n        Today's Chart NameSpecie : {{nameSpecieSelect}}\n        <br />\n        Today's Chart Zone : {{zoneSelect}}\n        <br />\n        Today's Chart Date 1 : {{dateSelect}}\n        <br />\n        Today's Chart Date 2 Begin : {{date2BeginSelect}}\n        <br />\n        Today's Chart Date 2 End : {{date2EndSelect}}\n    </p>\n-->\n\n<div class=\"mx-auto col-12 col-lg-6 col-xl-4\">\n    <a href=\"\" data-toggle=\"modal\" data-target=\"#lineChartModale\" (click)=\"onDatesLabels()\"><img id=\"formsubmit\" src =\"../../../../assets/img/Chart-JS.png\" width=\"400\" height=\"200\" title=\"Fishing LineChart\" alt=\"Fishing LineChart\"></a>  \n</div>\n \n<div class=\"modal fade\" id=\"lineChartModale\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"lineChartModaleTitle\" aria-hidden=\"true\">\n    <div class=\"modal-dialog modal-dialog-centered modal-xl\" role=\"document\">\n        <div class=\"modal-content\">\n            \n            <div class=\"modal-header\">\n                <h5 class=\"modal-title\" id=\"lineChartModaleLongTitle\">Courbe de périodes</h5>\n                <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                    <span aria-hidden=\"true\">&times;</span>\n                </button>\n            </div>\n\n            <div class=\"container\">\n                <app-chart-update [type]=\"type\" [data]=\"data\" [options]=\"options\">\n                </app-chart-update>\n            </div>\n\n            <div class=\"modal-footer\">\n                <button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Fermer</button>\n            </div>\n\n        </div>\n    </div>\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.html":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.html ***!
  \************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div [hidden]=\"formDir2.submitted && showAdminDatas\" class=\"container\">\n\n\n    <form [formGroup]=\"adminForm\" #formDir2=\"ngForm\">\n\n        <!-- lorsque l'on est connecté, le formulaire disparait, et la <div> souhaitée s'affiche -->\n        <!-- <div [hidden]=\"formDir2.submitted && showAdminDatas\" class=\"container\"> -->\n\n        <h1>Connexion (Administrateur)</h1>\n\n        <!-- <div class=\"cross-validation\" [class.cross-validation-error]=\"adminForm.errors?.loginUnchecked && (adminForm.touched || adminForm.dirty)\"> -->\n        <!-- <div class=\"cross-validation\" [class.cross-validation-error]=\"(userForm.touched || userForm.dirty)\"> -->\n\n        <div class=\"form-group\">\n\n            <mat-form-field class=\"col align-self-center\">\n                <mat-label for=\"adminLogin\">Login</mat-label>\n                <input matInput id=\"adminLogin\" class=\"form-control\" formControlName=\"login\" required>\n            </mat-form-field>\n\n            <div *ngIf=\"adminLogin.invalid && (adminLogin.dirty || adminLogin.touched)\" class=\"alert alert-danger\">\n\n                <div *ngIf=\"adminLogin.errors.required\">\n                    Le login est requis.\n                </div>\n                \n                <!-- <div *ngIf=\"adminLogin.errors.minlength\">\n                    le login doit être d'au moins 4 caractères.\n                </div> -->\n\n            </div>\n\n        </div>\n\n        <div class=\"form-group\">\n\n            <mat-form-field class=\"col align-self-center\">\n                <mat-label for=\"adminMail\">Mail</mat-label>      \n                <input matInput id=\"adminMail\" class=\"form-control\" formControlName=\"mail\" required>\n            </mat-form-field>\n            \n            <div *ngIf=\"adminMail.invalid && (adminMail.dirty || adminMail.touched)\" class=\"alert alert-danger\">\n\n                <div *ngIf=\"adminMail.errors.required\">\n                    Le mail est requis.\n                </div>\n                \n                <div *ngIf=\"adminMail.errors.email\">\n                    le mail doit être au bon format.\n                </div>\n\n            </div>\n\n        </div>\n\n        <!-- </div> -->\n\n        <div class=\"submit\">\n            <button type=\"submit\" (click)=\"onAdminSubmit()\" class=\"btn btn-secondary\" [disabled]=\"adminForm.invalid\">Se connecter</button> \n        </div><!-- [disabled]=\"adminForm.invalid\" : si appliqué, le bouton est invalide sauf pour le login, mail de l'admin -> trop visible ?? -->\n\n\n    </form>\n\n</div>\n\n\n<div class=\"submitted-message\" *ngIf=\"formDir2.submitted && showAdminDatas\" id=\"form-submitted2\">\n    <!-- AJOUT : id=\"form-submitted\" -->\n\n    <!-- <p>You've submitted your admin (login), {{ adminForm.value.login }}!</p> -->\n    \n    <app-autocomplete-form-inscription-clean></app-autocomplete-form-inscription-clean>\n\n    <!-- <app-form-inscription-test></app-form-inscription-test --><!-- bon -->\n    \n    <div class=\"submit\" style=\"text-align: center\">\n        <button type=\"submit\" (click)=\"onAdminDeconnect()\" class=\"btn btn-outline-danger\" [disabled]=\"adminForm.invalid\">Se déconnecter</button> \n    </div>\n\n</div>\n\n<!-- <div *ngIf=\"adminForm.errors?.loginUnchecked && (adminForm.touched || adminForm.dirty)\" class=\"cross-validation-error-message alert alert-danger\">\n\n    <p>Membre non-autorisé à l'espace d'administration, ou erreur de connexion...</p>\n\n</div> -->");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/form-connexion/form-connexion.component.html":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/form-connexion/form-connexion.component.html ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- lorsque l'on est connecté, le formulaire disparait, et la <div> souhaitée s'affiche -->\n<div [hidden]=\"formDir.submitted && showDatas\" class=\"container\">\n\n    <form [formGroup]=\"userForm\" #formDir=\"ngForm\">\n\n        <h1>Connexion</h1>\n\n        <!-- <div class=\"cross-validation\" [class.cross-validation-error]=\"(userForm.touched || userForm.dirty)\"> -->\n        <div class=\"form-group\">\n\n            <mat-form-field class=\"col align-self-center\">\n                <mat-label for=\"login\">Login</mat-label>     \n                <input matInput id=\"login\" class=\"form-control\" formControlName=\"login\" required>\n            </mat-form-field>\n            \n            <div *ngIf=\"login.invalid && (login.dirty || login.touched)\" class=\"alert alert-danger\">\n                <div *ngIf=\"login.errors.required\">\n                    Le login est requis.\n                </div>     \n                <div *ngIf=\"login.errors.minlength\">\n                    le login doit être d'au moins 4 caractères.\n                </div>\n            </div>\n\n        </div>\n\n        <div class=\"form-group\">\n\n            <mat-form-field class=\"col align-self-center\">\n                <mat-label for=\"mail\">Mail</mat-label>\n                <input matInput id=\"mail\" class=\"form-control\" formControlName=\"mail\" required>\n            </mat-form-field>\n\n            <div *ngIf=\"mail.invalid && (mail.dirty || mail.touched)\" class=\"alert-danger\">\n                \n                <div *ngIf=\"mail.errors.required\">\n                    Le mail est requis.\n                </div>   \n                <div *ngIf=\"mail.errors.email\">\n                    le mail doit être au bon format.\n                </div>\n\n            </div>\n\n        </div>\n\n        <div class=\"submit\">\n            <button type=\"submit\" (click)=\"onSubmit()\" class=\"btn btn-default\" [disabled]=\"userForm.invalid\">Afficher les données</button>\n        </div>\n\n    </form>\n\n</div>\n\n<div class=\"submitted-message\" *ngIf=\"formDir.submitted && showDatas\" id=\"form-submitted\"><!-- AJOUT : id=\"form-submitted\" -->\n\n    <!-- <p>You've submitted your user (login), {{ userForm.value.login }}!</p> -->\n\n    <app-search-form></app-search-form>\n\n</div>\n\n<div *ngIf=\"formDir.submitted && showDatas\" class=\"container\">\n\n    <div class=\"submit\">\n        <button type=\"submit\" (click)=\"onUserDeconnect()\" class=\"btn btn-outline-danger\" [disabled]=\"userForm.invalid\">Se déconnecter</button>\n    </div>\n    \n</div>\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/members-list/members-list.component.html":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/members-list/members-list.component.html ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div align =\"center\" class=\"table_container table-responsive-sm\">\n\n  <h1>liste des membres (auto-complete form)</h1>\n  \n  <br /><br />\n\n  <form [formGroup]=\"modificationForm\">\n      \n    <table class=\"table table-sm table-hover table-dark\">\n    \n      <thead>\n        <tr>\n          <th>id_user</th>\n          <th>login</th>\n          <th>mail</th>\n          <th>Supprimer un membre</th>\n        </tr>\n      </thead>\n      \n      <tbody *ngFor=\"let user of user$; trackBy: trackByItems\">\n\n        <tr>\n          <td>\n            <button class=\"badge\" (click)=\"onEdit(user)\">{{ user.id_user || -1 }}\n            </button>\n          </td>\n          <td (click)=\"onEdit(user)\">\n            <span *ngIf=\"user!==editUser\">{{user.login}}</span>\n            <input matInput *ngIf=\"user===editUser\" [(ngModel)]=\"user.login\" (blur)=\"onUpdate()\" (keyup.enter)=\"onUpdate()\" type=\"text\" placeholder=\"Login\" aria-label=\"Number\" [formControl]=\"login\" [matAutocomplete]=\"autoLogin\" #userLogin required>\n            <mat-autocomplete #autoLogin=\"matAutocomplete\">\n              <mat-option *ngFor=\"let login of loginFilteredOptions | async\" [value]=\"login\">{{ login }}</mat-option>\n            </mat-autocomplete>\n          </td>\n\n          <td (click)=\"onEdit(user)\">\n            <span *ngIf=\"user!==editUser\">{{user.mail}}</span>\n            <input matInput *ngIf=\"user===editUser\" [(ngModel)]=\"user.mail\" (blur)=\"onUpdate()\" (keyup.enter)=\"onUpdate()\" type=\"text\" placeholder=\"Mail\" aria-label=\"Number\" [formControl]=\"mail\" [matAutocomplete]=\"autoMail\" #userMail required>\n            <mat-autocomplete #autoMail=\"matAutocomplete\">\n              <mat-option *ngFor=\"let mail of mailFilteredOptions | async\" [value]=\"mail\">{{ mail }}</mat-option>\n            </mat-autocomplete>\n          </td>\n\n          <td>\n            <button class=\"delete\" title=\"delete user\" (click)=\"onDelete2(user)\"><!-- x -->\n              <svg class=\"bi bi-x-circle\" width=\"32\" height=\"32\" viewBox=\"0 0 20 20\" fill=\"currentColor\" xmlns=\"http://www.w3.org/2000/svg\">\n                <path fill-rule=\"evenodd\" d=\"M10 17a7 7 0 100-14 7 7 0 000 14zm0 1a8 8 0 100-16 8 8 0 000 16z\" clip-rule=\"evenodd\"></path>\n                <path fill-rule=\"evenodd\" d=\"M12.646 13.354l-6-6 .708-.708 6 6-.708.708z\" clip-rule=\"evenodd\"></path>\n                <path fill-rule=\"evenodd\" d=\"M7.354 13.354l6-6-.708-.708-6 6 .708.708z\" clip-rule=\"evenodd\"></path>\n              </svg>\n            </button>\n          </td>\n\n          <!-- <input *ngIf=\"user===editUser\" [(ngModel)]=\"user.login\" (blur)=\"onUpdate()\" (keyup.enter)=\"onUpdate()\" -->\n          <!-- <td>\n            <button type=\"submit\" (click)=\"onUpdate()\" class=\"btn btn-default\">Mettre à jour</button>\n          </td> -->\n\n        </tr>\n\n      </tbody>\n\n      <tbody>\n\n        <tr>\n          <td></td>\n          <td></td>\n          <td></td>\n          <td style=\"text-align: center;\">\n            <button type=\"submit\" (click)=\"onUpdate()\" class=\"btn btn-outline-success\">Mettre à jour les données</button>\n          </td>\n        </tr>\n        \n      </tbody>\n\n    </table>\n\n  </form>\n\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/search-form/search-form.component.html":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/search-form/search-form.component.html ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div class=\"form\"><!-- class=\"form\" -->\n\n    <div class=\"\" align=\"left\">\n        <h1 class=\"stats\">DATAS</h1>\n    </div>\n\n    <!-- TEST export composant 'enfant' > 'parent' -->\n\n    <!-- <label>Add a specie (init): <input #newNameSp></label> -->\n    <!-- <button (click)=\"addNewNameSp(newNameSp.value)\">Add to parent's</button> -->\n\n    <!-- <label>Add an item: <input #newItem></label>\n    <button (click)=\"addNewItem(newItem.value)\">Add to parent's list</button> -->\n\n\n\n    <form [formGroup]=\"searchForm\"> <!-- (ngSubmit)=\"onSubmit(searchForm)\" -->\n\n        <div class=\"row row-cols-1 row-cols-lg-2 row-cols-xl-3\">\n\n            <div class=\"col align-self-center\" style=\"margin-bottom:15px;\"><!-- class=\"thumbnail\" -->\n                <div class=\"col align-self-center\" *ngFor=\"let date of date.controls; let i=index\">\n                    <mat-form-field class=\"col align-self-center\">\n                        \n                        <!-- <mat-select placeholder= {{date.value}} [formControl]=\"date\">  -->          \n                        <mat-select class=\"col align-self-center\" placeholder=\"Choisir une date\" [formControl]=\"date\">\n                            <!--                         \n                                <mat-select-trigger>\n                                    {{date.value ? date.value[0] : ''}}\n                                    <span *ngIf=\"date.value?.length > 1\" class=\"example-additional-selection\">\n                                        ({{date.value.length}} {{'dates'}})\n                                    </span>\n                                </mat-select-trigger>        \n                            -->\n                            <mat-option class=\"col align-self-center\" *ngFor=\"let fish of date$\" [value]=\"fish.date\" (click)=\"onSelect()\"><b>{{ fish.date | date: 'dd/MM/yyyy' }}</b>\n                            </mat-option>\n                            <!--  | date: 'dd/MM/yyyy' ATTENTION : PIPE EN CONFLIT POSSIBLE AVEC SATURN DATEPICKER -->\n                        </mat-select>\n\n                    </mat-form-field>\n                </div>\n            </div>\n    \n            <!-- AUTRE VERSION (AVEC SAT-DATE-PICKER) :\n                <div class=\"thumbnail\">\n                    <div>\n                        <mat-form-field>\n                        <input matInput placeholder=\"Choose a date\" [satDatepicker]=\"picker\" [formControl]=\"date\">\n                        <sat-datepicker-toggle matSuffix [for]=\"picker\"></sat-datepicker-toggle>\n                        <sat-datepicker [rangeMode]=\"false\" [closeAfterSelection]=\"true\" startView=\"year\" touchUi #picker>\n                        </sat-datepicker>\n                        </mat-form-field>\n                    </div>\n                </div>\n            -->\n    \n            <div class=\"col align-self-center\" style=\"margin-bottom:15px;\">\n                <div class=\"col align-self-center\" *ngFor=\"let nameSp of nameSp.controls; let i=index\">\n                    <mat-form-field class=\"col align-self-center\">       \n                        <mat-select placeholder=\"Espèce\" [formControl]=\"nameSp\"> <!-- multiple -->\n                            <mat-option *ngFor=\"let fish of nameSp$; let i = index\" [value]=\"fish.name_specie\" (click)=\"onSelect()\"><b>{{ fish.name_specie }}</b></mat-option>\n                        </mat-select>\n                    </mat-form-field>\n                </div>\n            </div>\n    \n            <!-- SUPER-ZONES :\n                <div class=\"thumbnail\">\n                    <div *ngFor=\"let superZ of superZ.controls; let i=index\">\n                        <mat-form-field>\n                        <mat-select placeholder=\"Super-Zone\" [formControl]=\"superZ\" multiple>\n                            <mat-select-trigger>\n                                {{superZ.value ? superZ.value[0] : ''}}\n                                <span *ngIf=\"superZ.value?.length > 1\" class=\"example-additional-selection\">\n                                ({{superZ.value.length}} {{'super-zones'}})\n                                </span>\n                            </mat-select-trigger>\n                            <mat-option *ngFor=\"let fish of superZone$\" [value]=\"fish.super_zone\">\n                            {{ fish.super_zone }}\n                            </mat-option>\n                        </mat-select>\n                        </mat-form-field>\n                    </div>\n                </div>\n            -->\n  \n            <div class=\"col align-self-center\" style=\"margin-bottom:15px;\">\n                <div class=\"col align-self-center\" *ngFor=\"let zone of zone.controls; let i=index\">\n                    <mat-form-field class=\"col align-self-center\">\n                    <mat-select placeholder=\"Zone\" [formControl]=\"zone\"><!--  multiple -->\n                    <!--\n                        <mat-select-trigger>\n                            {{zone.value ? zone.value[0] : ''}}\n                            <span *ngIf=\"zone.value?.length > 1\" class=\"example-additional-selection\">\n                                ({{zone.value.length}} {{'zones'}})\n                            </span>\n                        </mat-select-trigger>\n                    -->\n                        <mat-option *ngFor=\"let fish of zone$\" [value]=\"fish.zone\" (click)=\"onSelect()\"><b>{{ fish.zone }}</b>\n                        </mat-option>\n                    </mat-select>\n                    </mat-form-field>\n                </div>\n            </div>\n    \n            <div class=\"col align-self-center\" style=\"margin-bottom:15px;\">\n                <div class=\"col align-self-center\">\n                    <mat-form-field class=\"col align-self-center\" id=\"datepicker\">\n                        <input matInput class=\"matselectclass\" [formControl]=\"date2\" placeholder=\"Choisir une plage de dates\" [satDatepicker]=\"picker\"> \n                        <!-- style=\"padding-right: 12px;\" -->\n                        <sat-datepicker #picker [rangeMode]=\"true\" orderPeriodLabel=\"month\" [closeAfterSelection]=\"true\" startView=\"year\" touchUi (click)=\"onSelect()\">\n                        </sat-datepicker>\n                        <sat-datepicker-toggle matSuffix [for]=\"picker\">\n                        </sat-datepicker-toggle>\n                    </mat-form-field>\n                </div>\n            </div>\n\n        </div>\n  \n    </form>\n\n</div>\n\n\n<div class=\"submit\">\n\n    <div class=\"row\">\n        <!-- currentnameSp (et autres) = ref aux exports de 'search-form.component.ts'-->\n        <!-- [nameSpecieSelect] = ref aux imports dans 'date-chart.component.ts'-->\n\n        <!-- <div class=\"mx-auto col-12 col-lg-6 col-xl-4\"> -->\n            <app-dates-chart \n                [nameSpecieSelect]=\"currentnameSp\" \n                [zoneSelect]=\"currentZone\"\n                [dateSelect]=\"currentDate\"\n                [date2BeginSelect]=\"currentDate2Begin\"\n                [date2EndSelect]=\"currentDate2End\"\n            >\n            </app-dates-chart><!-- 'currentnameSp' = ancien 'currentItem' -->\n        <!-- </div> -->\n\n        <!-- <div class=\"mx-auto col-12 col-lg-6 col-xl-4\"> -->\n            <app-species-chart \n                [nameSpecieSelect]=\"currentnameSp\" \n                [zoneSelect]=\"currentZone\"\n                [dateSelect]=\"currentDate\"\n                [date2BeginSelect]=\"currentDate2Begin\"\n                [date2EndSelect]=\"currentDate2End\"\n            >\n            </app-species-chart><!-- 'currentnameSp' = ancien 'currentItem' -->\n        <!-- </div> -->\n\n        <!-- <div class=\"mx-auto col-12 col-lg-6 col-xl-4\"> -->\n            <app-zones-map \n                [nameSpecieSelect]=\"currentnameSp\" \n                [zoneSelect]=\"currentZone\"\n                [dateSelect]=\"currentDate\"\n                [date2BeginSelect]=\"currentDate2Begin\"\n                [date2EndSelect]=\"currentDate2End\"\n            >\n            </app-zones-map><!-- 'currentnameSp' = ancien 'currentItem' -->\n        <!-- </div> -->\n        \n    </div>\n\n    <br />\n    \n    <div class=\"\" align=\"center\">\n        <!-- <button mat-button class=\"button\" (click)=\"addNameSp($event)\">Réinitialiser</button> -->\n        <button mat-button class=\"button\" (click)=\"onReset()\">Réinitialiser</button>\n    </div>\n\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/species-chart/species-chart.component.html":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/species-chart/species-chart.component.html ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- pour TEST : import composant parent > enfant -->\n\n<!-- \n    <p>\n        Today's Chart NameSpecie : {{nameSpecieSelect}}\n        <br />\n        Today's Chart Zone : {{zoneSelect}}\n        <br />\n        Today's Chart Date 1 : {{dateSelect}}\n        <br />\n        Today's Chart Date 2 Begin : {{date2BeginSelect}}\n        <br />\n        Today's Chart Date 2 End : {{date2EndSelect}}\n    </p>\n-->\n\n\n<div class=\"mx-auto col-12 col-lg-6 col-xl-4\">\n    <a href=\"\" data-toggle=\"modal\" data-target=\"#barChartModale\" (click)=\"onSpeciesLabels()\"><img id=\"formsubmit\" src =\"../../../../assets/img/serveimage.png\" width=\"400\" height=\"200\" title=\"Fishing Map\" alt=\"Fishing Map\"></a>\n</div>\n\n<div class=\"modal fade\" id=\"barChartModale\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"barChartModaleTitle\" aria-hidden=\"true\">\n    <div class=\"modal-dialog modal-dialog-centered modal-xl\" role=\"document\">\n        <div class=\"modal-content\">\n\n            <div class=\"modal-header\">\n                <h5 class=\"modal-title\" id=\"barChartModaleLongTitle\">Barres d'espèces</h5>\n                <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                    <span aria-hidden=\"true\">&times;</span>\n                </button>\n            </div>\n\n            <div class=\"container\">\n                <app-chart-update [type]=\"type\" [data]=\"data\" [options]=\"options\">\n                </app-chart-update>\n            </div>\n\n            <div class=\"modal-footer\">\n                <button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Fermer</button>\n            </div>\n\n        </div>\n    </div>\n</div>\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/tabs.component.html":
/*!***********************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/tabs.component.html ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<div class=\"gallery\">\n\n  <mat-tab-group>\n\n    <mat-tab label=\"Graphiques et Carte\">\n      \n      <!-- formulaire de connexion (membre) et accès aux données (tableau, graphiques, carte...) -->\n      <app-form-connexion></app-form-connexion>\n\n    </mat-tab>\n\n    <mat-tab label=\"Administrateur\">\n\n      <!-- formulaire d'accès à la partie administrateur : gestion des membres -->\n      <app-form-admin-connexion></app-form-admin-connexion>\n\n    </mat-tab>\n\n  </mat-tab-group>  \n  \n  <app-data-table></app-data-table>\n\n</div>");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/zones-map/zones-map.component.html":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/zones-map/zones-map.component.html ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!-- pour TEST : import composant parent > enfant -->\n<!-- \n    <p>\n        Today's Chart NameSpecie : {{nameSpecieSelect}}\n        <br />\n        Today's Chart Zone : {{zoneSelect}}\n        <br />\n        Today's Chart Date 1 : {{dateSelect}}\n        <br />\n        Today's Chart Date 2 Begin : {{date2BeginSelect}}\n        <br />\n        Today's Chart Date 2 End : {{date2EndSelect}}\n    </p>\n-->\n\n<div class=\"mx-auto col-12 col-lg-6 col-xl-4\">\n    <a href=\"\" data-toggle=\"modal\" data-target=\"#mapZonesModale\" (click)=\"onZonesLabels()\"><img id=\"formsubmit\" src =\"../../../../assets/img/serveimage-map3.jpeg\" width=\"400\" height=\"200\" title=\"Fishing BarChart\" alt=\"Fishing BarChart\"></a>\n</div>\n\n<div class=\"modal fade\" id=\"mapZonesModale\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"mapZonesModaleTitle\" aria-hidden=\"true\">\n    <div class=\"modal-dialog modal-dialog-centered modal-xl\" role=\"document\">\n        <div class=\"modal-content\" style=\"width: auto;\">\n\n            <div class=\"modal-header\">\n                <h5 class=\"modal-title\" id=\"mapZonesModaleLongTitle\">Carte des zones</h5>\n                <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                    <span aria-hidden=\"true\">&times;</span>\n                </button>\n            </div>\n\n            <div class=\"modal-body\">\n                <div leaflet id=\"myfrugalmap\"\n                    (leafletMapReady)=\"onMapReady($event)\"\n                    [leafletOptions]=\"options\">\n                </div> \n            </div>\n            <div class=\"modal-footer\">\n                <button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\">Fermer</button>\n            </div>\n\n        </div>\n    </div>\n</div>\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/zone.js/dist/zone.js":
/*!*******************************************!*\
  !*** ./node_modules/zone.js/dist/zone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
* @license
* Copyright Google Inc. All Rights Reserved.
*
* Use of this source code is governed by an MIT-style license that can be
* found in the LICENSE file at https://angular.io/license
*/
(function (global, factory) {
	 true ? factory() :
	undefined;
}(this, (function () { 'use strict';

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var Zone$1 = (function (global) {
    var performance = global['performance'];
    function mark(name) {
        performance && performance['mark'] && performance['mark'](name);
    }
    function performanceMeasure(name, label) {
        performance && performance['measure'] && performance['measure'](name, label);
    }
    mark('Zone');
    var checkDuplicate = global[('__zone_symbol__forceDuplicateZoneCheck')] === true;
    if (global['Zone']) {
        // if global['Zone'] already exists (maybe zone.js was already loaded or
        // some other lib also registered a global object named Zone), we may need
        // to throw an error, but sometimes user may not want this error.
        // For example,
        // we have two web pages, page1 includes zone.js, page2 doesn't.
        // and the 1st time user load page1 and page2, everything work fine,
        // but when user load page2 again, error occurs because global['Zone'] already exists.
        // so we add a flag to let user choose whether to throw this error or not.
        // By default, if existing Zone is from zone.js, we will not throw the error.
        if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {
            throw new Error('Zone already loaded.');
        }
        else {
            return global['Zone'];
        }
    }
    var Zone = /** @class */ (function () {
        function Zone(parent, zoneSpec) {
            this._parent = parent;
            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
            this._properties = zoneSpec && zoneSpec.properties || {};
            this._zoneDelegate =
                new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
        }
        Zone.assertZonePatched = function () {
            if (global['Promise'] !== patches['ZoneAwarePromise']) {
                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +
                    'has been overwritten.\n' +
                    'Most likely cause is that a Promise polyfill has been loaded ' +
                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +
                    'If you must load one, do so before loading zone.js.)');
            }
        };
        Object.defineProperty(Zone, "root", {
            get: function () {
                var zone = Zone.current;
                while (zone.parent) {
                    zone = zone.parent;
                }
                return zone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Zone, "current", {
            get: function () {
                return _currentZoneFrame.zone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Zone, "currentTask", {
            get: function () {
                return _currentTask;
            },
            enumerable: true,
            configurable: true
        });
        Zone.__load_patch = function (name, fn) {
            if (patches.hasOwnProperty(name)) {
                if (checkDuplicate) {
                    throw Error('Already loaded patch: ' + name);
                }
            }
            else if (!global['__Zone_disable_' + name]) {
                var perfName = 'Zone:' + name;
                mark(perfName);
                patches[name] = fn(global, Zone, _api);
                performanceMeasure(perfName, perfName);
            }
        };
        Object.defineProperty(Zone.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Zone.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Zone.prototype.get = function (key) {
            var zone = this.getZoneWith(key);
            if (zone)
                return zone._properties[key];
        };
        Zone.prototype.getZoneWith = function (key) {
            var current = this;
            while (current) {
                if (current._properties.hasOwnProperty(key)) {
                    return current;
                }
                current = current._parent;
            }
            return null;
        };
        Zone.prototype.fork = function (zoneSpec) {
            if (!zoneSpec)
                throw new Error('ZoneSpec required!');
            return this._zoneDelegate.fork(this, zoneSpec);
        };
        Zone.prototype.wrap = function (callback, source) {
            if (typeof callback !== 'function') {
                throw new Error('Expecting function got: ' + callback);
            }
            var _callback = this._zoneDelegate.intercept(this, callback, source);
            var zone = this;
            return function () {
                return zone.runGuarded(_callback, this, arguments, source);
            };
        };
        Zone.prototype.run = function (callback, applyThis, applyArgs, source) {
            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
            try {
                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        };
        Zone.prototype.runGuarded = function (callback, applyThis, applyArgs, source) {
            if (applyThis === void 0) { applyThis = null; }
            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
            try {
                try {
                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
                }
                catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) {
                        throw error;
                    }
                }
            }
            finally {
                _currentZoneFrame = _currentZoneFrame.parent;
            }
        };
        Zone.prototype.runTask = function (task, applyThis, applyArgs) {
            if (task.zone != this) {
                throw new Error('A task can only be run in the zone of creation! (Creation: ' +
                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            }
            // https://github.com/angular/zone.js/issues/778, sometimes eventTask
            // will run in notScheduled(canceled) state, we should not try to
            // run such kind of task but just return
            if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {
                return;
            }
            var reEntryGuard = task.state != running;
            reEntryGuard && task._transitionTo(running, scheduled);
            task.runCount++;
            var previousTask = _currentTask;
            _currentTask = task;
            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
            try {
                if (task.type == macroTask && task.data && !task.data.isPeriodic) {
                    task.cancelFn = undefined;
                }
                try {
                    return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
                }
                catch (error) {
                    if (this._zoneDelegate.handleError(this, error)) {
                        throw error;
                    }
                }
            }
            finally {
                // if the task's state is notScheduled or unknown, then it has already been cancelled
                // we should not reset the state to scheduled
                if (task.state !== notScheduled && task.state !== unknown) {
                    if (task.type == eventTask || (task.data && task.data.isPeriodic)) {
                        reEntryGuard && task._transitionTo(scheduled, running);
                    }
                    else {
                        task.runCount = 0;
                        this._updateTaskCount(task, -1);
                        reEntryGuard &&
                            task._transitionTo(notScheduled, running, notScheduled);
                    }
                }
                _currentZoneFrame = _currentZoneFrame.parent;
                _currentTask = previousTask;
            }
        };
        Zone.prototype.scheduleTask = function (task) {
            if (task.zone && task.zone !== this) {
                // check if the task was rescheduled, the newZone
                // should not be the children of the original zone
                var newZone = this;
                while (newZone) {
                    if (newZone === task.zone) {
                        throw Error("can not reschedule task to " + this.name + " which is descendants of the original zone " + task.zone.name);
                    }
                    newZone = newZone.parent;
                }
            }
            task._transitionTo(scheduling, notScheduled);
            var zoneDelegates = [];
            task._zoneDelegates = zoneDelegates;
            task._zone = this;
            try {
                task = this._zoneDelegate.scheduleTask(this, task);
            }
            catch (err) {
                // should set task's state to unknown when scheduleTask throw error
                // because the err may from reschedule, so the fromState maybe notScheduled
                task._transitionTo(unknown, scheduling, notScheduled);
                // TODO: @JiaLiPassion, should we check the result from handleError?
                this._zoneDelegate.handleError(this, err);
                throw err;
            }
            if (task._zoneDelegates === zoneDelegates) {
                // we have to check because internally the delegate can reschedule the task.
                this._updateTaskCount(task, 1);
            }
            if (task.state == scheduling) {
                task._transitionTo(scheduled, scheduling);
            }
            return task;
        };
        Zone.prototype.scheduleMicroTask = function (source, callback, data, customSchedule) {
            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));
        };
        Zone.prototype.scheduleMacroTask = function (source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
        };
        Zone.prototype.scheduleEventTask = function (source, callback, data, customSchedule, customCancel) {
            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
        };
        Zone.prototype.cancelTask = function (task) {
            if (task.zone != this)
                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +
                    (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
            task._transitionTo(canceling, scheduled, running);
            try {
                this._zoneDelegate.cancelTask(this, task);
            }
            catch (err) {
                // if error occurs when cancelTask, transit the state to unknown
                task._transitionTo(unknown, canceling);
                this._zoneDelegate.handleError(this, err);
                throw err;
            }
            this._updateTaskCount(task, -1);
            task._transitionTo(notScheduled, canceling);
            task.runCount = 0;
            return task;
        };
        Zone.prototype._updateTaskCount = function (task, count) {
            var zoneDelegates = task._zoneDelegates;
            if (count == -1) {
                task._zoneDelegates = null;
            }
            for (var i = 0; i < zoneDelegates.length; i++) {
                zoneDelegates[i]._updateTaskCount(task.type, count);
            }
        };
        Zone.__symbol__ = __symbol__;
        return Zone;
    }());
    var DELEGATE_ZS = {
        name: '',
        onHasTask: function (delegate, _, target, hasTaskState) { return delegate.hasTask(target, hasTaskState); },
        onScheduleTask: function (delegate, _, target, task) {
            return delegate.scheduleTask(target, task);
        },
        onInvokeTask: function (delegate, _, target, task, applyThis, applyArgs) {
            return delegate.invokeTask(target, task, applyThis, applyArgs);
        },
        onCancelTask: function (delegate, _, target, task) { return delegate.cancelTask(target, task); }
    };
    var ZoneDelegate = /** @class */ (function () {
        function ZoneDelegate(zone, parentDelegate, zoneSpec) {
            this._taskCounts = { 'microTask': 0, 'macroTask': 0, 'eventTask': 0 };
            this.zone = zone;
            this._parentDelegate = parentDelegate;
            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
            this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);
            this._interceptZS =
                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
            this._interceptDlgt =
                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
            this._interceptCurrZone =
                zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);
            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
            this._invokeDlgt =
                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
            this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);
            this._handleErrorZS =
                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
            this._handleErrorDlgt =
                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
            this._handleErrorCurrZone =
                zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);
            this._scheduleTaskZS =
                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
            this._scheduleTaskDlgt = zoneSpec &&
                (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
            this._scheduleTaskCurrZone =
                zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);
            this._invokeTaskZS =
                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
            this._invokeTaskDlgt =
                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
            this._invokeTaskCurrZone =
                zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);
            this._cancelTaskZS =
                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
            this._cancelTaskDlgt =
                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
            this._cancelTaskCurrZone =
                zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);
            this._hasTaskZS = null;
            this._hasTaskDlgt = null;
            this._hasTaskDlgtOwner = null;
            this._hasTaskCurrZone = null;
            var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
            var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
            if (zoneSpecHasTask || parentHasTask) {
                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
                // a case all task related interceptors must go through this ZD. We can't short circuit it.
                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
                this._hasTaskDlgt = parentDelegate;
                this._hasTaskDlgtOwner = this;
                this._hasTaskCurrZone = zone;
                if (!zoneSpec.onScheduleTask) {
                    this._scheduleTaskZS = DELEGATE_ZS;
                    this._scheduleTaskDlgt = parentDelegate;
                    this._scheduleTaskCurrZone = this.zone;
                }
                if (!zoneSpec.onInvokeTask) {
                    this._invokeTaskZS = DELEGATE_ZS;
                    this._invokeTaskDlgt = parentDelegate;
                    this._invokeTaskCurrZone = this.zone;
                }
                if (!zoneSpec.onCancelTask) {
                    this._cancelTaskZS = DELEGATE_ZS;
                    this._cancelTaskDlgt = parentDelegate;
                    this._cancelTaskCurrZone = this.zone;
                }
            }
        }
        ZoneDelegate.prototype.fork = function (targetZone, zoneSpec) {
            return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) :
                new Zone(targetZone, zoneSpec);
        };
        ZoneDelegate.prototype.intercept = function (targetZone, callback, source) {
            return this._interceptZS ?
                this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) :
                callback;
        };
        ZoneDelegate.prototype.invoke = function (targetZone, callback, applyThis, applyArgs, source) {
            return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) :
                callback.apply(applyThis, applyArgs);
        };
        ZoneDelegate.prototype.handleError = function (targetZone, error) {
            return this._handleErrorZS ?
                this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) :
                true;
        };
        ZoneDelegate.prototype.scheduleTask = function (targetZone, task) {
            var returnTask = task;
            if (this._scheduleTaskZS) {
                if (this._hasTaskZS) {
                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
                }
                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
                if (!returnTask)
                    returnTask = task;
            }
            else {
                if (task.scheduleFn) {
                    task.scheduleFn(task);
                }
                else if (task.type == microTask) {
                    scheduleMicroTask(task);
                }
                else {
                    throw new Error('Task is missing scheduleFn.');
                }
            }
            return returnTask;
        };
        ZoneDelegate.prototype.invokeTask = function (targetZone, task, applyThis, applyArgs) {
            return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) :
                task.callback.apply(applyThis, applyArgs);
        };
        ZoneDelegate.prototype.cancelTask = function (targetZone, task) {
            var value;
            if (this._cancelTaskZS) {
                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
            }
            else {
                if (!task.cancelFn) {
                    throw Error('Task is not cancelable');
                }
                value = task.cancelFn(task);
            }
            return value;
        };
        ZoneDelegate.prototype.hasTask = function (targetZone, isEmpty) {
            // hasTask should not throw error so other ZoneDelegate
            // can still trigger hasTask callback
            try {
                this._hasTaskZS &&
                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
            }
            catch (err) {
                this.handleError(targetZone, err);
            }
        };
        ZoneDelegate.prototype._updateTaskCount = function (type, count) {
            var counts = this._taskCounts;
            var prev = counts[type];
            var next = counts[type] = prev + count;
            if (next < 0) {
                throw new Error('More tasks executed then were scheduled.');
            }
            if (prev == 0 || next == 0) {
                var isEmpty = {
                    microTask: counts['microTask'] > 0,
                    macroTask: counts['macroTask'] > 0,
                    eventTask: counts['eventTask'] > 0,
                    change: type
                };
                this.hasTask(this.zone, isEmpty);
            }
        };
        return ZoneDelegate;
    }());
    var ZoneTask = /** @class */ (function () {
        function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {
            this._zone = null;
            this.runCount = 0;
            this._zoneDelegates = null;
            this._state = 'notScheduled';
            this.type = type;
            this.source = source;
            this.data = options;
            this.scheduleFn = scheduleFn;
            this.cancelFn = cancelFn;
            this.callback = callback;
            var self = this;
            // TODO: @JiaLiPassion options should have interface
            if (type === eventTask && options && options.useG) {
                this.invoke = ZoneTask.invokeTask;
            }
            else {
                this.invoke = function () {
                    return ZoneTask.invokeTask.call(global, self, this, arguments);
                };
            }
        }
        ZoneTask.invokeTask = function (task, target, args) {
            if (!task) {
                task = this;
            }
            _numberOfNestedTaskFrames++;
            try {
                task.runCount++;
                return task.zone.runTask(task, target, args);
            }
            finally {
                if (_numberOfNestedTaskFrames == 1) {
                    drainMicroTaskQueue();
                }
                _numberOfNestedTaskFrames--;
            }
        };
        Object.defineProperty(ZoneTask.prototype, "zone", {
            get: function () {
                return this._zone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ZoneTask.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        ZoneTask.prototype.cancelScheduleRequest = function () {
            this._transitionTo(notScheduled, scheduling);
        };
        ZoneTask.prototype._transitionTo = function (toState, fromState1, fromState2) {
            if (this._state === fromState1 || this._state === fromState2) {
                this._state = toState;
                if (toState == notScheduled) {
                    this._zoneDelegates = null;
                }
            }
            else {
                throw new Error(this.type + " '" + this.source + "': can not transition to '" + toState + "', expecting state '" + fromState1 + "'" + (fromState2 ? ' or \'' + fromState2 + '\'' : '') + ", was '" + this._state + "'.");
            }
        };
        ZoneTask.prototype.toString = function () {
            if (this.data && typeof this.data.handleId !== 'undefined') {
                return this.data.handleId.toString();
            }
            else {
                return Object.prototype.toString.call(this);
            }
        };
        // add toJSON method to prevent cyclic error when
        // call JSON.stringify(zoneTask)
        ZoneTask.prototype.toJSON = function () {
            return {
                type: this.type,
                state: this.state,
                source: this.source,
                zone: this.zone.name,
                runCount: this.runCount
            };
        };
        return ZoneTask;
    }());
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    ///  MICROTASK QUEUE
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    var symbolSetTimeout = __symbol__('setTimeout');
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    var _microTaskQueue = [];
    var _isDrainingMicrotaskQueue = false;
    var nativeMicroTaskQueuePromise;
    function scheduleMicroTask(task) {
        // if we are not running in any task, and there has not been anything scheduled
        // we must bootstrap the initial task creation by manually scheduling the drain
        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
            // We are not running in Task, so we need to kickstart the microtask queue.
            if (!nativeMicroTaskQueuePromise) {
                if (global[symbolPromise]) {
                    nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
                }
            }
            if (nativeMicroTaskQueuePromise) {
                var nativeThen = nativeMicroTaskQueuePromise[symbolThen];
                if (!nativeThen) {
                    // native Promise is not patchable, we need to use `then` directly
                    // issue 1078
                    nativeThen = nativeMicroTaskQueuePromise['then'];
                }
                nativeThen.call(nativeMicroTaskQueuePromise, drainMicroTaskQueue);
            }
            else {
                global[symbolSetTimeout](drainMicroTaskQueue, 0);
            }
        }
        task && _microTaskQueue.push(task);
    }
    function drainMicroTaskQueue() {
        if (!_isDrainingMicrotaskQueue) {
            _isDrainingMicrotaskQueue = true;
            while (_microTaskQueue.length) {
                var queue = _microTaskQueue;
                _microTaskQueue = [];
                for (var i = 0; i < queue.length; i++) {
                    var task = queue[i];
                    try {
                        task.zone.runTask(task, null, null);
                    }
                    catch (error) {
                        _api.onUnhandledError(error);
                    }
                }
            }
            _api.microtaskDrainDone();
            _isDrainingMicrotaskQueue = false;
        }
    }
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    ///  BOOTSTRAP
    //////////////////////////////////////////////////////
    //////////////////////////////////////////////////////
    var NO_ZONE = { name: 'NO ZONE' };
    var notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';
    var microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';
    var patches = {};
    var _api = {
        symbol: __symbol__,
        currentZoneFrame: function () { return _currentZoneFrame; },
        onUnhandledError: noop,
        microtaskDrainDone: noop,
        scheduleMicroTask: scheduleMicroTask,
        showUncaughtError: function () { return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')]; },
        patchEventTarget: function () { return []; },
        patchOnProperties: noop,
        patchMethod: function () { return noop; },
        bindArguments: function () { return []; },
        patchThen: function () { return noop; },
        patchMacroTask: function () { return noop; },
        setNativePromise: function (NativePromise) {
            // sometimes NativePromise.resolve static function
            // is not ready yet, (such as core-js/es6.promise)
            // so we need to check here.
            if (NativePromise && typeof NativePromise.resolve === 'function') {
                nativeMicroTaskQueuePromise = NativePromise.resolve(0);
            }
        },
        patchEventPrototype: function () { return noop; },
        isIEOrEdge: function () { return false; },
        getGlobalObjects: function () { return undefined; },
        ObjectDefineProperty: function () { return noop; },
        ObjectGetOwnPropertyDescriptor: function () { return undefined; },
        ObjectCreate: function () { return undefined; },
        ArraySlice: function () { return []; },
        patchClass: function () { return noop; },
        wrapWithCurrentZone: function () { return noop; },
        filterProperties: function () { return []; },
        attachOriginToPatched: function () { return noop; },
        _redefineProperty: function () { return noop; },
        patchCallbacks: function () { return noop; }
    };
    var _currentZoneFrame = { parent: null, zone: new Zone(null, null) };
    var _currentTask = null;
    var _numberOfNestedTaskFrames = 0;
    function noop() { }
    function __symbol__(name) {
        return '__zone_symbol__' + name;
    }
    performanceMeasure('Zone', 'Zone');
    return global['Zone'] = Zone;
})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);

var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {
    var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ObjectDefineProperty = Object.defineProperty;
    function readableObjectToString(obj) {
        if (obj && obj.toString === Object.prototype.toString) {
            var className = obj.constructor && obj.constructor.name;
            return (className ? className : '') + ': ' + JSON.stringify(obj);
        }
        return obj ? obj.toString() : Object.prototype.toString.call(obj);
    }
    var __symbol__ = api.symbol;
    var _uncaughtPromiseErrors = [];
    var symbolPromise = __symbol__('Promise');
    var symbolThen = __symbol__('then');
    var creationTrace = '__creationTrace__';
    api.onUnhandledError = function (e) {
        if (api.showUncaughtError()) {
            var rejection = e && e.rejection;
            if (rejection) {
                console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
            }
            else {
                console.error(e);
            }
        }
    };
    api.microtaskDrainDone = function () {
        while (_uncaughtPromiseErrors.length) {
            var _loop_1 = function () {
                var uncaughtPromiseError = _uncaughtPromiseErrors.shift();
                try {
                    uncaughtPromiseError.zone.runGuarded(function () {
                        throw uncaughtPromiseError;
                    });
                }
                catch (error) {
                    handleUnhandledRejection(error);
                }
            };
            while (_uncaughtPromiseErrors.length) {
                _loop_1();
            }
        }
    };
    var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');
    function handleUnhandledRejection(e) {
        api.onUnhandledError(e);
        try {
            var handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
            if (handler && typeof handler === 'function') {
                handler.call(this, e);
            }
        }
        catch (err) {
        }
    }
    function isThenable(value) {
        return value && value.then;
    }
    function forwardResolution(value) {
        return value;
    }
    function forwardRejection(rejection) {
        return ZoneAwarePromise.reject(rejection);
    }
    var symbolState = __symbol__('state');
    var symbolValue = __symbol__('value');
    var symbolFinally = __symbol__('finally');
    var symbolParentPromiseValue = __symbol__('parentPromiseValue');
    var symbolParentPromiseState = __symbol__('parentPromiseState');
    var source = 'Promise.then';
    var UNRESOLVED = null;
    var RESOLVED = true;
    var REJECTED = false;
    var REJECTED_NO_CATCH = 0;
    function makeResolver(promise, state) {
        return function (v) {
            try {
                resolvePromise(promise, state, v);
            }
            catch (err) {
                resolvePromise(promise, false, err);
            }
            // Do not return value or you will break the Promise spec.
        };
    }
    var once = function () {
        var wasCalled = false;
        return function wrapper(wrappedFunction) {
            return function () {
                if (wasCalled) {
                    return;
                }
                wasCalled = true;
                wrappedFunction.apply(null, arguments);
            };
        };
    };
    var TYPE_ERROR = 'Promise resolved with itself';
    var CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');
    // Promise Resolution
    function resolvePromise(promise, state, value) {
        var onceWrapper = once();
        if (promise === value) {
            throw new TypeError(TYPE_ERROR);
        }
        if (promise[symbolState] === UNRESOLVED) {
            // should only get value.then once based on promise spec.
            var then = null;
            try {
                if (typeof value === 'object' || typeof value === 'function') {
                    then = value && value.then;
                }
            }
            catch (err) {
                onceWrapper(function () {
                    resolvePromise(promise, false, err);
                })();
                return promise;
            }
            // if (value instanceof ZoneAwarePromise) {
            if (state !== REJECTED && value instanceof ZoneAwarePromise &&
                value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) &&
                value[symbolState] !== UNRESOLVED) {
                clearRejectedNoCatch(value);
                resolvePromise(promise, value[symbolState], value[symbolValue]);
            }
            else if (state !== REJECTED && typeof then === 'function') {
                try {
                    then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
                }
                catch (err) {
                    onceWrapper(function () {
                        resolvePromise(promise, false, err);
                    })();
                }
            }
            else {
                promise[symbolState] = state;
                var queue = promise[symbolValue];
                promise[symbolValue] = value;
                if (promise[symbolFinally] === symbolFinally) {
                    // the promise is generated by Promise.prototype.finally
                    if (state === RESOLVED) {
                        // the state is resolved, should ignore the value
                        // and use parent promise value
                        promise[symbolState] = promise[symbolParentPromiseState];
                        promise[symbolValue] = promise[symbolParentPromiseValue];
                    }
                }
                // record task information in value when error occurs, so we can
                // do some additional work such as render longStackTrace
                if (state === REJECTED && value instanceof Error) {
                    // check if longStackTraceZone is here
                    var trace = Zone.currentTask && Zone.currentTask.data &&
                        Zone.currentTask.data[creationTrace];
                    if (trace) {
                        // only keep the long stack trace into error when in longStackTraceZone
                        ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, { configurable: true, enumerable: false, writable: true, value: trace });
                    }
                }
                for (var i = 0; i < queue.length;) {
                    scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
                }
                if (queue.length == 0 && state == REJECTED) {
                    promise[symbolState] = REJECTED_NO_CATCH;
                    try {
                        // try to print more readable error log
                        throw new Error('Uncaught (in promise): ' + readableObjectToString(value) +
                            (value && value.stack ? '\n' + value.stack : ''));
                    }
                    catch (err) {
                        var error_1 = err;
                        error_1.rejection = value;
                        error_1.promise = promise;
                        error_1.zone = Zone.current;
                        error_1.task = Zone.currentTask;
                        _uncaughtPromiseErrors.push(error_1);
                        api.scheduleMicroTask(); // to make sure that it is running
                    }
                }
            }
        }
        // Resolving an already resolved promise is a noop.
        return promise;
    }
    var REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');
    function clearRejectedNoCatch(promise) {
        if (promise[symbolState] === REJECTED_NO_CATCH) {
            // if the promise is rejected no catch status
            // and queue.length > 0, means there is a error handler
            // here to handle the rejected promise, we should trigger
            // windows.rejectionhandled eventHandler or nodejs rejectionHandled
            // eventHandler
            try {
                var handler = Zone[REJECTION_HANDLED_HANDLER];
                if (handler && typeof handler === 'function') {
                    handler.call(this, { rejection: promise[symbolValue], promise: promise });
                }
            }
            catch (err) {
            }
            promise[symbolState] = REJECTED;
            for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {
                if (promise === _uncaughtPromiseErrors[i].promise) {
                    _uncaughtPromiseErrors.splice(i, 1);
                }
            }
        }
    }
    function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
        clearRejectedNoCatch(promise);
        var promiseState = promise[symbolState];
        var delegate = promiseState ?
            (typeof onFulfilled === 'function') ? onFulfilled : forwardResolution :
            (typeof onRejected === 'function') ? onRejected : forwardRejection;
        zone.scheduleMicroTask(source, function () {
            try {
                var parentPromiseValue = promise[symbolValue];
                var isFinallyPromise = chainPromise && symbolFinally === chainPromise[symbolFinally];
                if (isFinallyPromise) {
                    // if the promise is generated from finally call, keep parent promise's state and value
                    chainPromise[symbolParentPromiseValue] = parentPromiseValue;
                    chainPromise[symbolParentPromiseState] = promiseState;
                }
                // should not pass value to finally callback
                var value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ?
                    [] :
                    [parentPromiseValue]);
                resolvePromise(chainPromise, true, value);
            }
            catch (error) {
                // if error occurs, should always return this error
                resolvePromise(chainPromise, false, error);
            }
        }, chainPromise);
    }
    var ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';
    var ZoneAwarePromise = /** @class */ (function () {
        function ZoneAwarePromise(executor) {
            var promise = this;
            if (!(promise instanceof ZoneAwarePromise)) {
                throw new Error('Must be an instanceof Promise.');
            }
            promise[symbolState] = UNRESOLVED;
            promise[symbolValue] = []; // queue;
            try {
                executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
            }
            catch (error) {
                resolvePromise(promise, false, error);
            }
        }
        ZoneAwarePromise.toString = function () {
            return ZONE_AWARE_PROMISE_TO_STRING;
        };
        ZoneAwarePromise.resolve = function (value) {
            return resolvePromise(new this(null), RESOLVED, value);
        };
        ZoneAwarePromise.reject = function (error) {
            return resolvePromise(new this(null), REJECTED, error);
        };
        ZoneAwarePromise.race = function (values) {
            var e_1, _a;
            var resolve;
            var reject;
            var promise = new this(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            function onResolve(value) {
                resolve(value);
            }
            function onReject(error) {
                reject(error);
            }
            try {
                for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                    var value = values_1_1.value;
                    if (!isThenable(value)) {
                        value = this.resolve(value);
                    }
                    value.then(onResolve, onReject);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return promise;
        };
        ZoneAwarePromise.all = function (values) {
            var e_2, _a;
            var resolve;
            var reject;
            var promise = new this(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            // Start at 2 to prevent prematurely resolving if .then is called immediately.
            var unresolvedCount = 2;
            var valueIndex = 0;
            var resolvedValues = [];
            var _loop_2 = function (value) {
                if (!isThenable(value)) {
                    value = this_1.resolve(value);
                }
                var curValueIndex = valueIndex;
                value.then(function (value) {
                    resolvedValues[curValueIndex] = value;
                    unresolvedCount--;
                    if (unresolvedCount === 0) {
                        resolve(resolvedValues);
                    }
                }, reject);
                unresolvedCount++;
                valueIndex++;
            };
            var this_1 = this;
            try {
                for (var values_2 = __values(values), values_2_1 = values_2.next(); !values_2_1.done; values_2_1 = values_2.next()) {
                    var value = values_2_1.value;
                    _loop_2(value);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (values_2_1 && !values_2_1.done && (_a = values_2.return)) _a.call(values_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // Make the unresolvedCount zero-based again.
            unresolvedCount -= 2;
            if (unresolvedCount === 0) {
                resolve(resolvedValues);
            }
            return promise;
        };
        Object.defineProperty(ZoneAwarePromise.prototype, Symbol.toStringTag, {
            get: function () {
                return 'Promise';
            },
            enumerable: true,
            configurable: true
        });
        ZoneAwarePromise.prototype.then = function (onFulfilled, onRejected) {
            var chainPromise = new this.constructor(null);
            var zone = Zone.current;
            if (this[symbolState] == UNRESOLVED) {
                this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
            }
            else {
                scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
            }
            return chainPromise;
        };
        ZoneAwarePromise.prototype.catch = function (onRejected) {
            return this.then(null, onRejected);
        };
        ZoneAwarePromise.prototype.finally = function (onFinally) {
            var chainPromise = new this.constructor(null);
            chainPromise[symbolFinally] = symbolFinally;
            var zone = Zone.current;
            if (this[symbolState] == UNRESOLVED) {
                this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
            }
            else {
                scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
            }
            return chainPromise;
        };
        return ZoneAwarePromise;
    }());
    // Protect against aggressive optimizers dropping seemingly unused properties.
    // E.g. Closure Compiler in advanced mode.
    ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
    ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
    ZoneAwarePromise['race'] = ZoneAwarePromise.race;
    ZoneAwarePromise['all'] = ZoneAwarePromise.all;
    var NativePromise = global[symbolPromise] = global['Promise'];
    var ZONE_AWARE_PROMISE = Zone.__symbol__('ZoneAwarePromise');
    var desc = ObjectGetOwnPropertyDescriptor(global, 'Promise');
    if (!desc || desc.configurable) {
        desc && delete desc.writable;
        desc && delete desc.value;
        if (!desc) {
            desc = { configurable: true, enumerable: true };
        }
        desc.get = function () {
            // if we already set ZoneAwarePromise, use patched one
            // otherwise return native one.
            return global[ZONE_AWARE_PROMISE] ? global[ZONE_AWARE_PROMISE] : global[symbolPromise];
        };
        desc.set = function (NewNativePromise) {
            if (NewNativePromise === ZoneAwarePromise) {
                // if the NewNativePromise is ZoneAwarePromise
                // save to global
                global[ZONE_AWARE_PROMISE] = NewNativePromise;
            }
            else {
                // if the NewNativePromise is not ZoneAwarePromise
                // for example: after load zone.js, some library just
                // set es6-promise to global, if we set it to global
                // directly, assertZonePatched will fail and angular
                // will not loaded, so we just set the NewNativePromise
                // to global[symbolPromise], so the result is just like
                // we load ES6 Promise before zone.js
                global[symbolPromise] = NewNativePromise;
                if (!NewNativePromise.prototype[symbolThen]) {
                    patchThen(NewNativePromise);
                }
                api.setNativePromise(NewNativePromise);
            }
        };
        ObjectDefineProperty(global, 'Promise', desc);
    }
    global['Promise'] = ZoneAwarePromise;
    var symbolThenPatched = __symbol__('thenPatched');
    function patchThen(Ctor) {
        var proto = Ctor.prototype;
        var prop = ObjectGetOwnPropertyDescriptor(proto, 'then');
        if (prop && (prop.writable === false || !prop.configurable)) {
            // check Ctor.prototype.then propertyDescriptor is writable or not
            // in meteor env, writable is false, we should ignore such case
            return;
        }
        var originalThen = proto.then;
        // Keep a reference to the original method.
        proto[symbolThen] = originalThen;
        Ctor.prototype.then = function (onResolve, onReject) {
            var _this = this;
            var wrapped = new ZoneAwarePromise(function (resolve, reject) {
                originalThen.call(_this, resolve, reject);
            });
            return wrapped.then(onResolve, onReject);
        };
        Ctor[symbolThenPatched] = true;
    }
    api.patchThen = patchThen;
    function zoneify(fn) {
        return function () {
            var resultPromise = fn.apply(this, arguments);
            if (resultPromise instanceof ZoneAwarePromise) {
                return resultPromise;
            }
            var ctor = resultPromise.constructor;
            if (!ctor[symbolThenPatched]) {
                patchThen(ctor);
            }
            return resultPromise;
        };
    }
    if (NativePromise) {
        patchThen(NativePromise);
        var fetch_1 = global['fetch'];
        if (typeof fetch_1 == 'function') {
            global[api.symbol('fetch')] = fetch_1;
            global['fetch'] = zoneify(fetch_1);
        }
    }
    // This is not part of public API, but it is useful for tests, so we expose it.
    Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
    return ZoneAwarePromise;
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Suppress closure compiler errors about unknown 'Zone' variable
 * @fileoverview
 * @suppress {undefinedVars,globalThis,missingRequire}
 */
// issue #989, to reduce bundle size, use short name
/** Object.getOwnPropertyDescriptor */
var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
/** Object.defineProperty */
var ObjectDefineProperty = Object.defineProperty;
/** Object.getPrototypeOf */
var ObjectGetPrototypeOf = Object.getPrototypeOf;
/** Object.create */
var ObjectCreate = Object.create;
/** Array.prototype.slice */
var ArraySlice = Array.prototype.slice;
/** addEventListener string const */
var ADD_EVENT_LISTENER_STR = 'addEventListener';
/** removeEventListener string const */
var REMOVE_EVENT_LISTENER_STR = 'removeEventListener';
/** zoneSymbol addEventListener */
var ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);
/** zoneSymbol removeEventListener */
var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);
/** true string const */
var TRUE_STR = 'true';
/** false string const */
var FALSE_STR = 'false';
/** __zone_symbol__ string const */
var ZONE_SYMBOL_PREFIX = '__zone_symbol__';
function wrapWithCurrentZone(callback, source) {
    return Zone.current.wrap(callback, source);
}
function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
}
var zoneSymbol = Zone.__symbol__;
var isWindowExists = typeof window !== 'undefined';
var internalWindow = isWindowExists ? window : undefined;
var _global = isWindowExists && internalWindow || typeof self === 'object' && self || global;
var REMOVE_ATTRIBUTE = 'removeAttribute';
var NULL_ON_PROP_VALUE = [null];
function bindArguments(args, source) {
    for (var i = args.length - 1; i >= 0; i--) {
        if (typeof args[i] === 'function') {
            args[i] = wrapWithCurrentZone(args[i], source + '_' + i);
        }
    }
    return args;
}
function patchPrototype(prototype, fnNames) {
    var source = prototype.constructor['name'];
    var _loop_1 = function (i) {
        var name_1 = fnNames[i];
        var delegate = prototype[name_1];
        if (delegate) {
            var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name_1);
            if (!isPropertyWritable(prototypeDesc)) {
                return "continue";
            }
            prototype[name_1] = (function (delegate) {
                var patched = function () {
                    return delegate.apply(this, bindArguments(arguments, source + '.' + name_1));
                };
                attachOriginToPatched(patched, delegate);
                return patched;
            })(delegate);
        }
    };
    for (var i = 0; i < fnNames.length; i++) {
        _loop_1(i);
    }
}
function isPropertyWritable(propertyDesc) {
    if (!propertyDesc) {
        return true;
    }
    if (propertyDesc.writable === false) {
        return false;
    }
    return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');
}
var isWebWorker = (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope);
// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
// this code.
var isNode = (!('nw' in _global) && typeof _global.process !== 'undefined' &&
    {}.toString.call(_global.process) === '[object process]');
var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
// we are in electron of nw, so we are both browser and nodejs
// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
// this code.
var isMix = typeof _global.process !== 'undefined' &&
    {}.toString.call(_global.process) === '[object process]' && !isWebWorker &&
    !!(isWindowExists && internalWindow['HTMLElement']);
var zoneSymbolEventNames = {};
var wrapFn = function (event) {
    // https://github.com/angular/zone.js/issues/911, in IE, sometimes
    // event will be undefined, so we need to use window.event
    event = event || _global.event;
    if (!event) {
        return;
    }
    var eventNameSymbol = zoneSymbolEventNames[event.type];
    if (!eventNameSymbol) {
        eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol('ON_PROPERTY' + event.type);
    }
    var target = this || event.target || _global;
    var listener = target[eventNameSymbol];
    var result;
    if (isBrowser && target === internalWindow && event.type === 'error') {
        // window.onerror have different signiture
        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror
        // and onerror callback will prevent default when callback return true
        var errorEvent = event;
        result = listener &&
            listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
        if (result === true) {
            event.preventDefault();
        }
    }
    else {
        result = listener && listener.apply(this, arguments);
        if (result != undefined && !result) {
            event.preventDefault();
        }
    }
    return result;
};
function patchProperty(obj, prop, prototype) {
    var desc = ObjectGetOwnPropertyDescriptor(obj, prop);
    if (!desc && prototype) {
        // when patch window object, use prototype to check prop exist or not
        var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
        if (prototypeDesc) {
            desc = { enumerable: true, configurable: true };
        }
    }
    // if the descriptor not exists or is not configurable
    // just return
    if (!desc || !desc.configurable) {
        return;
    }
    var onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');
    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
        return;
    }
    // A property descriptor cannot have getter/setter and be writable
    // deleting the writable and value properties avoids this error:
    //
    // TypeError: property descriptors must not specify a value or be writable when a
    // getter or setter has been specified
    delete desc.writable;
    delete desc.value;
    var originalDescGet = desc.get;
    var originalDescSet = desc.set;
    // substr(2) cuz 'onclick' -> 'click', etc
    var eventName = prop.substr(2);
    var eventNameSymbol = zoneSymbolEventNames[eventName];
    if (!eventNameSymbol) {
        eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol('ON_PROPERTY' + eventName);
    }
    desc.set = function (newValue) {
        // in some of windows's onproperty callback, this is undefined
        // so we need to check it
        var target = this;
        if (!target && obj === _global) {
            target = _global;
        }
        if (!target) {
            return;
        }
        var previousValue = target[eventNameSymbol];
        if (previousValue) {
            target.removeEventListener(eventName, wrapFn);
        }
        // issue #978, when onload handler was added before loading zone.js
        // we should remove it with originalDescSet
        if (originalDescSet) {
            originalDescSet.apply(target, NULL_ON_PROP_VALUE);
        }
        if (typeof newValue === 'function') {
            target[eventNameSymbol] = newValue;
            target.addEventListener(eventName, wrapFn, false);
        }
        else {
            target[eventNameSymbol] = null;
        }
    };
    // The getter would return undefined for unassigned properties but the default value of an
    // unassigned property is null
    desc.get = function () {
        // in some of windows's onproperty callback, this is undefined
        // so we need to check it
        var target = this;
        if (!target && obj === _global) {
            target = _global;
        }
        if (!target) {
            return null;
        }
        var listener = target[eventNameSymbol];
        if (listener) {
            return listener;
        }
        else if (originalDescGet) {
            // result will be null when use inline event attribute,
            // such as <button onclick="func();">OK</button>
            // because the onclick function is internal raw uncompiled handler
            // the onclick will be evaluated when first time event was triggered or
            // the property is accessed, https://github.com/angular/zone.js/issues/525
            // so we should use original native get to retrieve the handler
            var value = originalDescGet && originalDescGet.call(this);
            if (value) {
                desc.set.call(this, value);
                if (typeof target[REMOVE_ATTRIBUTE] === 'function') {
                    target.removeAttribute(prop);
                }
                return value;
            }
        }
        return null;
    };
    ObjectDefineProperty(obj, prop, desc);
    obj[onPropPatchedSymbol] = true;
}
function patchOnProperties(obj, properties, prototype) {
    if (properties) {
        for (var i = 0; i < properties.length; i++) {
            patchProperty(obj, 'on' + properties[i], prototype);
        }
    }
    else {
        var onProperties = [];
        for (var prop in obj) {
            if (prop.substr(0, 2) == 'on') {
                onProperties.push(prop);
            }
        }
        for (var j = 0; j < onProperties.length; j++) {
            patchProperty(obj, onProperties[j], prototype);
        }
    }
}
var originalInstanceKey = zoneSymbol('originalInstance');
// wrap some native API on `window`
function patchClass(className) {
    var OriginalClass = _global[className];
    if (!OriginalClass)
        return;
    // keep original class in global
    _global[zoneSymbol(className)] = OriginalClass;
    _global[className] = function () {
        var a = bindArguments(arguments, className);
        switch (a.length) {
            case 0:
                this[originalInstanceKey] = new OriginalClass();
                break;
            case 1:
                this[originalInstanceKey] = new OriginalClass(a[0]);
                break;
            case 2:
                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
                break;
            case 3:
                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
                break;
            case 4:
                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
                break;
            default:
                throw new Error('Arg list too long.');
        }
    };
    // attach original delegate to patched function
    attachOriginToPatched(_global[className], OriginalClass);
    var instance = new OriginalClass(function () { });
    var prop;
    for (prop in instance) {
        // https://bugs.webkit.org/show_bug.cgi?id=44721
        if (className === 'XMLHttpRequest' && prop === 'responseBlob')
            continue;
        (function (prop) {
            if (typeof instance[prop] === 'function') {
                _global[className].prototype[prop] = function () {
                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
                };
            }
            else {
                ObjectDefineProperty(_global[className].prototype, prop, {
                    set: function (fn) {
                        if (typeof fn === 'function') {
                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);
                            // keep callback in wrapped function so we can
                            // use it in Function.prototype.toString to return
                            // the native one.
                            attachOriginToPatched(this[originalInstanceKey][prop], fn);
                        }
                        else {
                            this[originalInstanceKey][prop] = fn;
                        }
                    },
                    get: function () {
                        return this[originalInstanceKey][prop];
                    }
                });
            }
        }(prop));
    }
    for (prop in OriginalClass) {
        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
            _global[className][prop] = OriginalClass[prop];
        }
    }
}
function copySymbolProperties(src, dest) {
    if (typeof Object.getOwnPropertySymbols !== 'function') {
        return;
    }
    var symbols = Object.getOwnPropertySymbols(src);
    symbols.forEach(function (symbol) {
        var desc = Object.getOwnPropertyDescriptor(src, symbol);
        Object.defineProperty(dest, symbol, {
            get: function () {
                return src[symbol];
            },
            set: function (value) {
                if (desc && (!desc.writable || typeof desc.set !== 'function')) {
                    // if src[symbol] is not writable or not have a setter, just return
                    return;
                }
                src[symbol] = value;
            },
            enumerable: desc ? desc.enumerable : true,
            configurable: desc ? desc.configurable : true
        });
    });
}
var shouldCopySymbolProperties = false;

function patchMethod(target, name, patchFn) {
    var proto = target;
    while (proto && !proto.hasOwnProperty(name)) {
        proto = ObjectGetPrototypeOf(proto);
    }
    if (!proto && target[name]) {
        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
        proto = target;
    }
    var delegateName = zoneSymbol(name);
    var delegate = null;
    if (proto && !(delegate = proto[delegateName])) {
        delegate = proto[delegateName] = proto[name];
        // check whether proto[name] is writable
        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob
        var desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
        if (isPropertyWritable(desc)) {
            var patchDelegate_1 = patchFn(delegate, delegateName, name);
            proto[name] = function () {
                return patchDelegate_1(this, arguments);
            };
            attachOriginToPatched(proto[name], delegate);
            if (shouldCopySymbolProperties) {
                copySymbolProperties(delegate, proto[name]);
            }
        }
    }
    return delegate;
}
// TODO: @JiaLiPassion, support cancel task later if necessary
function patchMacroTask(obj, funcName, metaCreator) {
    var setNative = null;
    function scheduleTask(task) {
        var data = task.data;
        data.args[data.cbIdx] = function () {
            task.invoke.apply(this, arguments);
        };
        setNative.apply(data.target, data.args);
        return task;
    }
    setNative = patchMethod(obj, funcName, function (delegate) { return function (self, args) {
        var meta = metaCreator(self, args);
        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {
            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
        }
        else {
            // cause an error by calling it directly.
            return delegate.apply(self, args);
        }
    }; });
}

function attachOriginToPatched(patched, original) {
    patched[zoneSymbol('OriginalDelegate')] = original;
}
var isDetectedIEOrEdge = false;
var ieOrEdge = false;
function isIE() {
    try {
        var ua = internalWindow.navigator.userAgent;
        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {
            return true;
        }
    }
    catch (error) {
    }
    return false;
}
function isIEOrEdge() {
    if (isDetectedIEOrEdge) {
        return ieOrEdge;
    }
    isDetectedIEOrEdge = true;
    try {
        var ua = internalWindow.navigator.userAgent;
        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
            ieOrEdge = true;
        }
    }
    catch (error) {
    }
    return ieOrEdge;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// override Function.prototype.toString to make zone.js patched function
// look like native function
Zone.__load_patch('toString', function (global) {
    // patch Func.prototype.toString to let them look like native
    var originalFunctionToString = Function.prototype.toString;
    var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
    var PROMISE_SYMBOL = zoneSymbol('Promise');
    var ERROR_SYMBOL = zoneSymbol('Error');
    var newFunctionToString = function toString() {
        if (typeof this === 'function') {
            var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
            if (originalDelegate) {
                if (typeof originalDelegate === 'function') {
                    return originalFunctionToString.call(originalDelegate);
                }
                else {
                    return Object.prototype.toString.call(originalDelegate);
                }
            }
            if (this === Promise) {
                var nativePromise = global[PROMISE_SYMBOL];
                if (nativePromise) {
                    return originalFunctionToString.call(nativePromise);
                }
            }
            if (this === Error) {
                var nativeError = global[ERROR_SYMBOL];
                if (nativeError) {
                    return originalFunctionToString.call(nativeError);
                }
            }
        }
        return originalFunctionToString.call(this);
    };
    newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
    Function.prototype.toString = newFunctionToString;
    // patch Object.prototype.toString to let them look like native
    var originalObjectToString = Object.prototype.toString;
    var PROMISE_OBJECT_TO_STRING = '[object Promise]';
    Object.prototype.toString = function () {
        if (this instanceof Promise) {
            return PROMISE_OBJECT_TO_STRING;
        }
        return originalObjectToString.call(this);
    };
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {missingRequire}
 */
var passiveSupported = false;
if (typeof window !== 'undefined') {
    try {
        var options = Object.defineProperty({}, 'passive', {
            get: function () {
                passiveSupported = true;
            }
        });
        window.addEventListener('test', options, options);
        window.removeEventListener('test', options, options);
    }
    catch (err) {
        passiveSupported = false;
    }
}
// an identifier to tell ZoneTask do not create a new invoke closure
var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
    useG: true
};
var zoneSymbolEventNames$1 = {};
var globalSources = {};
var EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\w+)(true|false)$/;
var IMMEDIATE_PROPAGATION_SYMBOL = ('__zone_symbol__propagationStopped');
function patchEventTarget(_global, apis, patchOptions) {
    var ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;
    var REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;
    var LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || 'eventListeners';
    var REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || 'removeAllListeners';
    var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
    var ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
    var PREPEND_EVENT_LISTENER = 'prependListener';
    var PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
    var invokeTask = function (task, target, event) {
        // for better performance, check isRemoved which is set
        // by removeEventListener
        if (task.isRemoved) {
            return;
        }
        var delegate = task.callback;
        if (typeof delegate === 'object' && delegate.handleEvent) {
            // create the bind version of handleEvent when invoke
            task.callback = function (event) { return delegate.handleEvent(event); };
            task.originalDelegate = delegate;
        }
        // invoke static task.invoke
        task.invoke(task, target, [event]);
        var options = task.options;
        if (options && typeof options === 'object' && options.once) {
            // if options.once is true, after invoke once remove listener here
            // only browser need to do this, nodejs eventEmitter will cal removeListener
            // inside EventEmitter.once
            var delegate_1 = task.originalDelegate ? task.originalDelegate : task.callback;
            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate_1, options);
        }
    };
    // global shared zoneAwareCallback to handle all event callback with capture = false
    var globalZoneAwareCallback = function (event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;
        if (!event) {
            return;
        }
        // event.target is needed for Samsung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190
        var target = this || event.target || _global;
        var tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];
        if (tasks) {
            // invoke all tasks which attached to current target with given event.type and capture = false
            // for performance concern, if task.length === 1, just invoke
            if (tasks.length === 1) {
                invokeTask(tasks[0], target, event);
            }
            else {
                // https://github.com/angular/zone.js/issues/836
                // copy the tasks array before invoke, to avoid
                // the callback will remove itself or other listener
                var copyTasks = tasks.slice();
                for (var i = 0; i < copyTasks.length; i++) {
                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                        break;
                    }
                    invokeTask(copyTasks[i], target, event);
                }
            }
        }
    };
    // global shared zoneAwareCallback to handle all event callback with capture = true
    var globalZoneAwareCaptureCallback = function (event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;
        if (!event) {
            return;
        }
        // event.target is needed for Samsung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190
        var target = this || event.target || _global;
        var tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];
        if (tasks) {
            // invoke all tasks which attached to current target with given event.type and capture = false
            // for performance concern, if task.length === 1, just invoke
            if (tasks.length === 1) {
                invokeTask(tasks[0], target, event);
            }
            else {
                // https://github.com/angular/zone.js/issues/836
                // copy the tasks array before invoke, to avoid
                // the callback will remove itself or other listener
                var copyTasks = tasks.slice();
                for (var i = 0; i < copyTasks.length; i++) {
                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                        break;
                    }
                    invokeTask(copyTasks[i], target, event);
                }
            }
        }
    };
    function patchEventTargetMethods(obj, patchOptions) {
        if (!obj) {
            return false;
        }
        var useGlobalCallback = true;
        if (patchOptions && patchOptions.useG !== undefined) {
            useGlobalCallback = patchOptions.useG;
        }
        var validateHandler = patchOptions && patchOptions.vh;
        var checkDuplicate = true;
        if (patchOptions && patchOptions.chkDup !== undefined) {
            checkDuplicate = patchOptions.chkDup;
        }
        var returnTarget = false;
        if (patchOptions && patchOptions.rt !== undefined) {
            returnTarget = patchOptions.rt;
        }
        var proto = obj;
        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
            proto = ObjectGetPrototypeOf(proto);
        }
        if (!proto && obj[ADD_EVENT_LISTENER]) {
            // somehow we did not find it, but we can see it. This happens on IE for Window properties.
            proto = obj;
        }
        if (!proto) {
            return false;
        }
        if (proto[zoneSymbolAddEventListener]) {
            return false;
        }
        var eventNameToString = patchOptions && patchOptions.eventNameToString;
        // a shared global taskData to pass data for scheduleEventTask
        // so we do not need to create a new object just for pass some data
        var taskData = {};
        var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
        var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =
            proto[REMOVE_EVENT_LISTENER];
        var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =
            proto[LISTENERS_EVENT_LISTENER];
        var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =
            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
        var nativePrependEventListener;
        if (patchOptions && patchOptions.prepend) {
            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =
                proto[patchOptions.prepend];
        }
        function checkIsPassive(task) {
            if (!passiveSupported && typeof taskData.options !== 'boolean' &&
                typeof taskData.options !== 'undefined' && taskData.options !== null) {
                // options is a non-null non-undefined object
                // passive is not supported
                // don't pass options as object
                // just pass capture as a boolean
                task.options = !!taskData.options.capture;
                taskData.options = task.options;
            }
        }
        var customScheduleGlobal = function (task) {
            // if there is already a task for the eventName + capture,
            // just return, because we use the shared globalZoneAwareCallback here.
            if (taskData.isExisting) {
                return;
            }
            checkIsPassive(task);
            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
        };
        var customCancelGlobal = function (task) {
            // if task is not marked as isRemoved, this call is directly
            // from Zone.prototype.cancelTask, we should remove the task
            // from tasksList of target first
            if (!task.isRemoved) {
                var symbolEventNames = zoneSymbolEventNames$1[task.eventName];
                var symbolEventName = void 0;
                if (symbolEventNames) {
                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
                }
                var existingTasks = symbolEventName && task.target[symbolEventName];
                if (existingTasks) {
                    for (var i = 0; i < existingTasks.length; i++) {
                        var existingTask = existingTasks[i];
                        if (existingTask === task) {
                            existingTasks.splice(i, 1);
                            // set isRemoved to data for faster invokeTask check
                            task.isRemoved = true;
                            if (existingTasks.length === 0) {
                                // all tasks for the eventName + capture have gone,
                                // remove globalZoneAwareCallback and remove the task cache from target
                                task.allRemoved = true;
                                task.target[symbolEventName] = null;
                            }
                            break;
                        }
                    }
                }
            }
            // if all tasks for the eventName + capture have gone,
            // we will really remove the global event callback,
            // if not, return
            if (!task.allRemoved) {
                return;
            }
            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
        };
        var customScheduleNonGlobal = function (task) {
            checkIsPassive(task);
            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
        };
        var customSchedulePrepend = function (task) {
            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
        };
        var customCancelNonGlobal = function (task) {
            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
        };
        var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
        var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
        var compareTaskCallbackVsDelegate = function (task, delegate) {
            var typeOfDelegate = typeof delegate;
            return (typeOfDelegate === 'function' && task.callback === delegate) ||
                (typeOfDelegate === 'object' && task.originalDelegate === delegate);
        };
        var compare = (patchOptions && patchOptions.diff) ? patchOptions.diff : compareTaskCallbackVsDelegate;
        var blackListedEvents = Zone[Zone.__symbol__('BLACK_LISTED_EVENTS')];
        var makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget, prepend) {
            if (returnTarget === void 0) { returnTarget = false; }
            if (prepend === void 0) { prepend = false; }
            return function () {
                var target = this || _global;
                var eventName = arguments[0];
                var delegate = arguments[1];
                if (!delegate) {
                    return nativeListener.apply(this, arguments);
                }
                if (isNode && eventName === 'uncaughtException') {
                    // don't patch uncaughtException of nodejs to prevent endless loop
                    return nativeListener.apply(this, arguments);
                }
                // don't create the bind delegate function for handleEvent
                // case here to improve addEventListener performance
                // we will create the bind delegate when invoke
                var isHandleEvent = false;
                if (typeof delegate !== 'function') {
                    if (!delegate.handleEvent) {
                        return nativeListener.apply(this, arguments);
                    }
                    isHandleEvent = true;
                }
                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
                    return;
                }
                var options = arguments[2];
                if (blackListedEvents) {
                    // check black list
                    for (var i = 0; i < blackListedEvents.length; i++) {
                        if (eventName === blackListedEvents[i]) {
                            return nativeListener.apply(this, arguments);
                        }
                    }
                }
                var capture;
                var once = false;
                if (options === undefined) {
                    capture = false;
                }
                else if (options === true) {
                    capture = true;
                }
                else if (options === false) {
                    capture = false;
                }
                else {
                    capture = options ? !!options.capture : false;
                    once = options ? !!options.once : false;
                }
                var zone = Zone.current;
                var symbolEventNames = zoneSymbolEventNames$1[eventName];
                var symbolEventName;
                if (!symbolEventNames) {
                    // the code is duplicate, but I just want to get some better performance
                    var falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
                    var trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
                    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
                    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
                    zoneSymbolEventNames$1[eventName] = {};
                    zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;
                    zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;
                    symbolEventName = capture ? symbolCapture : symbol;
                }
                else {
                    symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
                }
                var existingTasks = target[symbolEventName];
                var isExisting = false;
                if (existingTasks) {
                    // already have task registered
                    isExisting = true;
                    if (checkDuplicate) {
                        for (var i = 0; i < existingTasks.length; i++) {
                            if (compare(existingTasks[i], delegate)) {
                                // same callback, same capture, same event name, just return
                                return;
                            }
                        }
                    }
                }
                else {
                    existingTasks = target[symbolEventName] = [];
                }
                var source;
                var constructorName = target.constructor['name'];
                var targetSource = globalSources[constructorName];
                if (targetSource) {
                    source = targetSource[eventName];
                }
                if (!source) {
                    source = constructorName + addSource +
                        (eventNameToString ? eventNameToString(eventName) : eventName);
                }
                // do not create a new object as task.data to pass those things
                // just use the global shared one
                taskData.options = options;
                if (once) {
                    // if addEventListener with once options, we don't pass it to
                    // native addEventListener, instead we keep the once setting
                    // and handle ourselves.
                    taskData.options.once = false;
                }
                taskData.target = target;
                taskData.capture = capture;
                taskData.eventName = eventName;
                taskData.isExisting = isExisting;
                var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;
                // keep taskData into data to allow onScheduleEventTask to access the task information
                if (data) {
                    data.taskData = taskData;
                }
                var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
                // should clear taskData.target to avoid memory leak
                // issue, https://github.com/angular/angular/issues/20442
                taskData.target = null;
                // need to clear up taskData because it is a global object
                if (data) {
                    data.taskData = null;
                }
                // have to save those information to task in case
                // application may call task.zone.cancelTask() directly
                if (once) {
                    options.once = true;
                }
                if (!(!passiveSupported && typeof task.options === 'boolean')) {
                    // if not support passive, and we pass an option object
                    // to addEventListener, we should save the options to task
                    task.options = options;
                }
                task.target = target;
                task.capture = capture;
                task.eventName = eventName;
                if (isHandleEvent) {
                    // save original delegate for compare to check duplicate
                    task.originalDelegate = delegate;
                }
                if (!prepend) {
                    existingTasks.push(task);
                }
                else {
                    existingTasks.unshift(task);
                }
                if (returnTarget) {
                    return target;
                }
            };
        };
        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
        if (nativePrependEventListener) {
            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
        }
        proto[REMOVE_EVENT_LISTENER] = function () {
            var target = this || _global;
            var eventName = arguments[0];
            var options = arguments[2];
            var capture;
            if (options === undefined) {
                capture = false;
            }
            else if (options === true) {
                capture = true;
            }
            else if (options === false) {
                capture = false;
            }
            else {
                capture = options ? !!options.capture : false;
            }
            var delegate = arguments[1];
            if (!delegate) {
                return nativeRemoveEventListener.apply(this, arguments);
            }
            if (validateHandler &&
                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
                return;
            }
            var symbolEventNames = zoneSymbolEventNames$1[eventName];
            var symbolEventName;
            if (symbolEventNames) {
                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
            }
            var existingTasks = symbolEventName && target[symbolEventName];
            if (existingTasks) {
                for (var i = 0; i < existingTasks.length; i++) {
                    var existingTask = existingTasks[i];
                    if (compare(existingTask, delegate)) {
                        existingTasks.splice(i, 1);
                        // set isRemoved to data for faster invokeTask check
                        existingTask.isRemoved = true;
                        if (existingTasks.length === 0) {
                            // all tasks for the eventName + capture have gone,
                            // remove globalZoneAwareCallback and remove the task cache from target
                            existingTask.allRemoved = true;
                            target[symbolEventName] = null;
                        }
                        existingTask.zone.cancelTask(existingTask);
                        if (returnTarget) {
                            return target;
                        }
                        return;
                    }
                }
            }
            // issue 930, didn't find the event name or callback
            // from zone kept existingTasks, the callback maybe
            // added outside of zone, we need to call native removeEventListener
            // to try to remove it.
            return nativeRemoveEventListener.apply(this, arguments);
        };
        proto[LISTENERS_EVENT_LISTENER] = function () {
            var target = this || _global;
            var eventName = arguments[0];
            var listeners = [];
            var tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
            for (var i = 0; i < tasks.length; i++) {
                var task = tasks[i];
                var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                listeners.push(delegate);
            }
            return listeners;
        };
        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
            var target = this || _global;
            var eventName = arguments[0];
            if (!eventName) {
                var keys = Object.keys(target);
                for (var i = 0; i < keys.length; i++) {
                    var prop = keys[i];
                    var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
                    var evtName = match && match[1];
                    // in nodejs EventEmitter, removeListener event is
                    // used for monitoring the removeListener call,
                    // so just keep removeListener eventListener until
                    // all other eventListeners are removed
                    if (evtName && evtName !== 'removeListener') {
                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
                    }
                }
                // remove removeListener listener finally
                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');
            }
            else {
                var symbolEventNames = zoneSymbolEventNames$1[eventName];
                if (symbolEventNames) {
                    var symbolEventName = symbolEventNames[FALSE_STR];
                    var symbolCaptureEventName = symbolEventNames[TRUE_STR];
                    var tasks = target[symbolEventName];
                    var captureTasks = target[symbolCaptureEventName];
                    if (tasks) {
                        var removeTasks = tasks.slice();
                        for (var i = 0; i < removeTasks.length; i++) {
                            var task = removeTasks[i];
                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                        }
                    }
                    if (captureTasks) {
                        var removeTasks = captureTasks.slice();
                        for (var i = 0; i < removeTasks.length; i++) {
                            var task = removeTasks[i];
                            var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                        }
                    }
                }
            }
            if (returnTarget) {
                return this;
            }
        };
        // for native toString patch
        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
        if (nativeRemoveAllListeners) {
            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
        }
        if (nativeListeners) {
            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
        }
        return true;
    }
    var results = [];
    for (var i = 0; i < apis.length; i++) {
        results[i] = patchEventTargetMethods(apis[i], patchOptions);
    }
    return results;
}
function findEventTasks(target, eventName) {
    var foundTasks = [];
    for (var prop in target) {
        var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
        var evtName = match && match[1];
        if (evtName && (!eventName || evtName === eventName)) {
            var tasks = target[prop];
            if (tasks) {
                for (var i = 0; i < tasks.length; i++) {
                    foundTasks.push(tasks[i]);
                }
            }
        }
    }
    return foundTasks;
}
function patchEventPrototype(global, api) {
    var Event = global['Event'];
    if (Event && Event.prototype) {
        api.patchMethod(Event.prototype, 'stopImmediatePropagation', function (delegate) { return function (self, args) {
            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;
            // we need to call the native stopImmediatePropagation
            // in case in some hybrid application, some part of
            // application will be controlled by zone, some are not
            delegate && delegate.apply(self, args);
        }; });
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function patchCallbacks(api, target, targetName, method, callbacks) {
    var symbol = Zone.__symbol__(method);
    if (target[symbol]) {
        return;
    }
    var nativeDelegate = target[symbol] = target[method];
    target[method] = function (name, opts, options) {
        if (opts && opts.prototype) {
            callbacks.forEach(function (callback) {
                var source = targetName + "." + method + "::" + callback;
                var prototype = opts.prototype;
                if (prototype.hasOwnProperty(callback)) {
                    var descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
                    if (descriptor && descriptor.value) {
                        descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
                        api._redefineProperty(opts.prototype, callback, descriptor);
                    }
                    else if (prototype[callback]) {
                        prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                    }
                }
                else if (prototype[callback]) {
                    prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
                }
            });
        }
        return nativeDelegate.call(target, name, opts, options);
    };
    api.attachOriginToPatched(target[method], nativeDelegate);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/*
 * This is necessary for Chrome and Chrome mobile, to enable
 * things like redefining `createdCallback` on an element.
 */
var zoneSymbol$1 = Zone.__symbol__;
var _defineProperty = Object[zoneSymbol$1('defineProperty')] = Object.defineProperty;
var _getOwnPropertyDescriptor = Object[zoneSymbol$1('getOwnPropertyDescriptor')] =
    Object.getOwnPropertyDescriptor;
var _create = Object.create;
var unconfigurablesKey = zoneSymbol$1('unconfigurables');
function propertyPatch() {
    Object.defineProperty = function (obj, prop, desc) {
        if (isUnconfigurable(obj, prop)) {
            throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
        }
        var originalConfigurableFlag = desc.configurable;
        if (prop !== 'prototype') {
            desc = rewriteDescriptor(obj, prop, desc);
        }
        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
    };
    Object.defineProperties = function (obj, props) {
        Object.keys(props).forEach(function (prop) {
            Object.defineProperty(obj, prop, props[prop]);
        });
        return obj;
    };
    Object.create = function (obj, proto) {
        if (typeof proto === 'object' && !Object.isFrozen(proto)) {
            Object.keys(proto).forEach(function (prop) {
                proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
            });
        }
        return _create(obj, proto);
    };
    Object.getOwnPropertyDescriptor = function (obj, prop) {
        var desc = _getOwnPropertyDescriptor(obj, prop);
        if (desc && isUnconfigurable(obj, prop)) {
            desc.configurable = false;
        }
        return desc;
    };
}
function _redefineProperty(obj, prop, desc) {
    var originalConfigurableFlag = desc.configurable;
    desc = rewriteDescriptor(obj, prop, desc);
    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
}
function isUnconfigurable(obj, prop) {
    return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];
}
function rewriteDescriptor(obj, prop, desc) {
    // issue-927, if the desc is frozen, don't try to change the desc
    if (!Object.isFrozen(desc)) {
        desc.configurable = true;
    }
    if (!desc.configurable) {
        // issue-927, if the obj is frozen, don't try to set the desc to obj
        if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {
            _defineProperty(obj, unconfigurablesKey, { writable: true, value: {} });
        }
        if (obj[unconfigurablesKey]) {
            obj[unconfigurablesKey][prop] = true;
        }
    }
    return desc;
}
function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {
    try {
        return _defineProperty(obj, prop, desc);
    }
    catch (error) {
        if (desc.configurable) {
            // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's
            // retry with the original flag value
            if (typeof originalConfigurableFlag == 'undefined') {
                delete desc.configurable;
            }
            else {
                desc.configurable = originalConfigurableFlag;
            }
            try {
                return _defineProperty(obj, prop, desc);
            }
            catch (error) {
                var descJson = null;
                try {
                    descJson = JSON.stringify(desc);
                }
                catch (error) {
                    descJson = desc.toString();
                }
                console.log("Attempting to configure '" + prop + "' with descriptor '" + descJson + "' on object '" + obj + "' and got error, giving up: " + error);
            }
        }
        else {
            throw error;
        }
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {globalThis}
 */
var globalEventHandlersEventNames = [
    'abort',
    'animationcancel',
    'animationend',
    'animationiteration',
    'auxclick',
    'beforeinput',
    'blur',
    'cancel',
    'canplay',
    'canplaythrough',
    'change',
    'compositionstart',
    'compositionupdate',
    'compositionend',
    'cuechange',
    'click',
    'close',
    'contextmenu',
    'curechange',
    'dblclick',
    'drag',
    'dragend',
    'dragenter',
    'dragexit',
    'dragleave',
    'dragover',
    'drop',
    'durationchange',
    'emptied',
    'ended',
    'error',
    'focus',
    'focusin',
    'focusout',
    'gotpointercapture',
    'input',
    'invalid',
    'keydown',
    'keypress',
    'keyup',
    'load',
    'loadstart',
    'loadeddata',
    'loadedmetadata',
    'lostpointercapture',
    'mousedown',
    'mouseenter',
    'mouseleave',
    'mousemove',
    'mouseout',
    'mouseover',
    'mouseup',
    'mousewheel',
    'orientationchange',
    'pause',
    'play',
    'playing',
    'pointercancel',
    'pointerdown',
    'pointerenter',
    'pointerleave',
    'pointerlockchange',
    'mozpointerlockchange',
    'webkitpointerlockerchange',
    'pointerlockerror',
    'mozpointerlockerror',
    'webkitpointerlockerror',
    'pointermove',
    'pointout',
    'pointerover',
    'pointerup',
    'progress',
    'ratechange',
    'reset',
    'resize',
    'scroll',
    'seeked',
    'seeking',
    'select',
    'selectionchange',
    'selectstart',
    'show',
    'sort',
    'stalled',
    'submit',
    'suspend',
    'timeupdate',
    'volumechange',
    'touchcancel',
    'touchmove',
    'touchstart',
    'touchend',
    'transitioncancel',
    'transitionend',
    'waiting',
    'wheel'
];
var documentEventNames = [
    'afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'freeze', 'fullscreenchange',
    'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror',
    'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange',
    'visibilitychange', 'resume'
];
var windowEventNames = [
    'absolutedeviceorientation',
    'afterinput',
    'afterprint',
    'appinstalled',
    'beforeinstallprompt',
    'beforeprint',
    'beforeunload',
    'devicelight',
    'devicemotion',
    'deviceorientation',
    'deviceorientationabsolute',
    'deviceproximity',
    'hashchange',
    'languagechange',
    'message',
    'mozbeforepaint',
    'offline',
    'online',
    'paint',
    'pageshow',
    'pagehide',
    'popstate',
    'rejectionhandled',
    'storage',
    'unhandledrejection',
    'unload',
    'userproximity',
    'vrdisplyconnected',
    'vrdisplaydisconnected',
    'vrdisplaypresentchange'
];
var htmlElementEventNames = [
    'beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend',
    'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend',
    'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'
];
var mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];
var ieElementEventNames = [
    'activate',
    'afterupdate',
    'ariarequest',
    'beforeactivate',
    'beforedeactivate',
    'beforeeditfocus',
    'beforeupdate',
    'cellchange',
    'controlselect',
    'dataavailable',
    'datasetchanged',
    'datasetcomplete',
    'errorupdate',
    'filterchange',
    'layoutcomplete',
    'losecapture',
    'move',
    'moveend',
    'movestart',
    'propertychange',
    'resizeend',
    'resizestart',
    'rowenter',
    'rowexit',
    'rowsdelete',
    'rowsinserted',
    'command',
    'compassneedscalibration',
    'deactivate',
    'help',
    'mscontentzoom',
    'msmanipulationstatechanged',
    'msgesturechange',
    'msgesturedoubletap',
    'msgestureend',
    'msgesturehold',
    'msgesturestart',
    'msgesturetap',
    'msgotpointercapture',
    'msinertiastart',
    'mslostpointercapture',
    'mspointercancel',
    'mspointerdown',
    'mspointerenter',
    'mspointerhover',
    'mspointerleave',
    'mspointermove',
    'mspointerout',
    'mspointerover',
    'mspointerup',
    'pointerout',
    'mssitemodejumplistitemremoved',
    'msthumbnailclick',
    'stop',
    'storagecommit'
];
var webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];
var formEventNames = ['autocomplete', 'autocompleteerror'];
var detailEventNames = ['toggle'];
var frameEventNames = ['load'];
var frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll', 'messageerror'];
var marqueeEventNames = ['bounce', 'finish', 'start'];
var XMLHttpRequestEventNames = [
    'loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend',
    'readystatechange'
];
var IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];
var websocketEventNames = ['close', 'error', 'open', 'message'];
var workerEventNames = ['error', 'message'];
var eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);
function filterProperties(target, onProperties, ignoreProperties) {
    if (!ignoreProperties || ignoreProperties.length === 0) {
        return onProperties;
    }
    var tip = ignoreProperties.filter(function (ip) { return ip.target === target; });
    if (!tip || tip.length === 0) {
        return onProperties;
    }
    var targetIgnoreProperties = tip[0].ignoreProperties;
    return onProperties.filter(function (op) { return targetIgnoreProperties.indexOf(op) === -1; });
}
function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
    // check whether target is available, sometimes target will be undefined
    // because different browser or some 3rd party plugin.
    if (!target) {
        return;
    }
    var filteredProperties = filterProperties(target, onProperties, ignoreProperties);
    patchOnProperties(target, filteredProperties, prototype);
}
function propertyDescriptorPatch(api, _global) {
    if (isNode && !isMix) {
        return;
    }
    if (Zone[api.symbol('patchEvents')]) {
        // events are already been patched by legacy patch.
        return;
    }
    var supportsWebSocket = typeof WebSocket !== 'undefined';
    var ignoreProperties = _global['__Zone_ignore_on_properties'];
    // for browsers that we can patch the descriptor:  Chrome & Firefox
    if (isBrowser) {
        var internalWindow = window;
        var ignoreErrorProperties = isIE ? [{ target: internalWindow, ignoreProperties: ['error'] }] : [];
        // in IE/Edge, onProp not exist in window object, but in WindowPrototype
        // so we need to pass WindowPrototype to check onProp exist or not
        patchFilteredProperties(internalWindow, eventNames.concat(['messageerror']), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));
        patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);
        if (typeof internalWindow['SVGElement'] !== 'undefined') {
            patchFilteredProperties(internalWindow['SVGElement'].prototype, eventNames, ignoreProperties);
        }
        patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);
        patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);
        patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);
        patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);
        patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);
        patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);
        patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);
        var HTMLMarqueeElement_1 = internalWindow['HTMLMarqueeElement'];
        if (HTMLMarqueeElement_1) {
            patchFilteredProperties(HTMLMarqueeElement_1.prototype, marqueeEventNames, ignoreProperties);
        }
        var Worker_1 = internalWindow['Worker'];
        if (Worker_1) {
            patchFilteredProperties(Worker_1.prototype, workerEventNames, ignoreProperties);
        }
    }
    var XMLHttpRequest = _global['XMLHttpRequest'];
    if (XMLHttpRequest) {
        // XMLHttpRequest is not available in ServiceWorker, so we need to check here
        patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);
    }
    var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];
    if (XMLHttpRequestEventTarget) {
        patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);
    }
    if (typeof IDBIndex !== 'undefined') {
        patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);
    }
    if (supportsWebSocket) {
        patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Zone.__load_patch('util', function (global, Zone, api) {
    api.patchOnProperties = patchOnProperties;
    api.patchMethod = patchMethod;
    api.bindArguments = bindArguments;
    api.patchMacroTask = patchMacroTask;
    // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to
    // define which events will not be patched by `Zone.js`.
    // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep
    // the name consistent with angular repo.
    // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for
    // backwards compatibility.
    var SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');
    var SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');
    if (global[SYMBOL_UNPATCHED_EVENTS]) {
        global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];
    }
    if (global[SYMBOL_BLACK_LISTED_EVENTS]) {
        Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] =
            global[SYMBOL_BLACK_LISTED_EVENTS];
    }
    api.patchEventPrototype = patchEventPrototype;
    api.patchEventTarget = patchEventTarget;
    api.isIEOrEdge = isIEOrEdge;
    api.ObjectDefineProperty = ObjectDefineProperty;
    api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
    api.ObjectCreate = ObjectCreate;
    api.ArraySlice = ArraySlice;
    api.patchClass = patchClass;
    api.wrapWithCurrentZone = wrapWithCurrentZone;
    api.filterProperties = filterProperties;
    api.attachOriginToPatched = attachOriginToPatched;
    api._redefineProperty = _redefineProperty;
    api.patchCallbacks = patchCallbacks;
    api.getGlobalObjects = function () { return ({
        globalSources: globalSources,
        zoneSymbolEventNames: zoneSymbolEventNames$1,
        eventNames: eventNames,
        isBrowser: isBrowser,
        isMix: isMix,
        isNode: isNode,
        TRUE_STR: TRUE_STR,
        FALSE_STR: FALSE_STR,
        ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX,
        ADD_EVENT_LISTENER_STR: ADD_EVENT_LISTENER_STR,
        REMOVE_EVENT_LISTENER_STR: REMOVE_EVENT_LISTENER_STR
    }); };
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function eventTargetLegacyPatch(_global, api) {
    var _a = api.getGlobalObjects(), eventNames = _a.eventNames, globalSources = _a.globalSources, zoneSymbolEventNames = _a.zoneSymbolEventNames, TRUE_STR = _a.TRUE_STR, FALSE_STR = _a.FALSE_STR, ZONE_SYMBOL_PREFIX = _a.ZONE_SYMBOL_PREFIX;
    var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';
    var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'
        .split(',');
    var EVENT_TARGET = 'EventTarget';
    var apis = [];
    var isWtf = _global['wtf'];
    var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');
    if (isWtf) {
        // Workaround for: https://github.com/google/tracing-framework/issues/555
        apis = WTF_ISSUE_555_ARRAY.map(function (v) { return 'HTML' + v + 'Element'; }).concat(NO_EVENT_TARGET);
    }
    else if (_global[EVENT_TARGET]) {
        apis.push(EVENT_TARGET);
    }
    else {
        // Note: EventTarget is not available in all browsers,
        // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
        apis = NO_EVENT_TARGET;
    }
    var isDisableIECheck = _global['__Zone_disable_IE_check'] || false;
    var isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;
    var ieOrEdge = api.isIEOrEdge();
    var ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';
    var FUNCTION_WRAPPER = '[object FunctionWrapper]';
    var BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }';
    //  predefine all __zone_symbol__ + eventName + true/false string
    for (var i = 0; i < eventNames.length; i++) {
        var eventName = eventNames[i];
        var falseEventName = eventName + FALSE_STR;
        var trueEventName = eventName + TRUE_STR;
        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
        zoneSymbolEventNames[eventName] = {};
        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
    }
    //  predefine all task.source string
    for (var i = 0; i < WTF_ISSUE_555.length; i++) {
        var target = WTF_ISSUE_555_ARRAY[i];
        var targets = globalSources[target] = {};
        for (var j = 0; j < eventNames.length; j++) {
            var eventName = eventNames[j];
            targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;
        }
    }
    var checkIEAndCrossContext = function (nativeDelegate, delegate, target, args) {
        if (!isDisableIECheck && ieOrEdge) {
            if (isEnableCrossContextCheck) {
                try {
                    var testString = delegate.toString();
                    if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {
                        nativeDelegate.apply(target, args);
                        return false;
                    }
                }
                catch (error) {
                    nativeDelegate.apply(target, args);
                    return false;
                }
            }
            else {
                var testString = delegate.toString();
                if ((testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS)) {
                    nativeDelegate.apply(target, args);
                    return false;
                }
            }
        }
        else if (isEnableCrossContextCheck) {
            try {
                delegate.toString();
            }
            catch (error) {
                nativeDelegate.apply(target, args);
                return false;
            }
        }
        return true;
    };
    var apiTypes = [];
    for (var i = 0; i < apis.length; i++) {
        var type = _global[apis[i]];
        apiTypes.push(type && type.prototype);
    }
    // vh is validateHandler to check event handler
    // is valid or not(for security check)
    api.patchEventTarget(_global, apiTypes, { vh: checkIEAndCrossContext });
    Zone[api.symbol('patchEventTarget')] = !!_global[EVENT_TARGET];
    return true;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// we have to patch the instance since the proto is non-configurable
function apply(api, _global) {
    var _a = api.getGlobalObjects(), ADD_EVENT_LISTENER_STR = _a.ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR = _a.REMOVE_EVENT_LISTENER_STR;
    var WS = _global.WebSocket;
    // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener
    // On older Chrome, no need since EventTarget was already patched
    if (!_global.EventTarget) {
        api.patchEventTarget(_global, [WS.prototype]);
    }
    _global.WebSocket = function (x, y) {
        var socket = arguments.length > 1 ? new WS(x, y) : new WS(x);
        var proxySocket;
        var proxySocketProto;
        // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance
        var onmessageDesc = api.ObjectGetOwnPropertyDescriptor(socket, 'onmessage');
        if (onmessageDesc && onmessageDesc.configurable === false) {
            proxySocket = api.ObjectCreate(socket);
            // socket have own property descriptor 'onopen', 'onmessage', 'onclose', 'onerror'
            // but proxySocket not, so we will keep socket as prototype and pass it to
            // patchOnProperties method
            proxySocketProto = socket;
            [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, 'send', 'close'].forEach(function (propName) {
                proxySocket[propName] = function () {
                    var args = api.ArraySlice.call(arguments);
                    if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {
                        var eventName = args.length > 0 ? args[0] : undefined;
                        if (eventName) {
                            var propertySymbol = Zone.__symbol__('ON_PROPERTY' + eventName);
                            socket[propertySymbol] = proxySocket[propertySymbol];
                        }
                    }
                    return socket[propName].apply(socket, args);
                };
            });
        }
        else {
            // we can patch the real socket
            proxySocket = socket;
        }
        api.patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);
        return proxySocket;
    };
    var globalWebSocket = _global['WebSocket'];
    for (var prop in WS) {
        globalWebSocket[prop] = WS[prop];
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {globalThis}
 */
function propertyDescriptorLegacyPatch(api, _global) {
    var _a = api.getGlobalObjects(), isNode = _a.isNode, isMix = _a.isMix;
    if (isNode && !isMix) {
        return;
    }
    if (!canPatchViaPropertyDescriptor(api, _global)) {
        var supportsWebSocket = typeof WebSocket !== 'undefined';
        // Safari, Android browsers (Jelly Bean)
        patchViaCapturingAllTheEvents(api);
        api.patchClass('XMLHttpRequest');
        if (supportsWebSocket) {
            apply(api, _global);
        }
        Zone[api.symbol('patchEvents')] = true;
    }
}
function canPatchViaPropertyDescriptor(api, _global) {
    var _a = api.getGlobalObjects(), isBrowser = _a.isBrowser, isMix = _a.isMix;
    if ((isBrowser || isMix) &&
        !api.ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') &&
        typeof Element !== 'undefined') {
        // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
        // IDL interface attributes are not configurable
        var desc = api.ObjectGetOwnPropertyDescriptor(Element.prototype, 'onclick');
        if (desc && !desc.configurable)
            return false;
        // try to use onclick to detect whether we can patch via propertyDescriptor
        // because XMLHttpRequest is not available in service worker
        if (desc) {
            api.ObjectDefineProperty(Element.prototype, 'onclick', {
                enumerable: true,
                configurable: true,
                get: function () {
                    return true;
                }
            });
            var div = document.createElement('div');
            var result = !!div.onclick;
            api.ObjectDefineProperty(Element.prototype, 'onclick', desc);
            return result;
        }
    }
    var XMLHttpRequest = _global['XMLHttpRequest'];
    if (!XMLHttpRequest) {
        // XMLHttpRequest is not available in service worker
        return false;
    }
    var ON_READY_STATE_CHANGE = 'onreadystatechange';
    var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
    var xhrDesc = api.ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);
    // add enumerable and configurable here because in opera
    // by default XMLHttpRequest.prototype.onreadystatechange is undefined
    // without adding enumerable and configurable will cause onreadystatechange
    // non-configurable
    // and if XMLHttpRequest.prototype.onreadystatechange is undefined,
    // we should set a real desc instead a fake one
    if (xhrDesc) {
        api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {
            enumerable: true,
            configurable: true,
            get: function () {
                return true;
            }
        });
        var req = new XMLHttpRequest();
        var result = !!req.onreadystatechange;
        // restore original desc
        api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});
        return result;
    }
    else {
        var SYMBOL_FAKE_ONREADYSTATECHANGE_1 = api.symbol('fake');
        api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {
            enumerable: true,
            configurable: true,
            get: function () {
                return this[SYMBOL_FAKE_ONREADYSTATECHANGE_1];
            },
            set: function (value) {
                this[SYMBOL_FAKE_ONREADYSTATECHANGE_1] = value;
            }
        });
        var req = new XMLHttpRequest();
        var detectFunc = function () { };
        req.onreadystatechange = detectFunc;
        var result = req[SYMBOL_FAKE_ONREADYSTATECHANGE_1] === detectFunc;
        req.onreadystatechange = null;
        return result;
    }
}
// Whenever any eventListener fires, we check the eventListener target and all parents
// for `onwhatever` properties and replace them with zone-bound functions
// - Chrome (for now)
function patchViaCapturingAllTheEvents(api) {
    var eventNames = api.getGlobalObjects().eventNames;
    var unboundKey = api.symbol('unbound');
    var _loop_1 = function (i) {
        var property = eventNames[i];
        var onproperty = 'on' + property;
        self.addEventListener(property, function (event) {
            var elt = event.target, bound, source;
            if (elt) {
                source = elt.constructor['name'] + '.' + onproperty;
            }
            else {
                source = 'unknown.' + onproperty;
            }
            while (elt) {
                if (elt[onproperty] && !elt[onproperty][unboundKey]) {
                    bound = api.wrapWithCurrentZone(elt[onproperty], source);
                    bound[unboundKey] = elt[onproperty];
                    elt[onproperty] = bound;
                }
                elt = elt.parentElement;
            }
        }, true);
    };
    for (var i = 0; i < eventNames.length; i++) {
        _loop_1(i);
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function registerElementPatch(_global, api) {
    var _a = api.getGlobalObjects(), isBrowser = _a.isBrowser, isMix = _a.isMix;
    if ((!isBrowser && !isMix) || !('registerElement' in _global.document)) {
        return;
    }
    var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];
    api.patchCallbacks(api, document, 'Document', 'registerElement', callbacks);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {missingRequire}
 */
(function (_global) {
    _global['__zone_symbol__legacyPatch'] = function () {
        var Zone = _global['Zone'];
        Zone.__load_patch('registerElement', function (global, Zone, api) {
            registerElementPatch(global, api);
        });
        Zone.__load_patch('EventTargetLegacy', function (global, Zone, api) {
            eventTargetLegacyPatch(global, api);
            propertyDescriptorLegacyPatch(api, global);
        });
    };
})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {missingRequire}
 */
var taskSymbol = zoneSymbol('zoneTask');
function patchTimer(window, setName, cancelName, nameSuffix) {
    var setNative = null;
    var clearNative = null;
    setName += nameSuffix;
    cancelName += nameSuffix;
    var tasksByHandleId = {};
    function scheduleTask(task) {
        var data = task.data;
        function timer() {
            try {
                task.invoke.apply(this, arguments);
            }
            finally {
                // issue-934, task will be cancelled
                // even it is a periodic task such as
                // setInterval
                if (!(task.data && task.data.isPeriodic)) {
                    if (typeof data.handleId === 'number') {
                        // in non-nodejs env, we remove timerId
                        // from local cache
                        delete tasksByHandleId[data.handleId];
                    }
                    else if (data.handleId) {
                        // Node returns complex objects as handleIds
                        // we remove task reference from timer object
                        data.handleId[taskSymbol] = null;
                    }
                }
            }
        }
        data.args[0] = timer;
        data.handleId = setNative.apply(window, data.args);
        return task;
    }
    function clearTask(task) {
        return clearNative(task.data.handleId);
    }
    setNative =
        patchMethod(window, setName, function (delegate) { return function (self, args) {
            if (typeof args[0] === 'function') {
                var options = {
                    isPeriodic: nameSuffix === 'Interval',
                    delay: (nameSuffix === 'Timeout' || nameSuffix === 'Interval') ? args[1] || 0 :
                        undefined,
                    args: args
                };
                var task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
                if (!task) {
                    return task;
                }
                // Node.js must additionally support the ref and unref functions.
                var handle = task.data.handleId;
                if (typeof handle === 'number') {
                    // for non nodejs env, we save handleId: task
                    // mapping in local cache for clearTimeout
                    tasksByHandleId[handle] = task;
                }
                else if (handle) {
                    // for nodejs env, we save task
                    // reference in timerId Object for clearTimeout
                    handle[taskSymbol] = task;
                }
                // check whether handle is null, because some polyfill or browser
                // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame
                if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' &&
                    typeof handle.unref === 'function') {
                    task.ref = handle.ref.bind(handle);
                    task.unref = handle.unref.bind(handle);
                }
                if (typeof handle === 'number' || handle) {
                    return handle;
                }
                return task;
            }
            else {
                // cause an error by calling it directly.
                return delegate.apply(window, args);
            }
        }; });
    clearNative =
        patchMethod(window, cancelName, function (delegate) { return function (self, args) {
            var id = args[0];
            var task;
            if (typeof id === 'number') {
                // non nodejs env.
                task = tasksByHandleId[id];
            }
            else {
                // nodejs env.
                task = id && id[taskSymbol];
                // other environments.
                if (!task) {
                    task = id;
                }
            }
            if (task && typeof task.type === 'string') {
                if (task.state !== 'notScheduled' &&
                    (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
                    if (typeof id === 'number') {
                        delete tasksByHandleId[id];
                    }
                    else if (id) {
                        id[taskSymbol] = null;
                    }
                    // Do not cancel already canceled functions
                    task.zone.cancelTask(task);
                }
            }
            else {
                // cause an error by calling it directly.
                delegate.apply(window, args);
            }
        }; });
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function patchCustomElements(_global, api) {
    var _a = api.getGlobalObjects(), isBrowser = _a.isBrowser, isMix = _a.isMix;
    if ((!isBrowser && !isMix) || !_global['customElements'] || !('customElements' in _global)) {
        return;
    }
    var callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];
    api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function eventTargetPatch(_global, api) {
    if (Zone[api.symbol('patchEventTarget')]) {
        // EventTarget is already patched.
        return;
    }
    var _a = api.getGlobalObjects(), eventNames = _a.eventNames, zoneSymbolEventNames = _a.zoneSymbolEventNames, TRUE_STR = _a.TRUE_STR, FALSE_STR = _a.FALSE_STR, ZONE_SYMBOL_PREFIX = _a.ZONE_SYMBOL_PREFIX;
    //  predefine all __zone_symbol__ + eventName + true/false string
    for (var i = 0; i < eventNames.length; i++) {
        var eventName = eventNames[i];
        var falseEventName = eventName + FALSE_STR;
        var trueEventName = eventName + TRUE_STR;
        var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
        var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
        zoneSymbolEventNames[eventName] = {};
        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
    }
    var EVENT_TARGET = _global['EventTarget'];
    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
        return;
    }
    api.patchEventTarget(_global, [EVENT_TARGET && EVENT_TARGET.prototype]);
    return true;
}
function patchEvent$1(global, api) {
    api.patchEventPrototype(global, api);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview
 * @suppress {missingRequire}
 */
Zone.__load_patch('legacy', function (global) {
    var legacyPatch = global[Zone.__symbol__('legacyPatch')];
    if (legacyPatch) {
        legacyPatch();
    }
});
Zone.__load_patch('timers', function (global) {
    var set = 'set';
    var clear = 'clear';
    patchTimer(global, set, clear, 'Timeout');
    patchTimer(global, set, clear, 'Interval');
    patchTimer(global, set, clear, 'Immediate');
});
Zone.__load_patch('requestAnimationFrame', function (global) {
    patchTimer(global, 'request', 'cancel', 'AnimationFrame');
    patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
    patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
});
Zone.__load_patch('blocking', function (global, Zone) {
    var blockingMethods = ['alert', 'prompt', 'confirm'];
    for (var i = 0; i < blockingMethods.length; i++) {
        var name_1 = blockingMethods[i];
        patchMethod(global, name_1, function (delegate, symbol, name) {
            return function (s, args) {
                return Zone.current.run(delegate, global, args, name);
            };
        });
    }
});
Zone.__load_patch('EventTarget', function (global, Zone, api) {
    patchEvent$1(global, api);
    eventTargetPatch(global, api);
    // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener
    var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];
    if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);
    }
    patchClass('MutationObserver');
    patchClass('WebKitMutationObserver');
    patchClass('IntersectionObserver');
    patchClass('FileReader');
});
Zone.__load_patch('on_property', function (global, Zone, api) {
    propertyDescriptorPatch(api, global);
    propertyPatch();
});
Zone.__load_patch('customElements', function (global, Zone, api) {
    patchCustomElements(global, api);
});
Zone.__load_patch('XHR', function (global, Zone) {
    // Treat XMLHttpRequest as a macrotask.
    patchXHR(global);
    var XHR_TASK = zoneSymbol('xhrTask');
    var XHR_SYNC = zoneSymbol('xhrSync');
    var XHR_LISTENER = zoneSymbol('xhrListener');
    var XHR_SCHEDULED = zoneSymbol('xhrScheduled');
    var XHR_URL = zoneSymbol('xhrURL');
    var XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');
    function patchXHR(window) {
        var XMLHttpRequest = window['XMLHttpRequest'];
        if (!XMLHttpRequest) {
            // XMLHttpRequest is not available in service worker
            return;
        }
        var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
        function findPendingTask(target) {
            return target[XHR_TASK];
        }
        var oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
        var oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
        if (!oriAddListener) {
            var XMLHttpRequestEventTarget_1 = window['XMLHttpRequestEventTarget'];
            if (XMLHttpRequestEventTarget_1) {
                var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget_1.prototype;
                oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
                oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
            }
        }
        var READY_STATE_CHANGE = 'readystatechange';
        var SCHEDULED = 'scheduled';
        function scheduleTask(task) {
            var data = task.data;
            var target = data.target;
            target[XHR_SCHEDULED] = false;
            target[XHR_ERROR_BEFORE_SCHEDULED] = false;
            // remove existing event listener
            var listener = target[XHR_LISTENER];
            if (!oriAddListener) {
                oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
                oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
            }
            if (listener) {
                oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
            }
            var newListener = target[XHR_LISTENER] = function () {
                if (target.readyState === target.DONE) {
                    // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
                    // readyState=4 multiple times, so we need to check task state here
                    if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
                        // check whether the xhr has registered onload listener
                        // if that is the case, the task should invoke after all
                        // onload listeners finish.
                        var loadTasks = target['__zone_symbol__loadfalse'];
                        if (loadTasks && loadTasks.length > 0) {
                            var oriInvoke_1 = task.invoke;
                            task.invoke = function () {
                                // need to load the tasks again, because in other
                                // load listener, they may remove themselves
                                var loadTasks = target['__zone_symbol__loadfalse'];
                                for (var i = 0; i < loadTasks.length; i++) {
                                    if (loadTasks[i] === task) {
                                        loadTasks.splice(i, 1);
                                    }
                                }
                                if (!data.aborted && task.state === SCHEDULED) {
                                    oriInvoke_1.call(task);
                                }
                            };
                            loadTasks.push(task);
                        }
                        else {
                            task.invoke();
                        }
                    }
                    else if (!data.aborted && target[XHR_SCHEDULED] === false) {
                        // error occurs when xhr.send()
                        target[XHR_ERROR_BEFORE_SCHEDULED] = true;
                    }
                }
            };
            oriAddListener.call(target, READY_STATE_CHANGE, newListener);
            var storedTask = target[XHR_TASK];
            if (!storedTask) {
                target[XHR_TASK] = task;
            }
            sendNative.apply(target, data.args);
            target[XHR_SCHEDULED] = true;
            return task;
        }
        function placeholderCallback() { }
        function clearTask(task) {
            var data = task.data;
            // Note - ideally, we would call data.target.removeEventListener here, but it's too late
            // to prevent it from firing. So instead, we store info for the event listener.
            data.aborted = true;
            return abortNative.apply(data.target, data.args);
        }
        var openNative = patchMethod(XMLHttpRequestPrototype, 'open', function () { return function (self, args) {
            self[XHR_SYNC] = args[2] == false;
            self[XHR_URL] = args[1];
            return openNative.apply(self, args);
        }; });
        var XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';
        var fetchTaskAborting = zoneSymbol('fetchTaskAborting');
        var fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');
        var sendNative = patchMethod(XMLHttpRequestPrototype, 'send', function () { return function (self, args) {
            if (Zone.current[fetchTaskScheduling] === true) {
                // a fetch is scheduling, so we are using xhr to polyfill fetch
                // and because we already schedule macroTask for fetch, we should
                // not schedule a macroTask for xhr again
                return sendNative.apply(self, args);
            }
            if (self[XHR_SYNC]) {
                // if the XHR is sync there is no task to schedule, just execute the code.
                return sendNative.apply(self, args);
            }
            else {
                var options = { target: self, url: self[XHR_URL], isPeriodic: false, args: args, aborted: false };
                var task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
                if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted &&
                    task.state === SCHEDULED) {
                    // xhr request throw error when send
                    // we should invoke task instead of leaving a scheduled
                    // pending macroTask
                    task.invoke();
                }
            }
        }; });
        var abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', function () { return function (self, args) {
            var task = findPendingTask(self);
            if (task && typeof task.type == 'string') {
                // If the XHR has already completed, do nothing.
                // If the XHR has already been aborted, do nothing.
                // Fix #569, call abort multiple times before done will cause
                // macroTask task count be negative number
                if (task.cancelFn == null || (task.data && task.data.aborted)) {
                    return;
                }
                task.zone.cancelTask(task);
            }
            else if (Zone.current[fetchTaskAborting] === true) {
                // the abort is called from fetch polyfill, we need to call native abort of XHR.
                return abortNative.apply(self, args);
            }
            // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
            // task
            // to cancel. Do nothing.
        }; });
    }
});
Zone.__load_patch('geolocation', function (global) {
    /// GEO_LOCATION
    if (global['navigator'] && global['navigator'].geolocation) {
        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
    }
});
Zone.__load_patch('PromiseRejectionEvent', function (global, Zone) {
    // handle unhandled promise rejection
    function findPromiseRejectionHandler(evtName) {
        return function (e) {
            var eventTasks = findEventTasks(global, evtName);
            eventTasks.forEach(function (eventTask) {
                // windows has added unhandledrejection event listener
                // trigger the event listener
                var PromiseRejectionEvent = global['PromiseRejectionEvent'];
                if (PromiseRejectionEvent) {
                    var evt = new PromiseRejectionEvent(evtName, { promise: e.promise, reason: e.rejection });
                    eventTask.invoke(evt);
                }
            });
        };
    }
    if (global['PromiseRejectionEvent']) {
        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =
            findPromiseRejectionHandler('unhandledrejection');
        Zone[zoneSymbol('rejectionHandledHandler')] =
            findPromiseRejectionHandler('rejectionhandled');
    }
});

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

})));


/***/ }),

/***/ "./src/$$_lazy_route_resource lazy recursive":
/*!**********************************************************!*\
  !*** ./src/$$_lazy_route_resource lazy namespace object ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "./src/$$_lazy_route_resource lazy recursive";

/***/ }),

/***/ "./src/app/app-routing.module.ts":
/*!***************************************!*\
  !*** ./src/app/app-routing.module.ts ***!
  \***************************************/
/*! exports provided: AppRoutingModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppRoutingModule", function() { return AppRoutingModule; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
/* harmony import */ var _todo_component_tabs_dates_chart_dates_chart_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./todo-component/tabs/dates-chart/dates-chart.component */ "./src/app/todo-component/tabs/dates-chart/dates-chart.component.ts");
/* harmony import */ var _todo_component_tabs_species_chart_species_chart_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./todo-component/tabs/species-chart/species-chart.component */ "./src/app/todo-component/tabs/species-chart/species-chart.component.ts");
/* harmony import */ var _todo_component_tabs_zones_map_zones_map_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./todo-component/tabs/zones-map/zones-map.component */ "./src/app/todo-component/tabs/zones-map/zones-map.component.ts");
/* harmony import */ var _todo_component_tabs_data_table_data_table_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./todo-component/tabs/data-table/data-table.component */ "./src/app/todo-component/tabs/data-table/data-table.component.ts");



// import des composants ... :
// import { LeafletMapComponent } from './todo-component/tabs/leaflet-map/leaflet-map.component';




var routes = [
    { path: '**', redirectTo: '/' },
    // #### A TESTER > pas besoin si tabs ?? (One page), mais peut être si liens - modales ?? (images, icônes...)
    // Permet l'ajout d'un composant '/map' dans la page (endroit = décidé selon
    // où l'on place le 'router-outlet', dans le html : ici, testé en bas de 'tabs.component.ts')
    // { path: 'map', component: LeafletMapComponent },
    { path: 'speciechart', component: _todo_component_tabs_species_chart_species_chart_component__WEBPACK_IMPORTED_MODULE_4__["SpeciesChartComponent"] },
    { path: 'datechart', component: _todo_component_tabs_dates_chart_dates_chart_component__WEBPACK_IMPORTED_MODULE_3__["DatesChartComponent"] },
    { path: 'zonemap', component: _todo_component_tabs_zones_map_zones_map_component__WEBPACK_IMPORTED_MODULE_5__["ZonesMapComponent"] },
    { path: 'tablechart', component: _todo_component_tabs_data_table_data_table_component__WEBPACK_IMPORTED_MODULE_6__["DataTableComponent"] }
    // exemples de redirection automatique au chargement de l'application (ne marche plus ici, pour l'instant...)
    //  { path: '', redirectTo: '/fishes-linechartdata', /* pathMatch: 'full',*/ component: LinechartComponent },
    // { path: '', redirectTo: '/fishes-postsdata', /* pathMatch: 'full',*/ component: PostsComponent }
    //  { path: '', redirectTo: '/fish-dashboard', pathMatch: 'full' },
];
var AppRoutingModule = /** @class */ (function () {
    function AppRoutingModule() {
    }
    AppRoutingModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
            imports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"].forRoot(routes)],
            exports: [_angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"]]
        })
    ], AppRoutingModule);
    return AppRoutingModule;
}());



/***/ }),

/***/ "./src/app/app.component.scss":
/*!************************************!*\
  !*** ./src/app/app.component.scss ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2FwcC5jb21wb25lbnQuc2NzcyJ9 */");

/***/ }),

/***/ "./src/app/app.component.ts":
/*!**********************************!*\
  !*** ./src/app/app.component.ts ***!
  \**********************************/
/*! exports provided: AppComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppComponent", function() { return AppComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");


//  import { LinechartService } from 'linechart.service';
var AppComponent = /** @class */ (function () {
    function AppComponent() {
        this.title = 'Dataviz Fish App';
        // AVANT: DANS 'TABS.COMPONENT':
        // /* liste des membres inscription (users) */
        // showUsers = true;
        // /* pour app-config (gestion d'erreurs...) */
        // showConfig = true;
        // showSearch = true;
        // toggleUsers() { this.showUsers = !this.showUsers; }
        // toggleConfig() { this.showConfig = !this.showConfig; }
        // toggleSearch() { this.showSearch = !this.showSearch; }
    }
    AppComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-root',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./app.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/app.component.html")).default,
            providers: [],
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./app.component.scss */ "./src/app/app.component.scss")).default]
        })
    ], AppComponent);
    return AppComponent;
}());



/***/ }),

/***/ "./src/app/app.module.ts":
/*!*******************************!*\
  !*** ./src/app/app.module.ts ***!
  \*******************************/
/*! exports provided: AppModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppModule", function() { return AppModule; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm5/platform-browser.js");
/* harmony import */ var _app_routing_module__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app-routing.module */ "./src/app/app-routing.module.ts");
/* harmony import */ var _angular_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/http */ "./node_modules/@angular/http/fesm5/http.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var _app_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./app.component */ "./src/app/app.component.ts");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var ng2_charts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ng2-charts */ "./node_modules/ng2-charts/fesm5/ng2-charts.js");
/* harmony import */ var _todo_component_tabs_tabs_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./todo-component/tabs/tabs.component */ "./src/app/todo-component/tabs/tabs.component.ts");
/* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm5/animations.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
/* harmony import */ var _node_modules_saturn_datepicker_esm5_saturn_datepicker_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../node_modules/saturn-datepicker/esm5/saturn-datepicker.js */ "./node_modules/saturn-datepicker/esm5/saturn-datepicker.js");
/* harmony import */ var _asymmetrik_ngx_leaflet__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @asymmetrik/ngx-leaflet */ "./node_modules/@asymmetrik/ngx-leaflet/dist/index.js");
/* harmony import */ var ag_grid_angular_main__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ag-grid-angular/main */ "./node_modules/ag-grid-angular/main.js");
/* harmony import */ var ag_grid_angular_main__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(ag_grid_angular_main__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _node_modules_mat_range_datepicker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../node_modules/mat-range-datepicker */ "./node_modules/mat-range-datepicker/fesm5/mat-range-datepicker.js");
/* harmony import */ var _angular_material_moment_adapter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @angular/material-moment-adapter */ "./node_modules/@angular/material-moment-adapter/esm5/material-moment-adapter.es5.js");
/* harmony import */ var _todo_class_chart_update_chart_update_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./todo-class/chart-update/chart-update.component */ "./src/app/todo-class/chart-update/chart-update.component.ts");
/* harmony import */ var _todo_component_tabs_dates_chart_dates_chart_component__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./todo-component/tabs/dates-chart/dates-chart.component */ "./src/app/todo-component/tabs/dates-chart/dates-chart.component.ts");
/* harmony import */ var _todo_component_tabs_species_chart_species_chart_component__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./todo-component/tabs/species-chart/species-chart.component */ "./src/app/todo-component/tabs/species-chart/species-chart.component.ts");
/* harmony import */ var _todo_component_tabs_zones_map_zones_map_component__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./todo-component/tabs/zones-map/zones-map.component */ "./src/app/todo-component/tabs/zones-map/zones-map.component.ts");
/* harmony import */ var _todo_component_tabs_data_table_data_table_component__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./todo-component/tabs/data-table/data-table.component */ "./src/app/todo-component/tabs/data-table/data-table.component.ts");
/* harmony import */ var _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./todo-data-service/fish.service */ "./src/app/todo-data-service/fish.service.ts");
/* harmony import */ var _todo_component_tabs_search_form_search_form_component__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./todo-component/tabs/search-form/search-form.component */ "./src/app/todo-component/tabs/search-form/search-form.component.ts");
/* harmony import */ var _todo_component_tabs_form_connexion_form_connexion_component__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./todo-component/tabs/form-connexion/form-connexion.component */ "./src/app/todo-component/tabs/form-connexion/form-connexion.component.ts");
/* harmony import */ var _todo_component_config_config_component__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./todo-component/config/config.component */ "./src/app/todo-component/config/config.component.ts");
/* harmony import */ var _todo_data_service_http_error_handler_service__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./todo-data-service/http-error-handler.service */ "./src/app/todo-data-service/http-error-handler.service.ts");
/* harmony import */ var _todo_component_tabs_autocomplete_form_inscription_clean_autocomplete_form_inscription_clean_component__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component */ "./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.ts");
/* harmony import */ var _todo_component_tabs_form_admin_connexion_form_admin_connexion_component__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./todo-component/tabs/form-admin-connexion/form-admin-connexion.component */ "./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.ts");
/* harmony import */ var _todo_component_tabs_members_list_members_list_component__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./todo-component/tabs/members-list/members-list.component */ "./src/app/todo-component/tabs/members-list/members-list.component.ts");






// import { RouterModule } from '@angular/router';
// ** AJOUTS DE MODULES :

// import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
 /* reactive forms */
 // <-- NgModel lives here !

 /* essai d'onglets 1 */
 /* 'material design' import */








// #### test - marche pas ici (pb de version d'angular ??):
// import { ShapefileLeafletComponent } from './todo-component/tabs/shapefile-leaflet/shapefile-leaflet.component';
// import { LeafletMapComponent } from './todo-component/tabs/leaflet-map/leaflet-map.component';




// ***********

// *** IMPORT DE SERVICES :


/* FORMULAIRES DE CONNEXION (USAGER) - EN TEST */
// import { ReactiveFormConnexionComponent } from './todo-component/reactive-form-connexion/reactive-form-connexion.component';






// import { UnlessDirective } from './todo-directive/unless.directive';
// const ROUTES = [
//   {
//     path: '', // prise en compte du chemin vide
//     redirectTo: 'graph', // affiche par défaut un tableau sur la page web
//     pathMatch: 'full'
//   },
//   {
//     path: '**', redirectTo: 'graph' // // prise en compte du chemin 'wildcard' (pour une page d'erreur 404, par exemple)
//   },
//   {
//     path: 'graph',
//     component: LinechartComponent
//   },
//   {
//     path: 'table',
//     component: PostsComponent
//   },
//   {
//     path: 'table/view/:id',
//     component: PostsComponent
//   }
// ];
var AppModule = /** @class */ (function () {
    function AppModule() {
    }
    AppModule = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
            imports: [
                _angular_platform_browser__WEBPACK_IMPORTED_MODULE_2__["BrowserModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_7__["ReactiveFormsModule"],
                _angular_http__WEBPACK_IMPORTED_MODULE_4__["HttpModule"],
                ng2_charts__WEBPACK_IMPORTED_MODULE_8__["ChartsModule"],
                _angular_common_http__WEBPACK_IMPORTED_MODULE_5__["HttpClientModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_7__["FormsModule"],
                _app_routing_module__WEBPACK_IMPORTED_MODULE_3__["AppRoutingModule"],
                _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_10__["BrowserAnimationsModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatTabsModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatFormFieldModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatInputModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatAutocompleteModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatProgressSpinnerModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatSelectModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatButtonModule"],
                _node_modules_saturn_datepicker_esm5_saturn_datepicker_js__WEBPACK_IMPORTED_MODULE_12__["SatNativeDateModule"],
                ag_grid_angular_main__WEBPACK_IMPORTED_MODULE_14__["AgGridModule"].withComponents([]),
                _node_modules_mat_range_datepicker__WEBPACK_IMPORTED_MODULE_15__["MatRangeDatepickerModule"],
                _node_modules_mat_range_datepicker__WEBPACK_IMPORTED_MODULE_15__["MatRangeNativeDateModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatDatepickerModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["NativeDateModule"],
                // MatNativeDateModule,
                _node_modules_saturn_datepicker_esm5_saturn_datepicker_js__WEBPACK_IMPORTED_MODULE_12__["SatDatepickerModule"],
                _angular_material_moment_adapter__WEBPACK_IMPORTED_MODULE_16__["MatMomentDateModule"],
                // NgbModule,
                _asymmetrik_ngx_leaflet__WEBPACK_IMPORTED_MODULE_13__["LeafletModule"].forRoot()
                // ********************** POUR TEST :
                // The HttpClientInMemoryWebApiModule module intercepts HTTP requests
                // and returns simulated server responses.
                // Remove it when a real server is ready to receive requests.
                // RouterModule.forRoot(ROUTES), // Add routes to the app
                // *******************
                // HttpClientInMemoryWebApiModule.forRoot(
                //   InMemoryDataService, { dataEncapsulation: false, delay: 1000 }
                // )
                // ********************
            ],
            declarations: [
                _app_component__WEBPACK_IMPORTED_MODULE_6__["AppComponent"],
                _todo_component_tabs_tabs_component__WEBPACK_IMPORTED_MODULE_9__["TabsComponent"],
                _todo_component_tabs_data_table_data_table_component__WEBPACK_IMPORTED_MODULE_21__["DataTableComponent"],
                _todo_class_chart_update_chart_update_component__WEBPACK_IMPORTED_MODULE_17__["ChartUpdateComponent"],
                _todo_component_tabs_species_chart_species_chart_component__WEBPACK_IMPORTED_MODULE_19__["SpeciesChartComponent"],
                _todo_component_tabs_zones_map_zones_map_component__WEBPACK_IMPORTED_MODULE_20__["ZonesMapComponent"],
                // ShapefileLeafletComponent // marche pas ici
                // LeafletMapComponent,
                _todo_component_tabs_dates_chart_dates_chart_component__WEBPACK_IMPORTED_MODULE_18__["DatesChartComponent"],
                _todo_component_tabs_search_form_search_form_component__WEBPACK_IMPORTED_MODULE_23__["SearchFormComponent"],
                // ReactiveFormConnexionComponent, 
                _todo_component_tabs_form_connexion_form_connexion_component__WEBPACK_IMPORTED_MODULE_24__["FormConnexionComponent"],
                _todo_component_config_config_component__WEBPACK_IMPORTED_MODULE_25__["ConfigComponent"],
                _todo_component_tabs_autocomplete_form_inscription_clean_autocomplete_form_inscription_clean_component__WEBPACK_IMPORTED_MODULE_27__["AutocompleteFormInscriptionCleanComponent"],
                _todo_component_tabs_form_admin_connexion_form_admin_connexion_component__WEBPACK_IMPORTED_MODULE_28__["FormAdminConnexionComponent"],
                _todo_component_tabs_members_list_members_list_component__WEBPACK_IMPORTED_MODULE_29__["MembersListComponent"],
            ],
            exports: [
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatTabsModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatInputModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatAutocompleteModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatProgressSpinnerModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatSelectModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatButtonModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_11__["MatDatepickerModule"],
                _node_modules_saturn_datepicker_esm5_saturn_datepicker_js__WEBPACK_IMPORTED_MODULE_12__["SatDatepickerModule"],
                _node_modules_saturn_datepicker_esm5_saturn_datepicker_js__WEBPACK_IMPORTED_MODULE_12__["SatNativeDateModule"]
            ],
            entryComponents: [],
            bootstrap: [
                _app_component__WEBPACK_IMPORTED_MODULE_6__["AppComponent"]
            ],
            providers: [
                _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_22__["FishService"],
                _todo_data_service_http_error_handler_service__WEBPACK_IMPORTED_MODULE_26__["HttpErrorHandler"]
            ],
            schemas: [_angular_core__WEBPACK_IMPORTED_MODULE_1__["CUSTOM_ELEMENTS_SCHEMA"]]
        })
    ], AppModule);
    return AppModule;
}());



/***/ }),

/***/ "./src/app/todo-class/barchart-options.ts":
/*!************************************************!*\
  !*** ./src/app/todo-class/barchart-options.ts ***!
  \************************************************/
/*! exports provided: BarchartOptionsService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BarchartOptionsService", function() { return BarchartOptionsService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);


// import Chart from 'chart.js';

var moment = moment__WEBPACK_IMPORTED_MODULE_2__;
var BarchartOptionsService = /** @class */ (function () {
    function BarchartOptionsService() {
        // *****************************
        // MODÈLE DU GRAPHIQUE :
        // *****************************
        this.type = 'bar';
        // data: data, // marche pas
        this.data = {
            labels: [],
            datasets: [
                {
                    label: [],
                    data: [],
                    backgroundColor: 'rgba(255, 68, 0, 0.49)',
                    borderColor: '#ff4500' // backgroundColor: '#FF6384'
                },
                {
                    label: [],
                    data: [],
                    borderColor: '#2d9ab7' // bleu clair: #2d9ab7 / #36A2EB (bleu de base)
                }
            ]
        };
        this.options = {
            responsive: true,
            tooltips: {
                enabled: true,
                position: 'nearest',
                fontFamily: 'sans-serif',
                fontSize: 10,
                callbacks: {
                    title: function (tooltipItem /*, data */) {
                        var title = tooltipItem[0].xLabel || '';
                        return title;
                    },
                    label: function (tooltipItem, data) {
                        var datas = tooltipItem.yLabel; // paramètre pour accéder aux données du graphique
                        var capturesLabel = 'Quantité (en tonnes) : ' + datas || false;
                        var quotasLabel = 'Quota (en tonnes) : ' + datas || false;
                        if (capturesLabel != null && tooltipItem.datasetIndex === 0) {
                            // labelCaptures += ' tonnes';
                            return capturesLabel;
                        }
                        if (quotasLabel != null && tooltipItem.datasetIndex === 1) {
                            // quotasLabel += ' tonnes';
                            return quotasLabel;
                        }
                        // alert(tooltipItem.toSource()); // pour vérifier le type de l'objet reçu dans le tooltip = tableau d'objets : [{ }]
                        // alert(data.toSource()); // pour vérifier le type de l'objet reçu dans le tooltip = tableau d'objets : [{ }]
                    }
                }
            },
            legend: {
                display: true,
                labels: {
                    fontFamily: 'sans-serif',
                    fontSize: 14,
                    fontColor: 'black',
                    padding: 20,
                    usePointStyle: true
                }
            },
            //  maintainAspectRatio: true,
            scales: {
                xAxes: [{
                        // type: 'time', // AJOUT
                        distribution: 'linear',
                        scaleLabel: {
                            display: true,
                            fontFamily: 'sans-serif',
                            fontSize: 14,
                            padding: 20,
                            labelString: 'Dates de Captures et de Quotas',
                            fontColor: 'black'
                        },
                        fontFamily: 'sans-serif',
                        fontSize: 14,
                        // fontColor: 'black',
                        ticks: {
                            beginAtZero: true,
                        },
                    }],
                yAxes: [{
                        // distribution: 'linear', // AJOUT :data are spread according to their time (distances can vary)
                        fontFamily: 'sans-serif',
                        fontSize: 14,
                        fontColor: 'black',
                        scaleLabel: {
                            display: true,
                            fontFamily: 'sans-serif',
                            fontSize: 14,
                            padding: 20,
                            fontColor: 'black',
                            labelString: 'Quantités en Tonnes (T)',
                        },
                        stacked: false,
                        ticks: {
                            beginAtZero: true
                            // callback: function(value, index, values) {
                            //   // alert(value.toSource()); // pour vérifier le type de l'objet reçu dans le tooltip = tableau d'objets : [{ }]
                            //   return value + ' T';
                            // }
                        }
                    }]
            },
            labels: [{
                // MODIF enlevé : chartLabels
                }],
        };
    }
    BarchartOptionsService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
            providedIn: 'root'
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [])
    ], BarchartOptionsService);
    return BarchartOptionsService;
}());



/***/ }),

/***/ "./src/app/todo-class/chart-update/chart-update.component.ts":
/*!*******************************************************************!*\
  !*** ./src/app/todo-class/chart-update/chart-update.component.ts ***!
  \*******************************************************************/
/*! exports provided: ChartUpdateComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChartUpdateComponent", function() { return ChartUpdateComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");


var ChartUpdateComponent = /** @class */ (function () {
    function ChartUpdateComponent(elementRef, ngZone) {
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.clickCanvas = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.clickDataset = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.clickElements = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        this.clickElement = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
    }
    ChartUpdateComponent.prototype.ngOnInit = function () {
        this.create();
    };
    ChartUpdateComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (this.chart) {
            if (changes['type'] || changes['options']) {
                this.create();
            }
            else if (changes['data']) {
                var currentValue_1 = changes['data'].currentValue;
                ['datasets', 'labels', 'xLabels', 'yLabels'].forEach(function (property) {
                    _this.chart.data[property] = currentValue_1[property];
                });
                this.chart.update();
            }
        }
    };
    ChartUpdateComponent.prototype.create = function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            if (_this.canvas) {
                _this.elementRef.nativeElement.removeChild(_this.canvas);
            }
            _this.canvas = document.createElement('canvas');
            _this.elementRef.nativeElement.appendChild(_this.canvas);
            _this.chart = new Chart(_this.canvas, {
                type: _this.type,
                data: _this.data,
                options: _this.options
            });
            _this.canvas.onclick = function (e) {
                _this.ngZone.run(function () {
                    _this.clickCanvas.next(e);
                    if (_this.clickDataset.observers.length) {
                        _this.clickDataset.next(_this.chart.getDatasetAtEvent(e));
                    }
                    // if (this.clickElements.observers.length) {
                    //   this.clickElements.next(this.chart.getElementsAtEvent(e));
                    // }
                    // if (this.clickElement.observers.length) {
                    //   this.clickElement.next(this.chart.getElementAtEvent(e));
                    // }
                });
            };
        });
    };
    ChartUpdateComponent.ctorParameters = function () { return [
        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"] },
        { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"] }
    ]; };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], ChartUpdateComponent.prototype, "type", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], ChartUpdateComponent.prototype, "data", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], ChartUpdateComponent.prototype, "options", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], ChartUpdateComponent.prototype, "clickCanvas", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], ChartUpdateComponent.prototype, "clickDataset", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], ChartUpdateComponent.prototype, "clickElements", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Object)
    ], ChartUpdateComponent.prototype, "clickElement", void 0);
    ChartUpdateComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-chart-update',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./chart-update.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-class/chart-update/chart-update.component.html")).default,
            styles: [":host { display: block; }"]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"],
            _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgZone"]])
    ], ChartUpdateComponent);
    return ChartUpdateComponent;
}());



/***/ }),

/***/ "./src/app/todo-class/fish.ts":
/*!************************************!*\
  !*** ./src/app/todo-class/fish.ts ***!
  \************************************/
/*! exports provided: Fish */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fish", function() { return Fish; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// modèle pour les données :

var Fish = /** @class */ (function () {
    function Fish(id_fishing, value_landing, value_quota, date, // Date dans la BDD
    name_specie, super_zone, zone, z_coord, sz_coord) {
        this.id_fishing = id_fishing;
        this.value_landing = value_landing;
        this.value_quota = value_quota;
        this.date = date;
        this.name_specie = name_specie;
        this.super_zone = super_zone;
        this.zone = zone;
        this.z_coord = z_coord;
        this.sz_coord = sz_coord;
    }
    Fish.fromJson = function (json) {
        return new Fish(json['id_fishing'], json['value_landing'], json['value_quota'], json['date'], json['name_specie'], json['super_zone'], json['zone'], json['z_coord'], json['sz_coord']);
    };
    return Fish;
}());

// console.log('Fish constructor OUTPUT : ' + Fish);
/*
export class Fish {
    id_fishing: number;
    value_landing: number;
    value_quota: number;
    date: string;
    name_specie: string;
    super_zone: string;
    zone: string;
}


console.log('Fish constructor OUTPUT : ' + Fish);
*/
/*
export interface IUserResponse {
    total: number;
    results: Fish[];
}



/* exemple : http://localhost:3000/api/AllFishings
    {
        "id_fishing": 1;
        "value_landing": 18411;
        "value_quota": 20274;
        "date": "2018-02-06";
        "name_specie": "Cod";
        "super_zone": "North sea";
        "zone": "North sea"
    }
*/


/***/ }),

/***/ "./src/app/todo-class/linechart-options.ts":
/*!*************************************************!*\
  !*** ./src/app/todo-class/linechart-options.ts ***!
  \*************************************************/
/*! exports provided: LinechartOptionsService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinechartOptionsService", function() { return LinechartOptionsService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_2__);



var moment = moment__WEBPACK_IMPORTED_MODULE_2__;
var LinechartOptionsService = /** @class */ (function () {
    function LinechartOptionsService() {
        // *****************************
        // MODÈLE DU GRAPHIQUE :
        // *****************************
        // const Chart = require('chart.js');
        // require(['../node_modules/chart.js/dist/Chart.js'], function(Chart) {
        // const canvas = <HTMLCanvasElement> document.getElementById('mycanvas');
        // const ctx = this.canvas.getContext('2d');
        // const ctx = document.getElementById('myChart');
        // const ctx = document.getElementById('myChart').getContext('2d');
        // const ctx = 'myChart';
        // Chart.defaults.global.defaultFontFamily = 'source-sans-pro'; // marche pas
        // const myChart = new Chart(this.ctx, { // marche pas
        this.type = 'line';
        // data: data, // marche pas
        this.data = {
            labels: [],
            datasets: [
                {
                    label: [],
                    data: [],
                    backgroundColor: 'rgba(255, 68, 0, 0.49)',
                    borderColor: '#ff4500' // backgroundColor: '#FF6384'
                },
                {
                    label: [],
                    data: [],
                    borderColor: '#2d9ab7' // #36A2EB (bleu de base)
                }
            ]
        };
        this.options = {
            padding: {
                left: 20,
                right: 0,
                top: 0,
                bottom: 0
            },
            responsive: true,
            // maintainAspectRatio: false,
            // responsiveAnimationDuration: 2000,
            tooltips: {
                enabled: true,
                position: 'nearest',
                borderWidth: 1,
                fontFamily: 'sans-serif',
                fontSize: 10,
                // usePointStyle: true,
                callbacks: {
                    title: function (tooltipItem /*, data */) {
                        var title = 'Date : ' + tooltipItem[0].xLabel || false;
                        // console.log(title);
                        // const parsedTitle = moment(title, 'YYYY-MM-DD').format('DD-MM-YYYY');
                        var parsedTitle = moment(title, 'YYYY-MM-DD').locale('fr').format('LL');
                        // console.log(parsedTitle);
                        return parsedTitle;
                    },
                    label: function (tooltipItem, data) {
                        var datas = tooltipItem.yLabel; // paramètre pour accéder aux données du graphique
                        var capturesLabel = 'Quantité (en tonnes) : ' + datas || false;
                        var quotasLabel = 'Quota (en tonnes) : ' + datas || false;
                        if (capturesLabel != null && tooltipItem.datasetIndex === 0) {
                            // labelCaptures += ' tonnes';
                            return capturesLabel;
                        }
                        if (quotasLabel != null && tooltipItem.datasetIndex === 1) {
                            // quotasLabel += ' tonnes';
                            return quotasLabel;
                        }
                        // alert(tooltipItem.toSource()); // pour vérifier le type de l'objet reçu dans le tooltip = tableau d'objets : [{ }]
                        // return dataLabel;
                    }
                }
            },
            legend: {
                display: true,
                fullWidth: true,
                position: 'top',
                labels: {
                    fontFamily: 'sans-serif',
                    fontSize: 12,
                    fontColor: 'black',
                    // padding: 20, // marge du haut
                    usePointStyle: true
                }
            },
            scales: {
                xAxes: [{
                        type: 'time',
                        distribution: 'linear',
                        scaleLabel: {
                            display: true,
                            fontFamily: 'sans-serif',
                            fontSize: 12,
                            // padding: 20,
                            labelString: 'Dates de Captures et de Quotas',
                            fontColor: 'black'
                        },
                        // fontFamily: 'sans-serif', // source-sans-pro
                        // fontSize: 14,
                        // fontColor: 'black',
                        ticks: {
                            beginAtZero: true,
                            padding: 10,
                        },
                        time: {
                            unit: 'month',
                            // unit: 'day',
                            displayFormats: {
                                month: 'MM-YYYY',
                            }
                        }
                    }],
                yAxes: [{
                        // distribution: 'linear', // AJOUT :data are spread according to their time (distances can vary)
                        fontFamily: 'sans-serif',
                        fontSize: 14,
                        // fontColor: 'black',
                        scaleLabel: {
                            display: true,
                            fontFamily: 'sans-serif',
                            fontSize: 12,
                            // padding: 20,
                            fontColor: 'black',
                            labelString: 'Quantités en Tonnes (T)',
                        },
                        stacked: false,
                        ticks: {
                            beginAtZero: true,
                            padding: 10,
                        }
                    }]
            },
            labels: [{
                // MODIF enlevé : chartLabels
                }]
            // animation: {
            //   duration: 1000 // general animation time (ms)
            // },
            // hover: {
            //     animationDuration: 1000 // duration of animations when hovering an item
            // },
            // responsiveAnimationDuration: 1000, // animation duration after a resize
            // pan: { // PAN DÉSACTIVÉ
            //   enabled: false,
            //   mode: 'xy',
            //   speed: 20,
            //   threshold: 10
            // },
            // zoom: { // ZOOM DÉSACTIVÉ
            //   enabled: false,
            //   mode: 'xy',
            //   sensitivity: 100,
            //   rangeMin: {
            //     // Format of min pan range depends on scale type
            //     x: null,
            //     y: 0  // le graphique ne prend pas en compte les chiffres négatifs
            //   },
            // },
            // rangeMax: {
            //   // Format of max pan range depends on scale type
            //   x: null,
            //   y: null
            // }
        };
    }
    LinechartOptionsService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
            providedIn: 'root'
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [])
    ], LinechartOptionsService);
    return LinechartOptionsService;
}());



/***/ }),

/***/ "./src/app/todo-class/user.ts":
/*!************************************!*\
  !*** ./src/app/todo-class/user.ts ***!
  \************************************/
/*! exports provided: User */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "User", function() { return User; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// modèle pour les données des utilisateurs :

var User = /** @class */ (function () {
    function User(id_user, user_firstname, user_lastname, login, password, mail) {
        this.id_user = id_user;
        this.user_firstname = user_firstname;
        this.user_lastname = user_lastname;
        this.login = login;
        this.password = password;
        this.mail = mail;
    }
    User.fromJson = function (json) {
        return new User(json['id_user'], json['user_firstname'], json['user_lastname'], json['login'], json['password'], json['mail']);
    };
    return User;
}());



/***/ }),

/***/ "./src/app/todo-component/config/config.component.ts":
/*!***********************************************************!*\
  !*** ./src/app/todo-component/config/config.component.ts ***!
  \***********************************************************/
/*! exports provided: ConfigComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigComponent", function() { return ConfigComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _todo_data_service_config_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../todo-data-service/config.service */ "./src/app/todo-data-service/config.service.ts");



var ConfigComponent = /** @class */ (function () {
    function ConfigComponent(configService) {
        this.configService = configService;
    }
    ConfigComponent.prototype.clear = function () {
        this.config = undefined;
        this.error = undefined;
        this.headers = undefined;
    };
    ConfigComponent.prototype.showConfig = function () {
        var _this = this;
        this.configService.getConfig()
            .subscribe(function (data) { return _this.config = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, data); }, // success path
        function (// success path
        error) { return _this.error = error; } // error path
        );
    };
    ConfigComponent.prototype.showConfig_v1 = function () {
        var _this = this;
        this.configService.getConfig_1()
            .subscribe(function (data) { return _this.config = {
            heroesUrl: data['heroesUrl'],
            textfile: data['textfile']
        }; });
    };
    ConfigComponent.prototype.showConfig_v2 = function () {
        var _this = this;
        this.configService.getConfig()
            // clone the data object, using its known Config shape
            .subscribe(function (data) { return _this.config = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, data); });
    };
    ConfigComponent.prototype.showConfigResponse = function () {
        var _this = this;
        this.configService.getConfigResponse()
            // resp is of type `HttpResponse<Config>`
            .subscribe(function (resp) {
            // display its headers
            var keys = resp.headers.keys();
            _this.headers = keys.map(function (key) {
                return key + ": " + resp.headers.get(key);
            });
            // access the body directly, which is typed as `Config`.
            _this.config = tslib__WEBPACK_IMPORTED_MODULE_0__["__assign"]({}, resp.body);
        });
    };
    ConfigComponent.prototype.makeError = function () {
        var _this = this;
        this.configService.makeIntentionalError().subscribe(null, function (error) { return _this.error = error; });
    };
    ConfigComponent.ctorParameters = function () { return [
        { type: _todo_data_service_config_service__WEBPACK_IMPORTED_MODULE_2__["ConfigService"] }
    ]; };
    ConfigComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-config',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./config.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/config/config.component.html")).default,
            providers: [_todo_data_service_config_service__WEBPACK_IMPORTED_MODULE_2__["ConfigService"]],
            styles: [".error {color: red;}"]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_todo_data_service_config_service__WEBPACK_IMPORTED_MODULE_2__["ConfigService"]])
    ], ConfigComponent);
    return ConfigComponent;
}());

/*
Copyright Google LLC. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
*/ 


/***/ }),

/***/ "./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.scss":
/*!****************************************************************************************************************************!*\
  !*** ./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.scss ***!
  \****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/*\n  Copyright Google LLC. All Rights Reserved.\n  Use of this source code is governed by an MIT-style license that\n  can be found in the LICENSE file at http://angular.io/license\n  */\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3lhbm5pc2NvZGUvRGVza3RvcC91a3F1b3RhLmRhdGF2aXouZmlzaC16LWV4cG9ydC1tb2RhbGVzLWZvcm0tY29ubmV4aW9uLWIvc3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2F1dG9jb21wbGV0ZS1mb3JtLWluc2NyaXB0aW9uLWNsZWFuL2F1dG9jb21wbGV0ZS1mb3JtLWluc2NyaXB0aW9uLWNsZWFuLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2F1dG9jb21wbGV0ZS1mb3JtLWluc2NyaXB0aW9uLWNsZWFuL2F1dG9jb21wbGV0ZS1mb3JtLWluc2NyaXB0aW9uLWNsZWFuLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlFOzs7O0dDQUMiLCJmaWxlIjoic3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2F1dG9jb21wbGV0ZS1mb3JtLWluc2NyaXB0aW9uLWNsZWFuL2F1dG9jb21wbGV0ZS1mb3JtLWluc2NyaXB0aW9uLWNsZWFuLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLmNyb3NzLXZhbGlkYXRpb24tZXJyb3IgaW5wdXQge1xuLy8gICAgIGJvcmRlci1sZWZ0OiA1cHggc29saWQgcmVkO1xuLy8gfVxuXG4gIC8qXG4gIENvcHlyaWdodCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0XG4gIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHA6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgKi8iLCIvKlxuICBDb3B5cmlnaHQgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdFxuICBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICovXG4iXX0= */");

/***/ }),

/***/ "./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.ts":
/*!**************************************************************************************************************************!*\
  !*** ./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.ts ***!
  \**************************************************************************************************************************/
/*! exports provided: AutocompleteFormInscriptionCleanComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteFormInscriptionCleanComponent", function() { return AutocompleteFormInscriptionCleanComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-data-service/users.service */ "./src/app/todo-data-service/users.service.ts");








var AutocompleteFormInscriptionCleanComponent = /** @class */ (function () {
    // inscriptionForm = this.fb.group({ // groupe de champs de recherches pour la validation d'un formulaire 'réactif'
    //   //  firstName: ['', Validators.required], // exemple de champs simple, à la différence des tableaux de données utilisés ici :
    //   login: ['', Validators.required]
    // });
    function AutocompleteFormInscriptionCleanComponent(fb, usersService) {
        this.fb = fb;
        this.usersService = usersService;
        // Affichage ou non des boutons avec *ngIf :
        this.showPreUpdateUserButton = true; // SI L'ON SOUHAITE UN BOUTON DE PRÉVALIDATION
        this.showUpdateUserButton = false;
        this.showUserInscriptionButton = true;
        this.showCancelButton = false;
        // CHAMPS AUTO-COMPLETE (MÉTHODE AVEC OBSERVABLE QUI MARCHE AVEC DES DONNÉES RÉELLES = objets en input)
        this.user = {
            id_user: '',
            user_firstname: '',
            user_lastname: '',
            login: '',
            password: '',
            mail: ''
        };
        this.data$ = []; // nécessaire sous ce type (any - les autres ne semblent pas marcher...) (tableau vide) car utilisé pour filtrer les données saisies (_loginFilter, _mailFilter)
        /* MÉTHODE POUR AVOIR UN FORMULAIRE  :*/
        // inscriptionForm: FormGroup;
        this.inscriptionForm = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormGroup"]({
            login: new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"](this.user.login, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required
            ]),
            mail: new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"](this.user.mail, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required,
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].email
            ])
        });
        // this.usersService.getUsers() // apparemment pas conseillé comme ça (à revoir si possible...)
        // .subscribe(data$ => {  
        //   this.data$ = data$;
        // });
        // this.usersService.getUsers().subscribe(login$ => {  // indiquer ici la route vers l'api choisie
        //   this.login$ = login$;
        // });
        // this.usersService.getUsers().subscribe(mail$ => {
        //   this.mail$ = mail$;
        // });
    }
    Object.defineProperty(AutocompleteFormInscriptionCleanComponent.prototype, "login", {
        // ECOUTE DES VALEURS DU CHAMPS LOGIN
        get: function () {
            return this.inscriptionForm.get('login');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AutocompleteFormInscriptionCleanComponent.prototype, "mail", {
        // ECOUTE DES VALEURS DU CHAMPS MAIL
        get: function () {
            return this.inscriptionForm.get('mail');
        },
        enumerable: true,
        configurable: true
    });
    // // RECHERCHE LES CHAMPS CORRESPONDANTS AU MOYEN DES MÉTHODES DU FICHIER 'users.service.ts' (= TABLEAU DE STRINGS)
    AutocompleteFormInscriptionCleanComponent.prototype._loginFilter = function (value) {
        var _this = this;
        this.showUserInscriptionButton = true;
        this.showPreUpdateUserButton = true;
        this.showUpdateUserButton = false;
        console.log(value);
        // méthode appelée pour l'update de la liste des logins du champs auto-complete : (ÉVITE APPELS DES DONNÉES DANS LE CONSTRUCTEUR...)
        this.usersService.getUsers()
            .subscribe(function (data$) {
            _this.data$ = data$;
            console.log(_this.data$);
            return _this.data$;
        });
        console.log(this.data$);
        // const logins = this.users;
        var datas = this.data$;
        console.log(datas);
        var userData = [];
        for (var i = 0; i < datas.length; i++) {
            userData.push(datas[i].login);
        }
        console.log(userData);
        var filterValue = value.toLowerCase();
        return userData.filter(function (user) { return user
            .toLowerCase()
            .includes(filterValue); });
    };
    AutocompleteFormInscriptionCleanComponent.prototype._mailFilter = function (value) {
        var _this = this;
        this.showUserInscriptionButton = true;
        this.showPreUpdateUserButton = true;
        this.showUpdateUserButton = false;
        // TEST: méthode appelée pour l'update de la liste des logins du champs auto-complete :
        this.usersService.getUsers()
            .subscribe(function (data$) {
            _this.data$ = data$;
            console.log(_this.data$);
            return _this.data$;
        });
        console.log(this.data$);
        var datas = this.data$;
        console.log(datas);
        var mailData = [];
        for (var i = 0; i < datas.length; i++) {
            mailData.push(datas[i].mail);
        }
        console.log(mailData);
        var filterValue = value.toLowerCase();
        return mailData
            .filter(function (user) { return user
            .toLowerCase()
            .includes(filterValue); });
    };
    // onSubmit() {
    //   // TODO: Use EventEmitter with form value
    //   console.log('VALUE NAME_SPECIE \'ON SUBMIT _\' DANS UN CHAMPS DE FORMULAIRE : ' + this.inscriptionForm.value.login);
    // }
    // APPEL DES DONNÉES GÉNÉRALES SUR LES UTILISATEURS:
    AutocompleteFormInscriptionCleanComponent.prototype.getUsers = function () {
        var _this = this;
        return this.usersService.getUsers()
            .subscribe(function (user$) { return (_this.user$ = user$); });
    };
    AutocompleteFormInscriptionCleanComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.getUsers();
        // ÉCOUTER LES CHANGEMENTS DANS LES DONNÉES TAPÉES DANS LE CHAMPS (= STRING):
        this.loginFilteredOptions = this.login.valueChanges
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["startWith"])(''), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["map"])(function (value) { return _this._loginFilter(value); }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["debounceTime"])(300));
        this.mailFilteredOptions = this.mail.valueChanges
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["startWith"])(''), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["map"])(function (value) { return _this._mailFilter(value); }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["debounceTime"])(300));
    };
    // NECESSAIRE POUR L'UPDATE:
    AutocompleteFormInscriptionCleanComponent.prototype.onEdit = function (user) {
        console.log(user);
        console.log(this.editUser);
        if (this.editUser === undefined) {
            console.log(this.editUser);
            this.showUpdateUserButton = false; // le bouton update (User) ne disparait pas
        }
        else if (this.editUser.id_user === null || this.editUser.id_user === undefined) {
            console.log(this.editUser);
            this.editUser = user;
            this.showUpdateUserButton = false; // le bouton update (User) disparait
        }
        else if (this.editUser.id_user !== null || this.editUser.id_user !== undefined) {
            console.log(this.editUser);
            this.editUser.login = user.login;
            console.log(this.editUser.login);
            this.editUser.mail = user.mail;
            console.log(this.editUser.mail);
            // alert('Veuillez penser à valider de nouveau pour confirmer la modification du profil...');
            // le bouton Pre-update disparait (si utilisé...) :
            this.showPreUpdateUserButton = false;
            // this.showUpdateUserButton = true;
            this.showCancelButton = true;
        }
    };
    /* cf: methode add() */
    AutocompleteFormInscriptionCleanComponent.prototype.onInscriptionSubmit = function (login, mail) {
        var _this = this;
        console.log(login);
        this.getUsers();
        console.log(this.getUsers());
        this.editUser = undefined;
        login = login.trim();
        if (!login) {
            return;
        }
        console.log(mail);
        mail = mail.trim();
        if (!mail) {
            return;
        }
        // The server will generate the id for this new user
        var newUser = { login: login, mail: mail };
        this.usersService
            .addUser(newUser)
            .subscribe(function (user) {
            if (newUser) {
                _this.user.login = newUser.login;
                _this.user.mail = newUser.mail;
            }
            return;
        });
        // .subscribe(user => this.users.push(user));
        newUser = undefined;
        this.inscriptionForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
        this.showUserInscriptionButton = true; // le bouton d'inscription ne disparait pas
        this.showCancelButton = false;
    };
    AutocompleteFormInscriptionCleanComponent.prototype.onLoginSelect = function (valueLogin) {
        var _this = this;
        console.log(valueLogin); // valeur récupérée dans la liste déroulante (auto-complete)
        // partie champs 'login' à réaliser :
        // ETAPES :
        // à la sélection d'un utilisateur(login) dans la liste (mat-auto-complete):
        // le champs 'login' affiche le login sélectionné : OK !
        // on récupère id_user pour l'update():
        //    --> appel à l'API (get) avec pour paramètre le login choisi : OK !
        //    --> 'SELECT 'id_user', 'mail' FROM `users` WHERE login='"+login+"'; : OK !
        // à l'update: mise à jour du login après modification de login: OK !
        // le champs 'mail' affiche le mail correspondant: OK !
        // problème de MAJ de la liste des données login sélectionnées: avancé... OK... un peu lent au changement
        // problème : boutons submit update et confirmation disparus après update: Ok ! résolu
        // A ajouter: 
        // bouton d'annulation de la mise à jour en cours (apparaissant avant confirmation): OK !
        // bouton de reset du formulaire: ok!
        // reset du formulaire après la mise à jour du membre: efface liste de logins: OK !
        // reset du formulaire après l'inscription d'un nouveau membre: OK !
        // reset du formulaire après la désinscription d'un membre: marche pas... 
        // si le membre existe, bouton d'inscription = désactivé: OK !
        // bouton de désinscription (pas essentiel: présent dans la liste déroulante): à revoir plus tard si nécessaire...
        // partie champs 'mail' (update) à réaliser :
        // méthode onMailSelect() à créer : OK !
        // problèmes :
        // return = insertion d'un nouveau membre -> IRRÉSOLU
        // si sélection d'un membre (ex: 'login') > clic en dehors > reclic dans le champs : bouton pré-update disparait et confirmer apparait
        this.usersService.getSingleUserLogin(valueLogin)
            .subscribe(function (user$) {
            // user$ = objet User[] récupéré à l'API pour avoir les données de l'usager sélectionné
            _this.user$ = user$;
            console.log(_this.user$);
            if (_this.user$) {
                _this.editUser = _this.user$[0];
                console.log(_this.editUser);
                if (_this.editUser !== undefined || _this.editUser !== null) {
                    _this.inscriptionForm.setValue({ login: _this.editUser.login, mail: _this.editUser.mail });
                    _this.showUserInscriptionButton = false; // le bouton d'inscription disparait si le membre sélectionné existe déjà
                    _this.showCancelButton = true;
                }
            }
            else {
                _this.inscriptionForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
                _this.showUserInscriptionButton = true; // le bouton d'inscription ne disparait pas
                _this.showCancelButton = false;
            }
        });
    };
    AutocompleteFormInscriptionCleanComponent.prototype.onMailSelect = function (valueMail) {
        var _this = this;
        console.log(valueMail); // valeur récupérée dans la liste déroulante (auto-complete)
        // partie champs 'mail' (update) à finir :
        this.usersService.getSingleUserMail(valueMail)
            .subscribe(function (user$) {
            _this.user$ = user$;
            if (_this.user$) {
                console.log(_this.user$);
                _this.editUser = _this.user$[0];
                console.log(_this.editUser);
                if (_this.editUser !== undefined || _this.editUser !== null) {
                    _this.inscriptionForm.setValue({ login: _this.editUser.login, mail: _this.editUser.mail });
                    _this.showUserInscriptionButton = false; // le bouton d'inscription disparait si le membre sélectionné existe déjà
                    _this.showCancelButton = true;
                }
            }
            else {
                _this.inscriptionForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
                _this.showUserInscriptionButton = true; // le bouton d'inscription ne disparait pas
                _this.showCancelButton = false;
            }
        });
    };
    // MÉTHODE similaire à onEdit(user), appliquée au bouton de pré-update:
    AutocompleteFormInscriptionCleanComponent.prototype.onPreUpdate = function (user) {
        console.log(user);
        console.log(this.editUser);
        if (this.editUser === undefined) {
            console.log(this.editUser);
            this.showUpdateUserButton = false; // le bouton update (User) ne disparait pas
        }
        else if (this.editUser.id_user === null || this.editUser.id_user === undefined) {
            console.log(this.editUser);
            this.editUser = user;
            this.showUpdateUserButton = false; // le bouton update (User) disparait
        }
        else if (this.editUser.id_user !== null || this.editUser.id_user !== undefined) {
            console.log(this.editUser);
            this.editUser.login = user.login;
            console.log(this.editUser.login);
            this.editUser.mail = user.mail;
            console.log(this.editUser.mail);
            // le bouton Pre-update disparait (si utilisé...), le bouton Update apparait :
            this.showPreUpdateUserButton = false;
            this.showUpdateUserButton = true;
            this.showCancelButton = true;
        }
    };
    AutocompleteFormInscriptionCleanComponent.prototype.onUpdate = function () {
        var _this = this;
        console.log(this.editUser);
        if (this.editUser) {
            this.usersService
                .updateUser(this.editUser)
                .subscribe(function (user) {
                var ix = user ? _this.user$.findIndex(function (u) { return u.id_user === user.id_user; }) : -1;
                if (ix > -1) {
                    _this.user$[ix] = user;
                }
            });
            this.editUser = undefined; // réinitialisation de la variable
            // Cette fois, le bouton Update disparait, (le bouton Pre-Update apparait, si utilisé...) :
            this.showUpdateUserButton = false;
            this.showPreUpdateUserButton = true;
            this.inscriptionForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
            this.showUserInscriptionButton = true; // le bouton d'inscription ne disparait pas
            this.showCancelButton = false;
        }
    };
    AutocompleteFormInscriptionCleanComponent.prototype.onResetAction = function () {
        // Cette fois, le bouton Update disparait, le bouton Pre-Update apparait :
        this.showUpdateUserButton = false;
        this.showPreUpdateUserButton = true;
        this.editUser = undefined; // réinitialisation de la variable
        // this.user$ = undefined;
        this.inscriptionForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
        this.showUserInscriptionButton = true; // le bouton d'inscription ne réapparait pas
        this.showCancelButton = false;
    };
    // DELETE (MARCHE AVEC LE FORMULAIRE, PAR LA LISTE DU CHAMPS LOGIN, OU PAR BOUTONS SUR LE TABLEAU D'ÉLÉMENTS)
    AutocompleteFormInscriptionCleanComponent.prototype.onDelete = function (login) {
        console.log(login);
        this.usersService
            .deleteUser3(login)
            .subscribe();
        // this.inscriptionForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé: A RETESTER
        this.showUserInscriptionButton = true; // le bouton d'inscription ne disparait pas
        this.showCancelButton = false;
    };
    AutocompleteFormInscriptionCleanComponent.ctorParameters = function () { return [
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"] },
        { type: _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__["UsersService"] }
    ]; };
    AutocompleteFormInscriptionCleanComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-autocomplete-form-inscription-clean',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./autocomplete-form-inscription-clean.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.html")).default,
            providers: [
                _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__["UsersService"]
            ],
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./autocomplete-form-inscription-clean.component.scss */ "./src/app/todo-component/tabs/autocomplete-form-inscription-clean/autocomplete-form-inscription-clean.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"],
            _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__["UsersService"]])
    ], AutocompleteFormInscriptionCleanComponent);
    return AutocompleteFormInscriptionCleanComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/data-table/data-table.component.scss":
/*!**************************************************************************!*\
  !*** ./src/app/todo-component/tabs/data-table/data-table.component.scss ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvZGF0YS10YWJsZS9kYXRhLXRhYmxlLmNvbXBvbmVudC5zY3NzIn0= */");

/***/ }),

/***/ "./src/app/todo-component/tabs/data-table/data-table.component.ts":
/*!************************************************************************!*\
  !*** ./src/app/todo-component/tabs/data-table/data-table.component.ts ***!
  \************************************************************************/
/*! exports provided: DataTableComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTableComponent", function() { return DataTableComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../todo-data-service/fish.service */ "./src/app/todo-data-service/fish.service.ts");
// // NOUVELLE VERSION, QUI NE MARCHE PAS (fishService par reconnu !)

// import { Component, OnInit, ViewChild  } from '@angular/core';
// import { HttpClient } from '@angular/common/http';
// import { FishService } from '../../../todo-data-service/fish.service';
// // import { AgGridNg2 } from 'ag-grid-angular';
// import {GridOptions} from "ag-grid-community";
// @Component({
//   selector: 'app-data-table',
//   templateUrl: './data-table.component.html',
//   styleUrls: ['./data-table.component.scss']
// })
// export class DataTableComponent implements OnInit {
//   private gridOptions: GridOptions;
//   private http: HttpClient;
//   private fishService: FishService;
//   // @ViewChild('agGrid') agGrid: AgGridNg2;
//   title = 'my Filter Grid !';
//   agGrid: any;
//   rowData: any;
//   constructor() {
//     // this.http = HttpClient,
//     this.fishService;
//     this.gridOptions = <GridOptions>{};
//     this.gridOptions.columnDefs = [
//     // columnDefs = [
//     {
//       headerName: 'Id Fishing',
//       field: 'id_fishing',
//       width: 200,
//     },
//     {
//       headerName: 'Value Landing',
//       field: 'value_landing',
//       width: 200
//     },
//     {
//       headerName: 'Value Quota',
//       field: 'value_quota',
//       width: 200
//     },
//     {
//       headerName: 'Date',
//       field: 'date',
//       width: 200
//     },
//     {
//       headerName: 'Name Specie',
//       field: 'name_specie',
//       width: 150
//     },
//     {
//       headerName: 'Super Zone',
//       field: 'super_zone',
//       width: 200
//     },
//     {
//       headerName: 'Zone',
//       field: 'zone',
//       width: 200
//     }
//   ];
//   //   this.gridOptions.rowData = [
//   //     {id: 5, value: 10},
//   //     {id: 10, value: 15},
//   //     {id: 15, value: 20}
//   //   ]
//   }
//   // constructor(
//   //   private http: HttpClient,
//   //   private fishService: FishService
//   //   ) { }
//   ngOnInit() {
//       this.rowData = this.fishService.getAllFishings();
//   }
//   getSelectedRows() {
//     const selectedNodes = this.agGrid.api.getSelectedNodes();
//     const selectedData = selectedNodes.map( node => node.data );
//     // console.log(selectedData);
//     const selectedDataStringPresentation = selectedData.map( node => node.id_fishing + ' - ' + node.value_landing + ' - ' + node.value_quota
//     + ' - ' + node.date + ' - ' + node.name_specie + ' - ' + node.super_zone + ' - ' + node.zone).join('; ');
//     alert(`Selected nodes: ${selectedDataStringPresentation}`);
//   }
// }
// ********************************************
// VERSION PRÉCÉDENTE (AVANT MISE À JOUR)



var DataTableComponent = /** @class */ (function () {
    function DataTableComponent(http, fishService) {
        this.http = http;
        this.fishService = fishService;
        this.title = 'my Filter Grid !';
        this.columnDefs = [
            {
                headerName: 'Id Fishing',
                field: 'id_fishing',
                width: 100,
            },
            {
                headerName: 'Value Landing',
                field: 'value_landing',
                width: 130
            },
            {
                headerName: 'Value Quota',
                field: 'value_quota',
                width: 130
            },
            {
                headerName: 'Date',
                field: 'date',
                width: 100
            },
            {
                headerName: 'Name Specie',
                field: 'name_specie',
                width: 150
            },
            {
                headerName: 'Super Zone',
                field: 'super_zone',
                width: 200
            },
            {
                headerName: 'Zone',
                field: 'zone',
                width: 200
            }
        ];
    }
    DataTableComponent.prototype.ngOnInit = function () {
        this.rowData = this.fishService.getAllFishings();
        // this.gridOptions.defaultColDef.filter=true // marche pas
    };
    // getSelectedRows() {
    //   const selectedNodes = this.fishService.getAllFishings();
    //   // const selectedNodes = this.agGrid.api.getSelectedNodes();
    //   const selectedData = selectedNodes.map(node => node.data);
    //   // console.log(selectedData);
    //   const selectedDataStringPresentation = selectedData.map( node => node.id_fishing + ' - ' + node.value_landing + ' - ' + node.value_quota
    //   + ' - ' + node.date + ' - ' + node.name_specie + ' - ' + node.super_zone + ' - ' + node.zone).join('; ');
    //   alert(`Selected nodes: ${selectedDataStringPresentation}`);
    // }
    DataTableComponent.prototype.getSelectedRows = function () {
        var _this = this;
        this.fishService.getAllFishings()
            .subscribe(function (fishing$) {
            _this.fishing$ = fishing$;
            console.log(fishing$[0].name_specie);
            var selectedDataStringPresentation = fishing$[0].id_fishing + ' - ' + fishing$[0].value_landing + ' - ' + fishing$[0].value_quota
                + ' - ' + fishing$[0].date + ' - ' + fishing$[0].name_specie + ' - ' + fishing$[0].super_zone + ' - ' + fishing$[0].zone;
            alert("Selected nodes: " + selectedDataStringPresentation);
        });
    };
    DataTableComponent.ctorParameters = function () { return [
        { type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"] },
        { type: _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_3__["FishService"] }
    ]; };
    DataTableComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-data-table',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./data-table.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/data-table/data-table.component.html")).default,
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./data-table.component.scss */ "./src/app/todo-component/tabs/data-table/data-table.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"],
            _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_3__["FishService"]])
    ], DataTableComponent);
    return DataTableComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/dates-chart/dates-chart.component.scss":
/*!****************************************************************************!*\
  !*** ./src/app/todo-component/tabs/dates-chart/dates-chart.component.scss ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvZGF0ZXMtY2hhcnQvZGF0ZXMtY2hhcnQuY29tcG9uZW50LnNjc3MifQ== */");

/***/ }),

/***/ "./src/app/todo-component/tabs/dates-chart/dates-chart.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/todo-component/tabs/dates-chart/dates-chart.component.ts ***!
  \**************************************************************************/
/*! exports provided: DatesChartComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DatesChartComponent", function() { return DatesChartComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-data-service/fish.service */ "./src/app/todo-data-service/fish.service.ts");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _todo_class_linechart_options__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../todo-class/linechart-options */ "./src/app/todo-class/linechart-options.ts");




// import Chart from 'chart.js';

// Depending on whether rollup is used, moment needs to be imported differently.
// Since Moment.js doesn't have a default export, we normally need to import using the `* as`
// syntax. However, rollup creates a synthetic default module and we thus need to import it using
// the `default as` syntax.

var moment = moment__WEBPACK_IMPORTED_MODULE_5__;

var DatesChartComponent = /** @class */ (function () {
    function DatesChartComponent(router, fb, fishService, linechartOptionsService) {
        this.router = router;
        this.fb = fb;
        this.fishService = fishService;
        this.linechartOptionsService = linechartOptionsService;
        // MODÈLE DU GRAPHIQUE :
        this.type = 'line';
        this.options = this.linechartOptionsService.options;
    }
    DatesChartComponent.prototype.ngOnInit = function () {
        var _this = this;
        console.log(this.nameSpecieSelect);
        console.log(this.zoneSelect);
        console.log(this.dateSelect);
        console.log(this.date2BeginSelect);
        console.log(this.date2EndSelect);
        //  indiquer ici la route vers l'api choisie : getAllFishingDates()...
        this.fishService.getAllFishingDates()
            .subscribe(function (fishes) {
            var fishing = fishes; // variable créée pour récupérer la liste des données à afficher sur le graphique
            // this.fishes = fishes; // marche pas ici (voir dans le 'search-form' pour utilisation)
            // console.log('resultat API :' + fishes[0].value_landing, ' ' + fishes[0].zone);
            var dateBegin = _this.date2BeginSelect;
            // const dateBegin = fishes[0].date;
            // PARSAGE DE DATES (DE DÉBUT ET FIN) : de 'string' au format ('YYYY-MM-DD') vers date Moment.js au format
            // 'fr' et 'LL' (ex : 7 Février 2018) :
            var parsedDateBegin = moment(dateBegin, 'YYYY-MM-DD').locale('fr').format('LL');
            var dateEnd = _this.date2EndSelect;
            // const dateEnd = fishes[fishes.length - 1].date;
            var parsedDateEnd = moment(dateEnd, 'YYYY-MM-DD').locale('fr').format('LL');
            // this.type = 'line';
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (' + parsedDateBegin + ' - ' + parsedDateEnd + ') - ' // date2BeginDatas
                                + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (' + parsedDateBegin + ' - ' + parsedDateEnd + ') - '
                                + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        data: [],
                        borderColor: '#2d9ab7' // #36A2EB
                    }
                ]
            };
            // this.data.datasets[0].label.push(nameSpDatas);
            // this.data.datasets[1].label.push(nameSpDatas);
            // this.data.datasets[0].label.push(zonedatas);
            // this.data.datasets[1].label.push(zonedatas);
            if (fishing.length > 0) {
                // if (Object(fishes).length > 0) {
                for (var i = 0; i < fishing.length; i++) {
                    // for (let i = 0; i < Object(fishes).length; i++) {
                    //  for (let i = 0; i < Object.keys(fishs).length; i++) {
                    var landingPushDatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingPushDatas);
                    var quotaPushDatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotaPushDatas);
                    var date2pushdatas = fishes[i].date; // values : date;
                    _this.data.labels.push(date2pushdatas);
                    // const datepushdatas = fishes[i].date;  // values : date;
                    // this.data.labels.push(datepushdatas);
                } // fin de boucle 'for'
            }
            else {
                alert('Pas de donnée...');
            }
            // *****************************************************************
            // test légende détachée : (pb: listes à puces...)
            // const linefishes = document.getElementById('linefishes');
            // const myLineFishes = new Chart(linefishes, {
            //    type: 'line',
            //    options: this.options,
            //    data: this.data,
            // });
            // document.getElementById('legend').innerHTML = myLineFishes.generateLegend();
            // *****************************************************************
        });
    }; // fin de boucle : ngOnInit,
    // *********************************************************************************** //
    // *****      REQUETES POUR LES OPTIONS 'SELECT' DU FORMULAIRE DE RECHERCHE      ***** //
    // *********************************************************************************** //
    DatesChartComponent.prototype.onSelect = function () {
    }; // FIN DE MÉTHODE 'ONSELECT'
    DatesChartComponent.prototype.onReset = function () {
        // ACTUALISATION DU GRAPHIQUE DE BASE :
        var _this = this;
        this.fishService.getAllFishingDates() //  indiquer ici la route vers l'api choisie : getSomeFishes()...
            .subscribe(function (fishes) {
            var fishing = fishes;
            var dateBegin = fishes[0].date;
            var parsedDateBegin = moment(dateBegin, 'YYYY-MM-DD').locale('fr').format('LL');
            var dateEnd = fishes[fishes.length - 1].date;
            var parsedDateEnd = moment(dateEnd, 'YYYY-MM-DD').locale('fr').format('LL');
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (' + parsedDateBegin + ' - ' + parsedDateEnd + ') - '
                                + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (' + parsedDateBegin + ' - ' + parsedDateEnd + ') - '
                                + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        data: [],
                        borderColor: '#2d9ab7' // #36A2EB
                    }
                ]
            };
            if (fishing.length > 0) {
                for (var i = 0; i < fishing.length; i++) {
                    var landingPushDatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingPushDatas);
                    var quotaPushDatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotaPushDatas);
                    var date2pushdatas = fishes[i].date; // values : date;
                    _this.data.labels.push(date2pushdatas);
                }
            }
            else {
                alert('Pas de donnée...');
            }
        });
    };
    DatesChartComponent.prototype.onDatesLabels = function () {
        var _this = this;
        var nameSpSelect$ = this.nameSpecieSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        console.log(nameSpSelect$);
        var nameSpDatas = nameSpSelect$; // values: name_specie (du template)
        var labelNameSp = nameSpSelect$;
        console.log(labelNameSp);
        if (nameSpDatas === '' || nameSpDatas === 'Toutes Espèces') {
            nameSpDatas = 'vide';
            labelNameSp = 'Toutes Espèces';
        }
        var zoneSelect$ = this.zoneSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        var zoneDatas = zoneSelect$;
        var labelZone = zoneSelect$;
        // gestion d'une 'ZONE' VIDE :
        if (zoneDatas === '' || zoneDatas === 'Toutes Zones') {
            zoneDatas = 'vide';
            labelZone = 'Toutes Zones';
        }
        // const dateSelect$ = this.dateSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        var date2BeginSelect$ = this.date2BeginSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        var date2EndSelect$ = this.date2EndSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const date$ = this.searchForm.get('date2').value;
        // GESTION D'ERREUR POUR UN CHAMPS DE DATES INVALIDE (VIDE OU PARTIELLEMENT VIDE) :
        if (date2BeginSelect$ === null) {
            alert('Date de début vide : Veuillez choisir une plage de dates...');
            return;
        }
        else if (date2EndSelect$ === null) {
            alert('Date de fin vide : Veuillez choisir une plage de dates...');
            return;
        }
        // PARSAGE DE LA DATE (UTC) POUR LES LABELS DU GRAPHIQUE : / PROBLÈME DANS LE FORMATAGE : (VERSION QUI MARCHE)
        var options = { year: 'numeric', month: 'long', day: 'numeric' }; // ex : jour de semaine en lettres : weekday: 'long'
        // DATE DE DÉBUT :
        // date transformée  à partir du format UTC
        var dateBeginLabelToString = new Intl.DateTimeFormat('fr-FR', options).format(date2BeginSelect$); // parsage (exemple sans 'Moment') = 7 février 2018
        var dateBeginToString = date2BeginSelect$.getFullYear() + '-' + Number(date2BeginSelect$.getMonth() + 1) + '-' + date2BeginSelect$.getDate(); // parsage (exemple) = 2018-2-7
        // DATE DE FIN :
        // date transformée  à partir du format UTC
        var dateEndLabelToString = new Intl.DateTimeFormat('fr-FR', options).format(date2EndSelect$); // parsage (exemple) = 7 février 2018
        var dateEndToString = date2EndSelect$.getFullYear() + '-' + Number(date2EndSelect$.getMonth() + 1) + '-' + date2EndSelect$.getDate(); // parsage (exemple) = 2018-2-7
        // ************************************************************************************** //
        // *******************  AFFICHAGE DU GRAPHIQUE SELON LA REQUETE SOUHAITÉE  ************** //
        // ************************************************************************************** //
        //  indiquer ici la route vers l'api choisie : getAllDates()...
        this.fishService.getAllDates(nameSpDatas, zoneDatas, dateBeginToString, dateEndToString)
            .subscribe(function (fishes) {
            var fishing = fishes;
            // MÉTHODE RÉCUPÉRANT 'ESPÈCE' ET 'ZONE' SÉLECTIONNÉE
            //  console.log('resultat API :' + fishes[0].value_landing, ' ' + fishes[0].zone);
            _this.type = 'line';
            _this.options = _this.linechartOptionsService.options;
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (' + dateBeginLabelToString + ' - ' + dateEndLabelToString
                                + ') - ' + labelNameSp, ' ' + labelZone],
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (' + dateBeginLabelToString + ' - ' + dateEndLabelToString
                                + ') - ' + labelNameSp, ' ' + labelZone],
                        data: [],
                        borderColor: '#2d9ab7' // #36A2EB
                    }
                ]
            };
            if (fishing.length > 0) {
                for (var i = 0; i < fishing.length; i++) {
                    var landingPushDatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingPushDatas);
                    var quotaPushDatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotaPushDatas);
                    var date2pushdatas = fishes[i].date; // values : date;
                    _this.data.labels.push(date2pushdatas);
                }
            }
            else {
                alert('Pas de donnée...');
            }
        });
    }; // fin de méthode onDatesLabels()
    DatesChartComponent.ctorParameters = function () { return [
        { type: _angular_router__WEBPACK_IMPORTED_MODULE_2__["Router"] },
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"] },
        { type: _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"] },
        { type: _todo_class_linechart_options__WEBPACK_IMPORTED_MODULE_6__["LinechartOptionsService"] }
    ]; };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], DatesChartComponent.prototype, "nameSpecieSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], DatesChartComponent.prototype, "zoneSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], DatesChartComponent.prototype, "dateSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], DatesChartComponent.prototype, "date2BeginSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], DatesChartComponent.prototype, "date2EndSelect", void 0);
    DatesChartComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-dates-chart',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./dates-chart.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/dates-chart/dates-chart.component.html")).default,
            providers: [
                _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"]
            ],
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./dates-chart.component.scss */ "./src/app/todo-component/tabs/dates-chart/dates-chart.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_2__["Router"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"],
            _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"],
            _todo_class_linechart_options__WEBPACK_IMPORTED_MODULE_6__["LinechartOptionsService"]])
    ], DatesChartComponent);
    return DatesChartComponent;
}()); // fin de classe 'ChartChangeComponent'



/***/ }),

/***/ "./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.scss":
/*!**********************************************************************************************!*\
  !*** ./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.scss ***!
  \**********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/*\n  Copyright Google LLC. All Rights Reserved.\n  Use of this source code is governed by an MIT-style license that\n  can be found in the LICENSE file at http://angular.io/license\n  */\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3lhbm5pc2NvZGUvRGVza3RvcC91a3F1b3RhLmRhdGF2aXouZmlzaC16LWV4cG9ydC1tb2RhbGVzLWZvcm0tY29ubmV4aW9uLWIvc3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2Zvcm0tYWRtaW4tY29ubmV4aW9uL2Zvcm0tYWRtaW4tY29ubmV4aW9uLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2Zvcm0tYWRtaW4tY29ubmV4aW9uL2Zvcm0tYWRtaW4tY29ubmV4aW9uLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlFOzs7O0dDQUMiLCJmaWxlIjoic3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2Zvcm0tYWRtaW4tY29ubmV4aW9uL2Zvcm0tYWRtaW4tY29ubmV4aW9uLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLmNyb3NzLXZhbGlkYXRpb24tZXJyb3IgaW5wdXQge1xuLy8gICAgIGJvcmRlci1sZWZ0OiA1cHggc29saWQgcmVkO1xuLy8gfVxuXG4gIC8qXG4gIENvcHlyaWdodCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0XG4gIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHA6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgKi8iLCIvKlxuICBDb3B5cmlnaHQgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdFxuICBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICovXG4iXX0= */");

/***/ }),

/***/ "./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.ts":
/*!********************************************************************************************!*\
  !*** ./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.ts ***!
  \********************************************************************************************/
/*! exports provided: FormAdminConnexionComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormAdminConnexionComponent", function() { return FormAdminConnexionComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../todo-data-service/users.service */ "./src/app/todo-data-service/users.service.ts");
/* harmony import */ var _todo_directive_login_checked_directive__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-directive/login-checked-directive */ "./src/app/todo-directive/login-checked-directive.ts");




 // directive qui check le login, mail de l'admin
var FormAdminConnexionComponent = /** @class */ (function () {
    function FormAdminConnexionComponent(fb, usersService) {
        this.fb = fb;
        this.usersService = usersService;
        this.showAdminDatas = false; // Affichage div avec *ngIf (privilégié à la méthode du DOM)
        this.user = {
            id_user: '',
            user_firstname: '',
            user_lastname: '',
            login: '',
            password: '',
            mail: ''
        };
        // user = { id_user: 1, user_firstname: 'John', user_lastname: 'The Fisherman', login: 'Primus', password: '1234', mail: 'johnthefish@gmail.com'};
        // adminForm: FormGroup;
        this.adminForm = new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormGroup"]({
            login: new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"](this.user.login, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required,
            ]),
            mail: new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"](this.user.mail, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required,
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].email
            ]),
        }, {
            validators: _todo_directive_login_checked_directive__WEBPACK_IMPORTED_MODULE_4__["loginUnCheckedValidator"]
        }); // vérifier si l'administrateur (login, mail) est celui déclaré dans le formulaire
    }
    FormAdminConnexionComponent.prototype.ngOnInit = function () {
        // test mail :
        // const control = new FormControl('bad*@* — ', Validators.email);
        // console.log(control.errors); // {email: true}
        // this.adminForm = new FormGroup (
        // {
        //   login: new FormControl(this.user.login, [
        //     Validators.required,
        //     // Validators.minLength(4),
        //   ]),
        //   mail: new FormControl(this.user.mail, [
        //     Validators.required,
        //     Validators.email
        //   ]),
        // }, { validators: loginUnCheckedValidator }); // vérifier si l'administrateur (login, mail) est celui déclaré dans le formulaire
    };
    Object.defineProperty(FormAdminConnexionComponent.prototype, "adminLogin", {
        get: function () { return this.adminForm.get('login'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormAdminConnexionComponent.prototype, "adminMail", {
        get: function () { return this.adminForm.get('mail'); },
        enumerable: true,
        configurable: true
    });
    FormAdminConnexionComponent.prototype.onAdminSubmit = function () {
        var _this = this;
        var loginValue = this.adminForm.get('login').value;
        console.log(loginValue);
        var mailValue = this.adminForm.get('mail').value;
        console.log(mailValue);
        this.usersService.getLogin(loginValue, mailValue)
            .subscribe(function (admin$) {
            _this.admin$ = admin$;
            if (admin$[0] !== undefined) {
                var loginCheck = admin$[0].login.toString();
                console.log(loginCheck);
                var mailCheck = admin$[0].mail.toString();
                console.log(mailCheck);
                // VERSION 1: directive "loginUnCheckedValidator" utilisée (pour test)
                if (loginCheck === loginValue && mailCheck === mailValue) {
                    // VERSION 2: si la directive "loginUnCheckedValidator" n'est pas utilisée (plus sécu ?? le bouton n'apparait pas valide dès que les infos admin sont bonnes, et non seulement après validation...)
                    // if(loginValue === "Kasparov29" && loginCheck === loginValue && mailValue === "quotauk@gmail.com" && mailCheck === mailValue) {
                    console.log("login répertorié dans la BDD : connexion possible !");
                    _this.showAdminDatas = true;
                    // si le login existe, la <div> des données "masquées" est révélée :
                    // document.getElementById("form-submitted2").hidden = false;
                    return;
                }
                else {
                    _this.showAdminDatas = false;
                    alert("Votre login ou votre mail (admin) semble incorrect...");
                    return;
                }
            }
            else { // utile ?? (à retester si nécessaire)
                console.log("Aucun login répertorié : connexion impossible !");
                _this.showAdminDatas = false;
                // méthode (DOM) pour enlever le composant (plus que le masquer):
                // let formsubmitted2 = document.getElementById("form-submitted2");
                // formsubmitted2.parentNode.removeChild(formsubmitted2);
                // si le login n'est pas reconnu dans la BDD, la <div> reste masquée :
                // document.getElementById("form-submitted2").hidden = true;
                alert("Admin non répertorié...");
                return;
            }
        });
    };
    FormAdminConnexionComponent.prototype.onAdminDeconnect = function () {
        this.showAdminDatas = false;
        this.adminForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
    };
    FormAdminConnexionComponent.ctorParameters = function () { return [
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"] },
        { type: _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_3__["UsersService"] }
    ]; };
    FormAdminConnexionComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-form-admin-connexion',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./form-admin-connexion.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.html")).default,
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./form-admin-connexion.component.scss */ "./src/app/todo-component/tabs/form-admin-connexion/form-admin-connexion.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"],
            _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_3__["UsersService"]])
    ], FormAdminConnexionComponent);
    return FormAdminConnexionComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/form-connexion/form-connexion.component.scss":
/*!**********************************************************************************!*\
  !*** ./src/app/todo-component/tabs/form-connexion/form-connexion.component.scss ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/*\n  Copyright Google LLC. All Rights Reserved.\n  Use of this source code is governed by an MIT-style license that\n  can be found in the LICENSE file at http://angular.io/license\n  */\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3lhbm5pc2NvZGUvRGVza3RvcC91a3F1b3RhLmRhdGF2aXouZmlzaC16LWV4cG9ydC1tb2RhbGVzLWZvcm0tY29ubmV4aW9uLWIvc3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2Zvcm0tY29ubmV4aW9uL2Zvcm0tY29ubmV4aW9uLmNvbXBvbmVudC5zY3NzIiwic3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2Zvcm0tY29ubmV4aW9uL2Zvcm0tY29ubmV4aW9uLmNvbXBvbmVudC5zY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVFFOzs7O0dDSkMiLCJmaWxlIjoic3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL2Zvcm0tY29ubmV4aW9uL2Zvcm0tY29ubmV4aW9uLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLmNyb3NzLXZhbGlkYXRpb24tZXJyb3IgaW5wdXQge1xuLy8gICBib3JkZXItbGVmdDogNXB4IHNvbGlkICNiNzFjMWM7IC8vIGNvdWxldXIgZGUgYm9yZHVyZSBkZXMgY2hhbXBzXG4vLyB9XG5cbi8vIC5jcm9zcy12YWxpZGF0aW9uLWVycm9yIGlucHV0IHtcbi8vICAgICBib3JkZXItbGVmdDogNXB4IHNvbGlkIHJlZDtcbi8vIH1cblxuICAvKlxuICBDb3B5cmlnaHQgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdFxuICBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICovIiwiLypcbiAgQ29weXJpZ2h0IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXRcbiAgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cDovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAqL1xuIl19 */");

/***/ }),

/***/ "./src/app/todo-component/tabs/form-connexion/form-connexion.component.ts":
/*!********************************************************************************!*\
  !*** ./src/app/todo-component/tabs/form-connexion/form-connexion.component.ts ***!
  \********************************************************************************/
/*! exports provided: FormConnexionComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormConnexionComponent", function() { return FormConnexionComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../todo-data-service/users.service */ "./src/app/todo-data-service/users.service.ts");




var FormConnexionComponent = /** @class */ (function () {
    function FormConnexionComponent(fb, usersService) {
        this.fb = fb;
        this.usersService = usersService;
        // export class ReactiveFormConnexionComponent implements OnInit { /* ANCIENNE VERSION */
        // showConnexionForm = true;
        this.showDatas = false; // Affichage div avec *ngIf (privilégié à la méthode du DOM)
        // user = { id_user: 1, user_firstname: 'John', user_lastname: 'The Fisherman', login: 'Primus', password: '1234', mail: 'johnthefish@gmail.com'};
        this.user = {
            id_user: '',
            user_firstname: '',
            user_lastname: '',
            login: '',
            password: '',
            mail: ''
        };
        // userForm: FormGroup;
        this.userForm = new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormGroup"]({
            login: new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"](this.user.login, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required,
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].minLength(4),
            ]),
            mail: new _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormControl"](this.user.mail, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].required,
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["Validators"].email
            ])
        });
    }
    Object.defineProperty(FormConnexionComponent.prototype, "login", {
        // pas utilisé (pour l'instant ??):
        // ngOnInit(): void {
        // }
        get: function () { return this.userForm.get('login'); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FormConnexionComponent.prototype, "mail", {
        get: function () { return this.userForm.get('mail'); },
        enumerable: true,
        configurable: true
    });
    FormConnexionComponent.prototype.onSubmit = function () {
        var _this = this;
        var loginValue = this.userForm.get('login').value;
        console.log(loginValue);
        var mailValue = this.userForm.get('mail').value;
        console.log(mailValue);
        this.usersService.getLogin(loginValue, mailValue)
            .subscribe(function (user$) {
            _this.user$ = user$;
            if (user$[0] !== undefined) {
                var loginCheck = user$[0].login.toString();
                console.log(loginCheck);
                var mailCheck = user$[0].mail.toString();
                console.log(mailCheck);
                if (loginCheck === loginValue && mailCheck === mailValue) {
                    console.log("login répertorié dans la BDD : connexion possible !");
                    _this.showDatas = true;
                    // this.showConnexionForm = false;
                    // si le login existe, la <div> des données "masquées" est révélée :
                    // document.getElementById("form-submitted").hidden = false;
                    return;
                }
                else {
                    _this.showDatas = false;
                    alert("Votre login ou votre mail semble incorrect. Veuillez nous contacter par mail pour vous inscrire ou obtenir vos informations de connexion...");
                    _this.userForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
                    return;
                }
            }
            else { // utile ?? (à retester si nécessaire)
                // this.showConnexionForm = true;
                _this.showDatas = false;
                _this.userForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
                // Autre méthode (DOM) pour enlever le composant (plus que le masquer):
                // let formsubmitted = document.getElementById("form-submitted");
                // formsubmitted.parentNode.removeChild(formsubmitted);
                // si le login n'est pas reconnu dans la BDD, la <div> reste masquée :
                // document.getElementById("form-submitted").hidden = true;
                alert("Login ou mail non répertorié...");
                return;
            }
        });
    };
    FormConnexionComponent.prototype.onUserDeconnect = function () {
        this.showDatas = false;
        this.userForm.reset({ login: '', mail: '' }); // le contenu des champs est bien effacé
    };
    FormConnexionComponent.ctorParameters = function () { return [
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"] },
        { type: _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_3__["UsersService"] }
    ]; };
    FormConnexionComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-form-connexion',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./form-connexion.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/form-connexion/form-connexion.component.html")).default,
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./form-connexion.component.scss */ "./src/app/todo-component/tabs/form-connexion/form-connexion.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormBuilder"],
            _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_3__["UsersService"]])
    ], FormConnexionComponent);
    return FormConnexionComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/members-list/members-list.component.scss":
/*!******************************************************************************!*\
  !*** ./src/app/todo-component/tabs/members-list/members-list.component.scss ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvbWVtYmVycy1saXN0L21lbWJlcnMtbGlzdC5jb21wb25lbnQuc2NzcyJ9 */");

/***/ }),

/***/ "./src/app/todo-component/tabs/members-list/members-list.component.ts":
/*!****************************************************************************!*\
  !*** ./src/app/todo-component/tabs/members-list/members-list.component.ts ***!
  \****************************************************************************/
/*! exports provided: MembersListComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MembersListComponent", function() { return MembersListComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-data-service/users.service */ "./src/app/todo-data-service/users.service.ts");








var MembersListComponent = /** @class */ (function () {
    // AUTRE FORME POSSIBLE (A VOIR)
    // modificationForm = this.fb.group({ // groupe de champs de recherches pour la validation d'un formulaire 'réactif'
    //   //  firstName: ['', Validators.required], // exemple de champs simple, à la différence des tableaux de données utilisés ici :
    //   login: ['', Validators.required]
    // });
    // get login() {
    //   return this.inscriptionForm.get('login') as FormControl;
    // }
    function MembersListComponent(fb, usersService) {
        this.fb = fb;
        this.usersService = usersService;
        // CHAMPS AUTO-COMPLETE (MÉTHODE AVEC OBSERVABLE QUI MARCHE AVEC DES DONNÉES RÉELLES = objets en input)
        this.user = {
            id_user: '',
            user_firstname: '',
            user_lastname: '',
            login: '',
            password: '',
            mail: ''
        };
        this.data$ = []; // nécessaire sous ce type (any - les autres ne semblent pas marcher...) (tableau vide) car utilisé pour filtrer les données saisies (_loginFilter, _mailFilter)
        /* MÉTHODE POUR AVOIR UN FORMULAIRE  :*/
        // modificationForm: FormGroup;
        this.modificationForm = new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormGroup"]({
            id_user: new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"](this.user.id_user, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required
            ]),
            login: new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"](this.user.login, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required
            ]),
            mail: new _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormControl"](this.user.mail, [
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].required,
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["Validators"].email
            ])
        });
        // this.usersService.getUsers()
        //   .subscribe(data$ => {  // indiquer ici la route vers l'api choisie
        //   this.data$ = data$;
        // });
    }
    Object.defineProperty(MembersListComponent.prototype, "login", {
        // ECOUTE DES VALEURS DU CHAMPS LOGIN
        get: function () {
            return this.modificationForm.get('login');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MembersListComponent.prototype, "mail", {
        // ECOUTE DES VALEURS DU CHAMPS MAIL
        get: function () {
            return this.modificationForm.get('mail');
        },
        enumerable: true,
        configurable: true
    });
    // https://angular.io/guide/template-syntax : rendre la liste plus efficace... UTILE (A RETESTER) ??
    MembersListComponent.prototype.trackByItems = function (user) { return user.id_user; };
    // RECHERCHE LES CHAMPS CORRESPONDANTS AU MOYEN DES MÉTHODES DU FICHIER 'users.service.ts' (= TABLEAU DE STRINGS)
    MembersListComponent.prototype._loginFilter = function (value) {
        var _this = this;
        console.log(value);
        // méthode appelée pour l'update de la liste des logins du champs auto-complete : (ÉVITE APPELS DES DONNÉES DANS LE CONSTRUCTEUR...)
        this.usersService.getUsers()
            .subscribe(function (data$) {
            _this.data$ = data$;
            console.log(_this.data$);
            return _this.data$;
        });
        console.log(this.data$);
        // const logins = this.users;
        var datas = this.data$;
        console.log(datas);
        var userData = [];
        for (var i = 0; i < datas.length; i++) {
            userData.push(datas[i].login);
        }
        console.log(userData);
        var filterValue = value.toLowerCase();
        return userData.filter(function (user) { return user
            .toLowerCase()
            .includes(filterValue); });
    };
    MembersListComponent.prototype._mailFilter = function (value) {
        var _this = this;
        // méthode appelée pour l'update de la liste des logins du champs auto-complete :
        this.usersService.getUsers()
            .subscribe(function (data$) {
            _this.data$ = data$;
            console.log(_this.data$);
            return _this.data$;
        });
        console.log(this.data$);
        var datas = this.data$;
        console.log(datas);
        var mailData = [];
        for (var i = 0; i < datas.length; i++) {
            mailData.push(datas[i].mail);
        }
        console.log(mailData);
        var filterValue = value.toLowerCase();
        return mailData.filter(function (user) { return user
            .toLowerCase()
            .includes(filterValue); });
    };
    // onSubmit() {
    //   // TODO: Use EventEmitter with form value
    //   console.log('VALUE NAME_SPECIE \'ON SUBMIT _\' DANS UN CHAMPS DE FORMULAIRE : ' + this.inscriptionForm.value.login);
    // }
    // APPEL DES DONNÉES GÉNÉRALES SUR LES UTILISATEURS:
    // private getUsers(): any {
    //   this.usersService.getUsers()
    //     .subscribe(datas => (this.datas = datas));
    // }
    // APPEL DES DONNÉES GÉNÉRALES SUR LES UTILISATEURS:
    MembersListComponent.prototype.getUsers = function () {
        var _this = this;
        this.usersService.getUsers()
            .subscribe(function (user$) { return (_this.user$ = user$); });
    };
    MembersListComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.getUsers();
        // ÉCOUTER LES CHANGEMENTS DANS LES DONNÉES TAPÉES DANS LE CHAMPS (= STRING):
        this.loginFilteredOptions = this.login.valueChanges
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["startWith"])(''), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["map"])(function (value) { return _this._loginFilter(value); }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["debounceTime"])(300) // --> (en test) applique un "timeout" qui permet la mise à jour de la liste des champs si l'on passe de l'un à l'autre
        );
        this.mailFilteredOptions = this.mail.valueChanges
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["startWith"])(''), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["map"])(function (value) { return _this._mailFilter(value); }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__["debounceTime"])(300));
    };
    // DELETE (AVEC LISTE D'ÉLÉMENTS) - tests
    //   delete(login: string): void {
    //     console.log(login);
    //     // this.users = this.users.filter(u => u !== login); // marche pas
    //     // console.log(this.users);
    //     this.usersService
    //       .deleteUser3(login)
    //       .subscribe();
    //   }
    // // DELETE (AVEC BOUTON) :
    MembersListComponent.prototype.onDelete2 = function (user) {
        this.user$ = this.user$.filter(function (u) { return u !== user; });
        this.usersService
            .deleteUser2(user)
            .subscribe();
    };
    // NECESSAIRE POUR L'UPDATE:
    MembersListComponent.prototype.onEdit = function (user) {
        // si getUsers() = utilisé -> timeout semble nécessaire :
        // setTimeout(() => {
        //   this.getUsers();
        //   console.log('timeout !');
        //   // this.editUser = user;
        // }, 15000);  // 2000 = 2 secondes de délai avant le chargement
        this.editUser = user;
    };
    MembersListComponent.prototype.onUpdate = function () {
        var _this = this;
        this.getUsers();
        if (this.editUser) {
            this.usersService
                .updateUser(this.editUser) // editUser: User (type)
                .subscribe(function (user) {
                var ix = user ? _this.user$.findIndex(function (u) { return u.id_user === user.id_user; }) : -1;
                if (ix > -1) {
                    _this.user$[ix] = user;
                }
            });
            // réinitialisation du membre édité:
            this.editUser = undefined;
        }
    };
    MembersListComponent.ctorParameters = function () { return [
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"] },
        { type: _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__["UsersService"] }
    ]; };
    MembersListComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-members-list',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./members-list.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/members-list/members-list.component.html")).default,
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./members-list.component.scss */ "./src/app/todo-component/tabs/members-list/members-list.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"],
            _todo_data_service_users_service__WEBPACK_IMPORTED_MODULE_4__["UsersService"]])
    ], MembersListComponent);
    return MembersListComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/search-form/search-form.component.scss":
/*!****************************************************************************!*\
  !*** ./src/app/todo-component/tabs/search-form/search-form.component.scss ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvc2VhcmNoLWZvcm0vc2VhcmNoLWZvcm0uY29tcG9uZW50LnNjc3MifQ== */");

/***/ }),

/***/ "./src/app/todo-component/tabs/search-form/search-form.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/todo-component/tabs/search-form/search-form.component.ts ***!
  \**************************************************************************/
/*! exports provided: SearchFormComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchFormComponent", function() { return SearchFormComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-data-service/fish.service */ "./src/app/todo-data-service/fish.service.ts");
/* harmony import */ var _todo_class_linechart_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../todo-class/linechart-options */ "./src/app/todo-class/linechart-options.ts");






var SearchFormComponent = /** @class */ (function () {
    function SearchFormComponent(router, fb, fishService, linechartOptionsService) {
        this.router = router;
        this.fb = fb;
        this.fishService = fishService;
        this.linechartOptionsService = linechartOptionsService;
        // ************ METHODE 1 : ******************
        //  On définit ici la valeur des champs (avant l'INIT):
        this.searchForm = this.fb.group({
            nameSp: this.fb.array([
                this.fb.control('Toutes Espèces')
                //  this.fb.control('', Validators.required),
            ]),
            superZ: this.fb.array([
                this.fb.control('')
            ]),
            zone: this.fb.array([
                this.fb.control('Toutes Zones')
            ]),
            date: this.fb.array([
                this.fb.control('')
            ]),
            date2: [{ begin: new Date(2018, 1, 7), end: new Date() }],
        });
    }
    Object.defineProperty(SearchFormComponent.prototype, "nameSp", {
        // ************
        get: function () {
            this.currentnameSp = this.searchForm.get('nameSp').value[0];
            // console.log(this.searchForm.value.nameSp[0]); // autre écriture possible
            // TEST : export du composant enfant > parent
            // let nameSpEmit = this.searchForm.value.nameSp; 
            // this.initSpecieEvent.emit(nameSpEmit[0]);
            return this.searchForm.get('nameSp');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFormComponent.prototype, "zone", {
        get: function () {
            this.currentZone = this.searchForm.get('zone').value[0];
            return this.searchForm.get('zone');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFormComponent.prototype, "date", {
        get: function () {
            this.currentDate = this.searchForm.get('date').value;
            return this.searchForm.get('date');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchFormComponent.prototype, "date2", {
        get: function () {
            this.currentDate2Begin = this.searchForm.get('date2').value.begin;
            this.currentDate2End = this.searchForm.get('date2').value.end;
            return this.searchForm.get('date2');
        },
        enumerable: true,
        configurable: true
    });
    SearchFormComponent.prototype.ngOnInit = function () {
        var _this = this;
        //  On définit ici la valeur des champs (à l'INIT):
        this.fishService.getDate()
            .subscribe(function (fishing$) {
            _this.fishing$ = fishing$;
            console.log(fishing$[0].date);
            var lastDate = fishing$[0].date;
            _this.searchForm = _this.fb.group({
                nameSp: _this.fb.array([
                    _this.fb.control('Toutes Espèces')
                    //  this.fb.control('', Validators.required),
                ]),
                superZ: _this.fb.array([
                    _this.fb.control('')
                ]),
                zone: _this.fb.array([
                    _this.fb.control('Toutes Zones')
                ]),
                date: _this.fb.array([
                    _this.fb.control(lastDate)
                ]),
                date2: [{ begin: new Date(2018, 1, 7), end: new Date() }],
            });
        });
        // console.log(this.currentnameSp);
        // console.log(this.currentZone);
        // console.log(this.currentDate);
        // console.log(this.currentDate2Begin);
        // console.log(this.currentDate2End);
        // indiquer ici la route vers l'api choisie : getSomeFishes()...
        this.fishService.getFishes()
            .subscribe(function (nameSp$) {
            _this.nameSp$ = nameSp$;
            // console.log(this.nameSp$[0].name_specie);
            _this.nameSp$.unshift({
                id_fishing: 0,
                value_landing: 0,
                value_quota: 0,
                date: null,
                name_specie: 'Toutes Espèces',
                super_zone: 'string',
                zone: 'string',
                z_coord: null,
                sz_coord: null
            });
        });
        this.fishService.getZone()
            .subscribe(function (zone$) {
            _this.zone$ = zone$; // LISTE DES ÉLEMENTS DU CHAMPS 'SELECT'
            _this.zone$.unshift({
                id_fishing: 0,
                value_landing: 0,
                value_quota: 0,
                date: null,
                name_specie: 'string',
                super_zone: 'string',
                zone: 'Toutes Zones',
                z_coord: null,
                sz_coord: null
            });
        });
        this.fishService.getDate()
            .subscribe(function (date$) {
            _this.date$ = date$;
        });
        this.fishService.getDate2()
            .subscribe(function (date2$) {
            _this.date2$ = date2$;
        });
    }; // FIN DE MÉTHODE 'ONINIT()'
    SearchFormComponent.prototype.onSelect = function () {
        // console.log(this.currentnameSp);
        // console.log(this.currentZone);
        // console.log(this.currentDate);
        // console.log(this.currentDate2Begin);
        // console.log(this.currentDate2End);
        var _this = this;
        // LORSQU'ON CHOISIT UN NOM D'ESPÈCE, ON A LA ZONE ET LA PLAGE DE DATES (BEGIN & END) QUI S'ADAPTENT :
        var nameSpSelect$ = this.searchForm.get('nameSp').value;
        var nameSpdatas = nameSpSelect$[0]; // value: name_specie (du template)
        if (nameSpdatas === '' || nameSpdatas === 'Toutes Espèces') {
            nameSpdatas = 'vide';
        }
        // LORSQU'ON CHOISIT UNE ZONE, ON A LE NOM D'ESPÈCE ET LA PLAGE DE DATES (BEGIN & END) QUI S'ADAPTENT :
        var zoneSelect$ = this.searchForm.get('zone').value;
        var zonedatas = zoneSelect$[0]; // values: name_specie (du template)
        if (zonedatas === '' || zonedatas === 'Toutes Zones') {
            zonedatas = 'vide';
        }
        // LORSQU'ON CHOISIT UNE DATES SIMPLE, ON A LE NOM D'ESPÈCE ET LA ZONE QUI S'ADAPTENT : (A FINIR)
        var dateSelect$ = this.searchForm.get('date').value; // date = valeur donnée par le formulaire (html > searchForm)
        // ATTENTION : pour un champs 'select', date = string >> PAS DE TRANSFORMATION
        var dateSelectToString = dateSelect$;
        // ATTENTION : pour un 'Datepicker', date = format 'UTC' >> TRANSFORMATION EN STRING : 'YYYY-MM-DD'
        // let dateSelectToString = dateSelect$.getFullYear() + '-' + Number(dateSelect$.getMonth() + 1) + '-' + dateSelect$.getDate();
        // console.log(dateSelectToString); // MODE D'AFFICHAGE À REVOIR
        // GESTION D'ERREUR POUR UN CHAMPS DE DATES INVALIDE (VIDE OU PARTIELLEMENT VIDE) :
        if (dateSelectToString[0] === null || dateSelectToString === 'Dernière Dates') {
            // console.log(dateSelectToString);
            dateSelectToString = 'vide';
            alert('Veuillez choisir une date simple...');
            return;
        }
        // **********************************************
        // LORSQU'ON CHOISIT UNE PLAGE DE DATES (BEGIN & END), ON A LE NOM D'ESPÈCE ET LA ZONE QUI S'ADAPTENT : (A FINIR)
        var date2Select$ = this.searchForm.get('date2').value; // date2 = valeur donnée par le formulaire (html > searchForm)
        // GESTION D'ERREUR POUR UN CHAMPS DE DATES INVALIDE (VIDE OU PARTIELLEMENT VIDE) :
        if (date2Select$ === null) {
            alert('Veuillez choisir une plage de dates...');
            return;
        }
        var date2BeginDatas = date2Select$.begin.getFullYear() + '-' + Number(date2Select$.begin.getMonth() + 1) + '-'
            + date2Select$.begin.getDate();
        if (date2BeginDatas === '' || date2BeginDatas === null || date2BeginDatas === 'Date de Début') {
            date2BeginDatas = 'vide';
        }
        var date2EndDatas = date2Select$.end.getFullYear() + '-' + Number(date2Select$.end.getMonth() + 1) + '-'
            + date2Select$.end.getDate();
        if (date2EndDatas === '' || date2EndDatas === null || date2EndDatas === 'Date de Fin') {
            date2EndDatas = 'vide';
        }
        this.fishService.getNewDate2(date2BeginDatas, date2EndDatas)
            .subscribe(function (date2$) {
            _this.date2$ = date2$; // LISTE DES ÉLEMENTS DU CHAMPS 'SELECT'
        });
        // METHODES CORRESPONDANTES :
        // au nom d'espèce sélectionné, les zones et dates correspondantes sont filtrées : (en test)
        this.fishService.getNewZoneForSingleDate(nameSpdatas, dateSelectToString)
            .subscribe(function (zone$) {
            _this.zone$ = zone$; // LISTE DES ÉLEMENTS DU CHAMPS 'SELECT'
            _this.zone$.unshift({
                id_fishing: 0,
                value_landing: 0,
                value_quota: 0,
                date: undefined,
                name_specie: 'string',
                super_zone: 'string',
                zone: 'Toutes Zones',
                z_coord: null,
                sz_coord: null
            });
        });
        // à la zone sélectionnée, les noms d'espèces et dates correspondantes sont filtrées : (en test)
        this.fishService.getNewNamespForSingleDate(zonedatas, dateSelectToString)
            .subscribe(function (nameSp$) {
            _this.nameSp$ = nameSp$; // LISTE DES ÉLEMENTS DU CHAMPS 'SELECT'
            _this.nameSp$.unshift({
                id_fishing: 0,
                value_landing: 0,
                value_quota: 0,
                date: null,
                name_specie: 'Toutes Espèces',
                super_zone: 'string',
                zone: 'string',
                z_coord: null,
                sz_coord: null
            });
        });
        // à la date sélectionnée, les noms d'espèces et dates correspondantes sont filtrées : (en test)
        this.fishService.getNewDateForSingleDate(nameSpdatas, zonedatas)
            .subscribe(function (date$) {
            _this.date$ = date$; // LISTE DES ÉLEMENTS DU CHAMPS 'SELECT'
        });
    }; // FIN DE ONSELECT()
    SearchFormComponent.prototype.onReset = function () {
        // console.log(this.currentnameSp);
        // console.log(this.currentZone);
        // console.log(this.currentDate);
        // console.log(this.currentDate2Begin);
        // console.log(this.currentDate2End);
        var _this = this;
        // *********************************************************************************** //
        //  ACTUALISATION DES REQUETES POUR LES OPTIONS 'SELECT' DU FORMULAIRE DE RECHERCHE     //
        // *********************************************************************************** //
        // indiquer ici la route vers l'api choisie : getFishes()...
        this.fishService.getFishes()
            .subscribe(function (nameSp$) {
            _this.nameSp$ = nameSp$;
            _this.nameSp$.unshift({
                id_fishing: 0,
                value_landing: 0,
                value_quota: 0,
                date: null,
                name_specie: 'Toutes Espèces',
                super_zone: 'string',
                zone: 'string',
                z_coord: null,
                sz_coord: null
            });
        });
        this.fishService.getSuperZone()
            .subscribe(function (superZone$) {
            _this.superZone$ = superZone$;
        });
        this.fishService.getZone()
            .subscribe(function (zone$) {
            _this.zone$ = zone$; // LISTE DES ÉLEMENTS DU CHAMPS 'SELECT'
            _this.zone$.unshift({
                id_fishing: 0,
                value_landing: 0,
                value_quota: 0,
                date: null,
                name_specie: 'string',
                super_zone: 'string',
                zone: 'Toutes Zones',
                z_coord: null,
                sz_coord: null
            });
        });
        this.fishService.getDate()
            .subscribe(function (date$) {
            _this.date$ = date$;
        });
        this.fishService.getDate2()
            .subscribe(function (date2$) {
            _this.date2$ = date2$;
        });
        // ACTUALISATION DU FORMULAIRE DE BASE :
        //  On redéfinit ici la valeur des champs (au RESET):
        this.fishService.getDate()
            .subscribe(function (fishing$) {
            _this.fishing$ = fishing$;
            var lastDate = fishing$[0].date;
            _this.searchForm = _this.fb.group({
                nameSp: _this.fb.array([
                    _this.fb.control('Toutes Espèces')
                    //  this.fb.control('', Validators.required),
                ]),
                superZ: _this.fb.array([
                    _this.fb.control('')
                ]),
                zone: _this.fb.array([
                    _this.fb.control('Toutes Zones')
                ]),
                date: _this.fb.array([
                    _this.fb.control(lastDate)
                ]),
                date2: [{ begin: new Date(2018, 1, 7), end: new Date() }],
            });
        });
    }; // FIN DE MÉTHODE 'ONRESET()'
    SearchFormComponent.ctorParameters = function () { return [
        { type: _angular_router__WEBPACK_IMPORTED_MODULE_2__["Router"] },
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"] },
        { type: _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"] },
        { type: _todo_class_linechart_options__WEBPACK_IMPORTED_MODULE_5__["LinechartOptionsService"] }
    ]; };
    SearchFormComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-search-form',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./search-form.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/search-form/search-form.component.html")).default,
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./search-form.component.scss */ "./src/app/todo-component/tabs/search-form/search-form.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_2__["Router"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"],
            _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"],
            _todo_class_linechart_options__WEBPACK_IMPORTED_MODULE_5__["LinechartOptionsService"]])
    ], SearchFormComponent);
    return SearchFormComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/species-chart/species-chart.component.scss":
/*!********************************************************************************!*\
  !*** ./src/app/todo-component/tabs/species-chart/species-chart.component.scss ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvc3BlY2llcy1jaGFydC9zcGVjaWVzLWNoYXJ0LmNvbXBvbmVudC5zY3NzIn0= */");

/***/ }),

/***/ "./src/app/todo-component/tabs/species-chart/species-chart.component.ts":
/*!******************************************************************************!*\
  !*** ./src/app/todo-component/tabs/species-chart/species-chart.component.ts ***!
  \******************************************************************************/
/*! exports provided: SpeciesChartComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpeciesChartComponent", function() { return SpeciesChartComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-data-service/fish.service */ "./src/app/todo-data-service/fish.service.ts");
/* harmony import */ var _todo_class_barchart_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../todo-class/barchart-options */ "./src/app/todo-class/barchart-options.ts");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_6__);







var moment = moment__WEBPACK_IMPORTED_MODULE_6__;
var SpeciesChartComponent = /** @class */ (function () {
    // searchForm: FormGroup;
    function SpeciesChartComponent(router, fb, fishService, barchartOptionsService) {
        this.router = router;
        this.fb = fb;
        this.fishService = fishService;
        this.barchartOptionsService = barchartOptionsService;
        // MODÈLE du graphique :
        this.type = 'bar';
        this.options = this.barchartOptionsService.options;
    }
    SpeciesChartComponent.prototype.ngOnInit = function () {
        var _this = this;
        console.log(this.nameSpecieSelect);
        console.log(this.zoneSelect);
        console.log(this.dateSelect);
        console.log(this.date2BeginSelect);
        console.log(this.date2EndSelect);
        this.fishService.getAllFishingSpecies()
            // this.fishService.getAllFishingSpecies(dateToString)
            .subscribe(function (fishes) {
            // PARSAGE DE LA DATE (DE STRING À STRING REFORMATÉE AU FORMAT FRANÇAIS)
            var date = fishes[0].date;
            var parsedDate = moment(date, 'YYYY-MM-DD').locale('fr').format('LL');
            console.log(parsedDate);
            // this.type = 'bar';
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Captures (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'], // fishes[0].date
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Quotas (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'], // fishes[0].date
                        data: [],
                        backgroundColor: 'rgba(45, 154, 185, 0.54)',
                        borderColor: '#2d9ab7'
                    }
                ]
            };
            if (Object(fishes).length > 0) {
                // alert('De nouvelles données sont arrivées...');
                for (var i = 0; i < Object(fishes).length; i++) {
                    //    for (let i = 0; i < Object.keys(fishes).length; i++) {
                    var landingdatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingdatas);
                    var quotadatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotadatas);
                    var speciesdatas = fishes[i].name_specie; // values : date;
                    _this.data.labels.push(speciesdatas);
                } // fin de boucle 'for'
            }
            else {
                alert('Pas de donnée...');
                // alert('Pas de nouvelle donnée pour aujourd\'hui...');
            }
        });
    };
    // *********************************************************************************** //
    // *****      REQUETES POUR LES OPTIONS 'SELECT' DU FORMULAIRE DE RECHERCHE      ***** //
    // *********************************************************************************** //
    SpeciesChartComponent.prototype.onSelect = function () {
        console.log(this.nameSpecieSelect);
        console.log(this.zoneSelect);
        console.log(this.dateSelect);
        console.log(this.date2BeginSelect);
        console.log(this.date2EndSelect);
    }; // FIN DE MÉTHODE 'ONSELECT'
    SpeciesChartComponent.prototype.onReset = function () {
        // ACTUALISATION DU GRAPHIQUE DE BASE :
        var _this = this;
        this.fishService.getAllFishingSpecies() //  indiquer ici la route vers l'api choisie : getSomeFishes()...
            // this.fishService.getAllFishingSpecies(dateToString) //  indiquer ici la route vers l'api choisie : getSomeFishes()...
            .subscribe(function (fishes) {
            //  this.fishes = fishes;
            //  console.log('resultat API :' + fishes[0].value_landing, ' ' + fishes[0].zone);
            // PARSAGE DE LA DATE (DE STRING À STRING REFORMATÉE AU FORMAT FRANÇAIS)
            var date = fishes[0].date;
            var parsedDate = moment(date, 'YYYY-MM-DD').locale('fr').format('LL');
            // console.log(parsedDate);
            // this.type = 'bar';
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Captures (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'], // fishes[0].date
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Quotas (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'], // fishes[0].date
                        data: [],
                        backgroundColor: 'rgba(45, 154, 185, 0.54)',
                        borderColor: '#2d9ab7'
                    }
                ]
            };
            // this.data.datasets[0].label.push(nameSpdatas);
            // this.data.datasets[1].label.push(nameSpdatas);
            // this.data.datasets[0].label.push(zonedatas);
            // this.data.datasets[1].label.push(zonedatas);
            if (Object(fishes).length > 0) {
                for (var i = 0; i < Object(fishes).length; i++) {
                    //  for (let i = 0; i < Object.keys(fishs).length; i++) {
                    var landingPushDatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingPushDatas);
                    var quotaPushDatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotaPushDatas);
                    var speciesdatas = fishes[i].name_specie; // values : date;
                    _this.data.labels.push(speciesdatas);
                } // fin de boucle 'for'
            }
            else {
                alert('Pas de donnée...');
                // alert('Pas de nouvelle donnée pour aujourd\'hui...');
            }
        });
    };
    SpeciesChartComponent.prototype.onSpeciesLabels = function () {
        var _this = this;
        console.log(this.nameSpecieSelect);
        console.log(this.zoneSelect);
        console.log(this.dateSelect);
        console.log(this.date2BeginSelect);
        console.log(this.date2EndSelect);
        // const superZSelect$ = this.searchForm.get('superZ').value;
        var nameSpSelect$ = this.nameSpecieSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const nameSpSelect$ = this.searchForm.get('nameSp').value;
        var nameSpdatas = nameSpSelect$; // values: name_specie (du template)
        var labelnameSp = nameSpdatas;
        if (nameSpdatas === '' || nameSpdatas === 'Toutes Espèces') {
            nameSpdatas = 'vide';
            labelnameSp = 'Toutes Espèces';
        }
        var zoneSelect$ = this.zoneSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const zoneSelect$ = this.searchForm.get('zone').value;
        // gestion d'une 'ZONE' VIDE :
        var zonedatas = zoneSelect$;
        var labelzone = zonedatas;
        if (zonedatas === '' || zonedatas === 'Toutes Zones') {
            zonedatas = 'vide';
            labelzone = 'Toutes Zones';
        }
        var dateSelect$ = this.dateSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const dateSelect$ = this.searchForm.get('date').value;
        // VARIABLE POUR UN SIMPLE CHAMPS SELECT : (date = 'string')
        var dateAString = dateSelect$.toString(); // cas d'un champs select date
        //  const dateLabelToString = date$;
        // POUR UNE DATE AU FORMAT GMT :
        // let dateToString = date$.getFullYear() + '-' + Number(date$.getMonth() + 1) + '-' + date$.getDate();
        // console.log(dateToString); // MODE D'AFFICHAGE À REVOIR
        // VARIABLE POUR UN MAT-OU SAT-DATEPICKER A DATE UNIQUE : (DATE AU FORMAT GMT)
        // const options = { year: 'numeric', month: 'long', day: 'numeric'}; // ex : jour de semaine en lettres : weekday: 'long'
        // console.log(new Intl.DateTimeFormat('fr-FR', options).format(date$)); // date transformée  à partir du format UTC
        // const dateLabelToString = new Intl.DateTimeFormat('fr-FR', options).format(date$); // cas d'un mat ou sat datepicker
        // GESTION ERREUR CHAMPS DATE 'NULL' :
        console.log(dateAString);
        if (dateAString === '' || dateAString === undefined) {
            // modification de l'UTC date pour les 'labels' du graphique :
            dateAString = 'vide';
            alert('Veuillez choisir une date...');
        }
        // /********************************** */
        this.fishService.getAllSpecies(nameSpdatas, zonedatas, dateAString)
            //    this.httpService.get('./api/AllSpeciesAtZone', {responseType: 'json'})
            .subscribe(function (fishes) {
            // GESTION D'ERREUR (CHAMPS DATE NON COMPLÉTÉ)
            // console.log(fishes[0]);
            var datedatas = fishes[0];
            // const datedatas = fishes[0].date;
            console.log(datedatas);
            if (datedatas === undefined) {
                console.log('datedatas :' + datedatas);
                alert('Veuillez choisir une date...');
                return;
            }
            // PARSAGE DE LA DATE (DE STRING À STRING REFORMATÉE AU FORMAT FRANÇAIS)
            var date = fishes[0].date;
            var parsedDate = moment(date, 'YYYY-MM-DD').locale('fr').format('LL');
            // console.log(parsedDate);
            // this.type = 'bar';
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (le ' + parsedDate + ') - ' + labelnameSp, ' ' + labelzone],
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (le ' + parsedDate + ') - ' + labelnameSp, ' ' + labelzone],
                        data: [],
                        backgroundColor: 'rgba(45, 154, 185, 0.54)',
                        borderColor: '#2d9ab7'
                    }
                ]
            };
            if (Object(fishes).length > 0) {
                for (var i = 0; i < Object(fishes).length; i++) {
                    //    for (let i = 0; i < Object.keys(fishes).length; i++) {
                    var landingdatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingdatas);
                    var quotadatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotadatas);
                    var speciesdatas = fishes[i].name_specie; // values : date;
                    _this.data.labels.push(speciesdatas);
                }
            }
            else {
                alert('Pas de donnée...');
            }
        });
    }; // fin boucle 'onSpeciesLabels'()'
    SpeciesChartComponent.ctorParameters = function () { return [
        { type: _angular_router__WEBPACK_IMPORTED_MODULE_2__["Router"] },
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"] },
        { type: _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"] },
        { type: _todo_class_barchart_options__WEBPACK_IMPORTED_MODULE_5__["BarchartOptionsService"] }
    ]; };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], SpeciesChartComponent.prototype, "nameSpecieSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], SpeciesChartComponent.prototype, "zoneSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], SpeciesChartComponent.prototype, "dateSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], SpeciesChartComponent.prototype, "date2BeginSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], SpeciesChartComponent.prototype, "date2EndSelect", void 0);
    SpeciesChartComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-species-chart',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./species-chart.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/species-chart/species-chart.component.html")).default,
            providers: [
                _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"]
            ],
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./species-chart.component.scss */ "./src/app/todo-component/tabs/species-chart/species-chart.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_2__["Router"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormBuilder"],
            _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"],
            _todo_class_barchart_options__WEBPACK_IMPORTED_MODULE_5__["BarchartOptionsService"]])
    ], SpeciesChartComponent);
    return SpeciesChartComponent;
}()); // fin de classe 'ChartChangeComponent'



/***/ }),

/***/ "./src/app/todo-component/tabs/tabs.component.scss":
/*!*********************************************************!*\
  !*** ./src/app/todo-component/tabs/tabs.component.scss ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("/*\n    .center {\n        display: block;\n        margin-left: auto;\n        margin-right: auto;\n        width: 95%;\n        height: 95%; \n    }\n*/\n/* Create two equal columns that floats next to each other */\n/*cf : w3schools columns */\n/* Responsive layout - when the screen is less than 600px wide, make the three columns stack on top of each other instead of next to each other */\n/* cf : https://www.w3schools.com/howto/howto_css_three_columns.asp  */\n/* Styles for tab labels */\n\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3lhbm5pc2NvZGUvRGVza3RvcC91a3F1b3RhLmRhdGF2aXouZmlzaC16LWV4cG9ydC1tb2RhbGVzLWZvcm0tY29ubmV4aW9uLWIvc3JjL2FwcC90b2RvLWNvbXBvbmVudC90YWJzL3RhYnMuY29tcG9uZW50LnNjc3MiLCJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvdGFicy5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0NRQztBRFdELDREQUFBO0FBQThELDBCQUFBO0FBUTlELGlKQUFBO0FBQW1KLHNFQUFBO0FBYW5KLDBCQUFBIiwiZmlsZSI6InNyYy9hcHAvdG9kby1jb21wb25lbnQvdGFicy90YWJzLmNvbXBvbmVudC5zY3NzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICAuY2VudGVyIHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XG4gICAgICAgIHdpZHRoOiA5NSU7XG4gICAgICAgIGhlaWdodDogOTUlOyBcbiAgICB9XG4qL1xuXG5cbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vLyAucm93IHtcbi8vICAgICBtYXJnaW46IGF1dG87XG4vLyAgICAgd2lkdGg6IDk1JTtcbi8vIH1cblxuLy8gU0kgQ0hPSVggREUgMiBHUkFQSElRVUVTIFBBUiBQQUdFIDpcbi8qIENyZWF0ZSB0d28gZXF1YWwgY29sdW1ucyB0aGF0IGZsb2F0cyBuZXh0IHRvIGVhY2ggb3RoZXIgKi8gLypjZiA6IHczc2Nob29scyBjb2x1bW5zICovXG4vLyAuY29sdW1uIHtcbi8vICAgICBmbG9hdDogbGVmdDtcbi8vICAgICB3aWR0aDogNTAlOyAgICAvKiB3aWR0aDogNTAlOyBwb3VyIDIgZ3JhcGhpcXVlcyAqL1xuLy8gICAgIGhlaWdodDogMzAwJTsgICAvKiBoZWlndGg6IDMwMCBweCBsb3JzcXVlIDIgZ3JhcGhpcXVlcyAqL1xuLy8gfVxuXG5cbi8qIFJlc3BvbnNpdmUgbGF5b3V0IC0gd2hlbiB0aGUgc2NyZWVuIGlzIGxlc3MgdGhhbiA2MDBweCB3aWRlLCBtYWtlIHRoZSB0aHJlZSBjb2x1bW5zIHN0YWNrIG9uIHRvcCBvZiBlYWNoIG90aGVyIGluc3RlYWQgb2YgbmV4dCB0byBlYWNoIG90aGVyICovIC8qIGNmIDogaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9ob3d0by9ob3d0b19jc3NfdGhyZWVfY29sdW1ucy5hc3AgICovXG5cblxuLy8gQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNjAwcHgpIHtcbi8vICAgICAuY29sdW1uIHtcbi8vICAgICAgICAgd2lkdGg6IDEwMCU7XG4vLyAgICAgfVxuLy8gfSBcblxuXG5cbi8vIFRFU1QgOiBNT0RJRklDQVRJT04gRFUgQ1NTIERFUyBUQUJTIDpcblxuLyogU3R5bGVzIGZvciB0YWIgbGFiZWxzICovXG4vLyAubWF0LXRhYi1sYWJlbCB7XG4vLyAgICAgbWluLXdpZHRoOiAyNXB4ICFpbXBvcnRhbnQ7XG4vLyAgICAgcGFkZGluZzogNXB4O1xuLy8gICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuLy8gICAgIGNvbG9yOiByZWQ7XG4vLyAgICAgZm9udC13ZWlnaHQ6IDcwMDtcbi8vIH1cblxuLy8gLyogU3R5bGVzIGZvciB0aGUgYWN0aXZlIHRhYiBsYWJlbCAqL1xuLy8gLm1hdC10YWItbGFiZWwgLm1hdC10YWItbGFiZWwtYWN0aXZlIHtcbi8vICAgICBtaW4td2lkdGg6IDI1cHggIWltcG9ydGFudDtcbi8vICAgICBwYWRkaW5nOiA1cHg7XG4vLyAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4vLyAgICAgY29sb3I6IHJlZDtcbi8vICAgICBmb250LXdlaWdodDogNzAwO1xuLy8gfVxuXG4vLyAvKiBTdHlsZXMgZm9yIHRoZSBpbmsgYmFyICovXG4vLyAubWF0LWluay1iYXIge1xuLy8gICAgIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xuLy8gfSIsIi8qXG4gICAgLmNlbnRlciB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xuICAgICAgICB3aWR0aDogOTUlO1xuICAgICAgICBoZWlnaHQ6IDk1JTsgXG4gICAgfVxuKi9cbi8qIENyZWF0ZSB0d28gZXF1YWwgY29sdW1ucyB0aGF0IGZsb2F0cyBuZXh0IHRvIGVhY2ggb3RoZXIgKi9cbi8qY2YgOiB3M3NjaG9vbHMgY29sdW1ucyAqL1xuLyogUmVzcG9uc2l2ZSBsYXlvdXQgLSB3aGVuIHRoZSBzY3JlZW4gaXMgbGVzcyB0aGFuIDYwMHB4IHdpZGUsIG1ha2UgdGhlIHRocmVlIGNvbHVtbnMgc3RhY2sgb24gdG9wIG9mIGVhY2ggb3RoZXIgaW5zdGVhZCBvZiBuZXh0IHRvIGVhY2ggb3RoZXIgKi9cbi8qIGNmIDogaHR0cHM6Ly93d3cudzNzY2hvb2xzLmNvbS9ob3d0by9ob3d0b19jc3NfdGhyZWVfY29sdW1ucy5hc3AgICovXG4vKiBTdHlsZXMgZm9yIHRhYiBsYWJlbHMgKi9cbiJdfQ== */");

/***/ }),

/***/ "./src/app/todo-component/tabs/tabs.component.ts":
/*!*******************************************************!*\
  !*** ./src/app/todo-component/tabs/tabs.component.ts ***!
  \*******************************************************/
/*! exports provided: TabsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabsComponent", function() { return TabsComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");


var TabsComponent = /** @class */ (function () {
    function TabsComponent() {
    }
    TabsComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-tabs',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./tabs.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/tabs.component.html")).default,
            encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None // ajout pour modif CSS des Tab (en test)
            ,
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./tabs.component.scss */ "./src/app/todo-component/tabs/tabs.component.scss")).default]
        })
    ], TabsComponent);
    return TabsComponent;
}());



/***/ }),

/***/ "./src/app/todo-component/tabs/zones-map/zones-map.component.scss":
/*!************************************************************************!*\
  !*** ./src/app/todo-component/tabs/zones-map/zones-map.component.scss ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL3RvZG8tY29tcG9uZW50L3RhYnMvem9uZXMtbWFwL3pvbmVzLW1hcC5jb21wb25lbnQuc2NzcyJ9 */");

/***/ }),

/***/ "./src/app/todo-component/tabs/zones-map/zones-map.component.ts":
/*!**********************************************************************!*\
  !*** ./src/app/todo-component/tabs/zones-map/zones-map.component.ts ***!
  \**********************************************************************/
/*! exports provided: ZonesMapComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZonesMapComponent", function() { return ZonesMapComponent; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! leaflet */ "./node_modules/leaflet/dist/leaflet-src.js");
/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
/* harmony import */ var _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../todo-data-service/fish.service */ "./src/app/todo-data-service/fish.service.ts");
/* harmony import */ var _todo_class_barchart_options__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../todo-class/barchart-options */ "./src/app/todo-class/barchart-options.ts");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_7__);



 // pour la route de 'api.js' ??


 // pour le formulaire de recherche

var moment = moment__WEBPACK_IMPORTED_MODULE_7__;
var ZonesMapComponent = /** @class */ (function () {
    function ZonesMapComponent(router, fb, fishService, barchartOptionsService) {
        this.router = router;
        this.fb = fb;
        this.fishService = fishService;
        this.barchartOptionsService = barchartOptionsService;
        // public date2$: Fish[];
        // begin: D | any;
        // end: D | null;
        // searchForm: FormGroup;
        this.map = null; // ajout perso
        this.map2 = null; // ajout perso
        this.layer = null; // ajout perso
        this.tileLayer = null;
        this.type = 'bar';
        this.options = this.barchartOptionsService.options;
    }
    // MODÈLE du graphique :
    // type = 'bar';
    ZonesMapComponent.prototype.ngOnInit = function () {
        var _this = this;
        console.log(this.nameSpecieSelect);
        console.log(this.zoneSelect);
        console.log(this.dateSelect);
        console.log(this.date2BeginSelect);
        console.log(this.date2EndSelect);
        this.fishService.getAllFishingZones() //  indiquer ici la route vers l'api choisie : getSomeFishes()...
            // this.fishService.getAllFishingZones(dateToString)
            .subscribe(function (fishes) {
            // PARSAGE DE LA DATE (DE STRING À STRING REFORMATÉE AU FORMAT FRANÇAIS)
            var date = fishes[0].date;
            var parsedDate = moment(date, 'YYYY-MM-DD').locale('fr').format('LL');
            // console.log(parsedDate);
            // this.type = 'bar';
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Captures (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Quotas (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        data: [],
                        backgroundColor: 'rgba(45, 154, 185, 0.54)',
                        borderColor: '#2d9ab7'
                    }
                ]
            };
            if (Object(fishes).length > 0) {
                for (var i = 0; i < Object(fishes).length; i++) {
                    //    for (let i = 0; i < Object.keys(fishes).length; i++) {
                    var landingdatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingdatas);
                    var quotadatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotadatas);
                    var zonesdatas = fishes[i].zone; // values : date;
                    _this.data.labels.push(zonesdatas);
                } // fin de boucle 'for'
                // alert('De nouvelles données sont arrivées...');
            }
            else {
                alert('Pas de donnée...');
                // alert('Pas de nouvelle donnée pour aujourd\'hui...');
            }
        });
    }; // fin de Méthode 'ngOnInit'
    // *********************************************************************************** //
    // *****      REQUETES POUR LES OPTIONS 'SELECT' DU FORMULAIRE DE RECHERCHE      ***** //
    // *********************************************************************************** //
    // dans le composant du formulaire
    // onSelect(): any {
    // } // FIN DE MÉTHODE 'ONSELECT'
    ZonesMapComponent.prototype.onReset = function () {
        var _this = this;
        if (this.onMapReady(this.map) != null) { // > MARCHE COMME ÇA, MAIS INTÉRESSANT ??
            // if (this.map != null) { // > NE MARCHE PLUS ?? AVANT : SINON INITIALISATION DOUBLE DE LA CARTE AU NOUVEAU 'SUBMIT'
            this.map.remove(); // > MARCHAIT PAS SEUL
            this.map = null; //  > MARCHAIT MIEUX
        }
        // *********************************************************************************** //
        // RESET DU GRAPHIQUE :
        // *********************************************************************************** //
        this.fishService.getAllFishingZones() //  indiquer ici la route vers l'api choisie : getSomeFishes()...
            // this.fishService.getAllFishingZones(dateToString) //  indiquer ici la route vers l'api choisie : getSomeFishes()...
            .subscribe(function (fishes) {
            //  this.fishes = fishes;
            //  console.log('resultat API :' + fishes[0].value_landing, ' ' + fishes[0].zone);
            // PARSAGE DE LA DATE (DE STRING À STRING REFORMATÉE AU FORMAT FRANÇAIS)
            var date = fishes[0].date;
            var parsedDate = moment(date, 'YYYY-MM-DD').locale('fr').format('LL');
            console.log(parsedDate);
            // this.type = 'bar';
            _this.data = {
                labels: [],
                datasets: [
                    {
                        label: ['Captures (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Captures (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'], // fishes[0].date
                        data: [],
                        backgroundColor: 'rgba(255, 68, 0, 0.49)',
                        borderColor: '#ff4500' // backgroundColor: '#FF6384'
                    },
                    {
                        label: ['Quotas (le ' + parsedDate + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'],
                        // label: ['Quotas (le ' + dateLabelToString + ') - ' + 'Toutes Espèces', ' ' + 'Toutes Zones'], // fishes[0].date
                        data: [],
                        backgroundColor: 'rgba(45, 154, 185, 0.54)',
                        borderColor: '#2d9ab7'
                    }
                ]
            };
            // this.data.datasets[0].label.push(nameSpdatas);
            // this.data.datasets[1].label.push(nameSpdatas);
            // this.data.datasets[0].label.push(zonedatas);
            // this.data.datasets[1].label.push(zonedatas);
            if (Object(fishes).length > 0) {
                for (var i = 0; i < Object(fishes).length; i++) {
                    //  for (let i = 0; i < Object.keys(fishs).length; i++) {
                    var landingPushDatas = fishes[i].value_landing; // values: value_landing
                    _this.data.datasets[0].data.push(landingPushDatas);
                    var quotaPushDatas = fishes[i].value_quota; // values: value_quota
                    _this.data.datasets[1].data.push(quotaPushDatas);
                    var zonesdatas = fishes[i].zone; // values : zone;
                    _this.data.labels.push(zonesdatas);
                } // fin de boucle 'for'
            }
            else {
                alert('Pas de donnée...');
                // alert('Pas de nouvelle donnée pour aujourd\'hui...');
            }
        });
    };
    ZonesMapComponent.prototype.onZonesLabels = function () {
        var _this = this;
        console.log(this.nameSpecieSelect);
        console.log(this.zoneSelect);
        console.log(this.dateSelect);
        console.log(this.date2BeginSelect);
        console.log(this.date2EndSelect);
        console.log('onZonesLabels() : ');
        console.log(this.map);
        // if (this.map != null) {   //  || this.initMap()
        //   this.map = null;
        // }
        // console.log(this.map);
        // IMPORTANT POUR L'AFFICHAGE DES TILES DANS LA MODALE :
        if (this.map == null) {
            this.map = this.readyMap;
            console.log(this.map);
            console.log(this.readyMap);
        }
        console.log(this.map);
        setTimeout(function () {
            _this.map.invalidateSize(true);
            console.log('test ! readyMap onClick !');
            console.log(_this.map);
            var map = _this.map;
            console.log(map);
        }, 2000); // 2000 = 2 secondes de délai avant le chargement de la carte
        var zoneSelect$ = this.zoneSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const zoneSelect$ = this.searchForm.get('zone').value;
        // gestion d'une 'ZONE' VIDE :
        var zonedatas = zoneSelect$;
        var labelzone = zonedatas;
        if (zonedatas === '' || zonedatas === 'Toutes Zones') {
            zonedatas = 'vide';
            labelzone = 'Toutes Zones';
        }
        var nameSpSelect$ = this.nameSpecieSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const nameSpSelect$ = this.searchForm.get('nameSp').value;
        var nameSpdatas = nameSpSelect$; // values: name_specie (du template)
        var labelnameSp = nameSpdatas;
        if (nameSpdatas === '' || nameSpdatas === 'Toutes Espèces') {
            nameSpdatas = 'vide';
            labelnameSp = 'Toutes Espèces';
        }
        var dateSelect$ = this.dateSelect; // import du composant 'parent' ('modales.component') > enfant ('dates-chart)
        // const dateSelect$ = this.searchForm.get('date').value;
        // console.log(this.searchForm.get('date').value);
        // VARIABLE POUR UN SIMPLE CHAMPS SELECT : (date = 'string')
        var dateAString = dateSelect$.toString(); // cas d'un champs select date
        // GESTION ERREUR CHAMPS DATE 'NULL' :
        console.log(dateAString);
        if (dateAString === '' || dateAString === undefined) {
            // modification de l'UTC date pour les 'labels' du graphique :
            dateAString = 'vide';
            alert('Veuillez choisir une date...');
        }
        // /********************************** */
        // *********************************************************************************** //
        // AFFICHAGE DE LA CARTE (AVEC DES DONNÉES SÉLECTIONNÉES):
        // *********************************************************************************** //
        this.fishService.getAllZones(nameSpdatas, zonedatas, dateAString)
            //    this.httpService.get('./api/AllSpeciesAtZone', {responseType: 'json'})
            .subscribe(function (fishes) {
            // GESTION D'ERREUR (RESULTAT DE L'API = 'undefined', signifiant 'vide'):
            // console.log(fishes[0].date);
            var datedatas = fishes[0];
            // const datedatas = fishes[0].date;
            console.log(datedatas);
            if (datedatas === undefined) {
                console.log('datedatas :' + datedatas);
                alert('Veuillez choisir une date...');
                return;
            }
            if (nameSpdatas === 'vide') {
                nameSpdatas = 'Toutes Espèces';
            }
            // PARSAGE DE LA DATE (DE STRING À STRING REFORMATÉE AU FORMAT FRANÇAIS) - ex : 30 Janvier 2020
            var date = fishes[0].date;
            // console.log(date);
            var parsedDate = moment(date, 'YYYY-MM-DD').locale('fr').format('LL');
            // console.log(parsedDate);
            // ****************************************************************************************
            // ***** Déclaration de la carte avec les coordonnées du centre et le niveau de zoom ****
            // ****************************************************************************************
            // *************** IMPORTANT : ****************
            // semble nécessaire car la carte est déjà initialisée avant, mais doit être recréée avec les nouvelles données
            if (_this.map != null) {
                _this.map.remove();
            }
            // **********************************************
            // LAYER DES SOUS-ZONES MARITIMES (MARCHE) :
            // LAYER AQUARELLE (MARCHE)
            var stamenWatercolorMap = leaflet__WEBPACK_IMPORTED_MODULE_2__["tileLayer"]('http://tile.stamen.com/watercolor/{z}/{x}/{y}.jpg', {
                attribution: '<div><p>Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/ copyright">OpenStreetMap</a> contributors</p></div>',
                minZoom: 2,
                maxZoom: 7,
            }); // zoom : 2 > 10 à la base
            // **********
            // LAYER DE NOMS DE MERS ET OCEANS :
            var oceanMapRef = leaflet__WEBPACK_IMPORTED_MODULE_2__["tileLayer"]('https://services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}.pbf', {
                attribution: '<div><p>Sources: Esri, GEBCO, NOAA, National Geographic, Garmin, HERE, Geonames.org, and other contributor</p></div>',
                minZoom: 2,
                maxZoom: 7,
            });
            console.log(_this.map);
            // #### marche pas comme ça avec ngx-leaflet
            _this.map = leaflet__WEBPACK_IMPORTED_MODULE_2__["map"]('myfrugalmap', { layers: [stamenWatercolorMap, oceanMapRef] })
                .setView([48.24, -4.4833], 3); // setView : London lat & long / 4 = niveau de zoom à l'affichage
            var myfrugalmap = _this.map;
            // console.log('myfrugalmap :');
            // console.log(myfrugalmap);
            // *****************************
            // ***** TOOLTIPS (INFOS BULLES S'AFFICHANT SUR LA CARTE (ICI :UNE SEULE EN MODE STICKY) ********************
            var labelPopupOptions = {
                opacity: 1,
                sticky: true,
                interactive: true
            };
            // *****************************
            fishes.forEach(function (z_coord) {
                // console.log(z_coord);
                // console.log(z_coord.zone);
                // console.log(z_coord.value_landing);
                // console.log(z_coord.z_coord);
                // console.log(Array.from(z_coord.z_coord));
                if (z_coord.name_specie === undefined || z_coord.name_specie === null || z_coord.name_specie === '') {
                    z_coord.name_specie = 'Toutes Espèces';
                }
                var polygonColor = 'green';
                // console.log(polygonColor);
                if (Object(fishes).length > 0) {
                    if (z_coord.value_quota - z_coord.value_landing >= 0) { // si le quota n'est pas atteint
                        polygonColor = 'blue';
                        // console.log(polygonColor);
                        // **** CONSTRUCTION DES POLYGONES AVEC LE PARAMÈTRE DE COORDONNÉES DE LA BDD :
                        var layer = leaflet__WEBPACK_IMPORTED_MODULE_2__["polygon"](z_coord.z_coord, { color: polygonColor, dashArray: '15, 10', weight: 0.3 })
                            .addTo(myfrugalmap); // dasharray = pointillés (longueur du trait,longueur du vide)
                        layer.bindTooltip('<i>' + z_coord.name_specie + '</i><br>' + '<b>' + z_coord.zone + '</b>' + '<br>Value landing : '
                            + z_coord.value_landing + '<br>Value Quota : ' + z_coord.value_quota, labelPopupOptions);
                        layer.addTo(myfrugalmap);
                        // layer.openTooltip();
                    }
                    else if (z_coord.value_quota - z_coord.value_landing <= 0) { // si le quota est dépassé
                        polygonColor = 'red';
                        // console.log(polygonColor);
                        var layer = leaflet__WEBPACK_IMPORTED_MODULE_2__["polygon"](z_coord.z_coord, { color: polygonColor, dashArray: '15, 10', weight: 0.5 })
                            .addTo(myfrugalmap); // color: 'red' //dasharray
                        layer.bindTooltip('<i>' + z_coord.name_specie + '</i><br>' + '<b>' + z_coord.zone + '</b>' + '<br>Value landing : '
                            + z_coord.value_landing + '<br>Value Quota : ' + z_coord.value_quota, labelPopupOptions); // OPTION : , {permanent: true}
                        layer.addTo(myfrugalmap);
                        // layer.openTooltip();
                    }
                }
                else {
                    alert('Pas de donnée...');
                    // alert('Pas de nouvelle donnée pour aujourd\'hui...');
                }
            }); // fin de forEach()
            // ************** LEGENDE TEST : (marche !)
            // cf : https://stackoverflow.com/questions/49096159/how-to-add-legend-to-leaflet-map-written-by-angular-and-ngx-leaflet
            // console.log(fishes);
            var v1 = fishes[0].value_landing;
            // const v1 = this.min;
            var v3 = fishes[0].value_quota;
            // const v3 = this.max;
            var v2 = Math.round(v3 - v1);
            // const v2 = this.min + Math.round((this.max - this.min ) / 2);
            var legend = new (leaflet__WEBPACK_IMPORTED_MODULE_2__["Control"].extend({
                options: { position: 'bottomleft' }
            }));
            legend.onAdd = function () {
                // MA LÉGENDE :
                var div = leaflet__WEBPACK_IMPORTED_MODULE_2__["DomUtil"].create('div', 'legend');
                var labels = [
                    'Quotas respectés - <b>écarts >= à 0 (en tonnes)</b>',
                    'Quotas dépassés - <b>écarts < 0 (en tonnes)</b>',
                ];
                var grades = ['#0000ff', '#ff0000']; // 'blue', 'red'
                div.innerHTML = '<div style="background: grey; opacity: 0.8; color: black; margin-bottom: 12vh;"><div style="text-align: center;">'
                    + '<b>Légende</b></div><br />'
                    + '<div>Date : <b>' + parsedDate + '</b></div>' //  avant : fishes[0].date
                    + '<div>Nom d\'espèce : <b>' + nameSpdatas + '</b></div><br />' // fishes[0].name_specie
                    + '<i style="background:' + grades[0] + '"> &nbsp; &nbsp; &nbsp;</i> &nbsp; &nbsp;' + labels[0]
                    + '<br />' // grades[1]
                    + '<i style="background:' + grades[1] + '"> &nbsp; &nbsp; &nbsp;</i> &nbsp; &nbsp;' + labels[1]
                    + '<br /></div>'; // grades[1]
                return div;
            };
            legend.addTo(myfrugalmap);
        }); // fin de méthode getAllZones()
    }; // fin onZonesLabels()
    // ****************************
    // FONCTION NÉCESSAIRE à l'initialisation de la carte, pour faire marcher l'affichage de toutes les 'Tiles'
    // (tuiles) lors du déclenchement de la Modale (fonction 'onClick')
    ZonesMapComponent.prototype.onMapReady = function (map) {
        this.readyMap = map;
    };
    ZonesMapComponent.ctorParameters = function () { return [
        { type: _angular_router__WEBPACK_IMPORTED_MODULE_3__["Router"] },
        { type: _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormBuilder"] },
        { type: _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"] },
        { type: _todo_class_barchart_options__WEBPACK_IMPORTED_MODULE_5__["BarchartOptionsService"] }
    ]; };
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], ZonesMapComponent.prototype, "nameSpecieSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", String)
    ], ZonesMapComponent.prototype, "zoneSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], ZonesMapComponent.prototype, "dateSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], ZonesMapComponent.prototype, "date2BeginSelect", void 0);
    tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:type", Date)
    ], ZonesMapComponent.prototype, "date2EndSelect", void 0);
    ZonesMapComponent = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-zones-map',
            template: tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! raw-loader!./zones-map.component.html */ "./node_modules/raw-loader/dist/cjs.js!./src/app/todo-component/tabs/zones-map/zones-map.component.html")).default,
            providers: [
                _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"] // NÉCESSAIRE ?? > revoir les routes ?? : déjà dans 'app.module.ts'
            ],
            styles: [tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"](__webpack_require__(/*! ./zones-map.component.scss */ "./src/app/todo-component/tabs/zones-map/zones-map.component.scss")).default]
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_3__["Router"],
            _angular_forms__WEBPACK_IMPORTED_MODULE_6__["FormBuilder"],
            _todo_data_service_fish_service__WEBPACK_IMPORTED_MODULE_4__["FishService"],
            _todo_class_barchart_options__WEBPACK_IMPORTED_MODULE_5__["BarchartOptionsService"]])
    ], ZonesMapComponent);
    return ZonesMapComponent;
}());



/***/ }),

/***/ "./src/app/todo-data-service/config.service.ts":
/*!*****************************************************!*\
  !*** ./src/app/todo-data-service/config.service.ts ***!
  \*****************************************************/
/*! exports provided: ConfigService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConfigService", function() { return ConfigService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");





var ConfigService = /** @class */ (function () {
    function ConfigService(http) {
        this.http = http;
        this.configUrl = 'assets/config.json';
    }
    ConfigService.prototype.getConfig = function () {
        return this.http.get(this.configUrl)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["retry"])(3), // retry a failed request up to 3 times
        Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])(this.handleError) // then handle the error
        );
    };
    ConfigService.prototype.getConfig_1 = function () {
        return this.http.get(this.configUrl);
    };
    ConfigService.prototype.getConfig_2 = function () {
        // now returns an Observable of Config
        return this.http.get(this.configUrl);
    };
    ConfigService.prototype.getConfig_3 = function () {
        return this.http.get(this.configUrl)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])(this.handleError));
    };
    ConfigService.prototype.getConfigResponse = function () {
        return this.http.get(this.configUrl, { observe: 'response' });
    };
    ConfigService.prototype.handleError = function (error) {
        if (error.error instanceof ErrorEvent) {
            // A client-side or network error occurred. Handle it accordingly.
            console.error('An error occurred:', error.error.message);
        }
        else {
            // The backend returned an unsuccessful response code.
            // The response body may contain clues as to what went wrong,
            console.error("Backend returned code " + error.status + ", " +
                ("body was: " + error.error));
        }
        // return an observable with a user-facing error message
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__["throwError"])('Something bad happened; please try again later.');
    };
    ;
    ConfigService.prototype.makeIntentionalError = function () {
        return this.http.get('not/a/real/url')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__["catchError"])(this.handleError));
    };
    ConfigService.ctorParameters = function () { return [
        { type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"] }
    ]; };
    ConfigService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"]])
    ], ConfigService);
    return ConfigService;
}());

/*
Copyright Google LLC. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
*/ 


/***/ }),

/***/ "./src/app/todo-data-service/fish.service.ts":
/*!***************************************************!*\
  !*** ./src/app/todo-data-service/fish.service.ts ***!
  \***************************************************/
/*! exports provided: FishService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FishService", function() { return FishService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../todo-class/fish */ "./src/app/todo-class/fish.ts");





/*
export interface Fish {
  name_specie: string;
  super_zone: string;
  date: Date;
}
*/
var FishService = /** @class */ (function () {
    function FishService(http) {
        this.http = http;
    }
    // **************************************************************************************************************** //
    // REQUETE GÉNÉRIQUE (POUR UN TABLEAU DE BASE DANS LA METHODE 'ONINIT' - CF : LES DIFFÉRENTS 'CHART.COMPONENT') //
    // **************************************************************************************************************** //
    FishService.prototype.getAllFishings = function () {
        return this.http.get('http://localhost:3000/api/AllFishings')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__["Fish"].fromJson(jsonItem); }); }));
        //  .map(res => JSON.stringify(res));
    };
    // *********************************************************************************** //
    // *****       APPELS À L'API POUR LES CHAMPS 'SELECT' DU FORMULAIRE DE RECHERCHE      ***** //
    // *********************************************************************************** //
    FishService.prototype.getFishes = function () {
        return this.http.get('http://localhost:3000/api/NameSpecie')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__["Fish"].fromJson(jsonItem); }); }));
    };
    FishService.prototype.getSuperZone = function () {
        return this.http.get('http://localhost:3000/api/SuperZone')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__["Fish"].fromJson(jsonItem); }); }));
    };
    FishService.prototype.getZone = function () {
        return this.http.get('http://localhost:3000/api/Zone')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__["Fish"].fromJson(jsonItem); }); }));
    };
    // appel à l'API pour une date simple :
    FishService.prototype.getDate = function () {
        return this.http.get('http://localhost:3000/api/Date')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__["Fish"].fromJson(jsonItem); }); }));
    };
    // appel à l'API pour une plage de dates :
    FishService.prototype.getDate2 = function () {
        return this.http.get('http://localhost:3000/api/Date')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_fish__WEBPACK_IMPORTED_MODULE_4__["Fish"].fromJson(jsonItem); }); }));
    };
    // ************************************************************************************************* //
    // MÉTHODES POUR METTRE A JOUR LES CHAMPS 'SELECT' (AVEC UNE DATE SIMPLE) DU FORMULAIRE DE RECHERCHE //
    // ************************************************************************************************* //
    // getNewNameSp(name_specie: string, date2: string): Observable<Fish[]> {
    //   return this.http.get<Fish[]>('http://localhost:3000/api/newnamesp/' + name_specie + '&' + date2);
    // }
    FishService.prototype.getNewZoneForSingleDate = function (name_specie, date) {
        return this.http.get('http://localhost:3000/api/newZoneForSingleDate/' + name_specie + '&' + date);
    };
    FishService.prototype.getNewNamespForSingleDate = function (zone, date) {
        return this.http.get('http://localhost:3000/api/newNameSpForSingleDate/' + zone + '&' + date);
    };
    FishService.prototype.getNewDateForSingleDate = function (name_specie, zone) {
        return this.http.get('http://localhost:3000/api/newDateForSingleDate/' + name_specie + '&' + zone);
    };
    // ************************************************************************************************* //
    // *****       MÉTHODES POUR METTRE A JOUR LES CHAMPS 'SELECT' (AVEC PLAGE DE DATE) DU FORMULAIRE DE RECHERCHE      ***** //
    // ************************************************************************************************* //
    // getNewNameSp(name_specie: string, date2: string): Observable<Fish[]> {
    //   return this.http.get<Fish[]>('http://localhost:3000/api/newnamesp/' + name_specie + '&' + date2);
    // }
    FishService.prototype.getNewZone = function (name_specie, date2Begin, date2End) {
        return this.http.get('http://localhost:3000/api/newZone/' + name_specie + '&' + date2Begin + '&' + date2End);
    };
    FishService.prototype.getNewNameSp = function (zone, date2Begin, date2End) {
        return this.http.get('http://localhost:3000/api/newNameSp/' + zone + '&' + date2Begin + '&' + date2End);
    };
    FishService.prototype.getNewDate2 = function (date2Begin, date2End) {
        return this.http.get('http://localhost:3000/api/newDate2/' + date2Begin + '&' + date2End);
    };
    // **************************************************************************************************************** //
    // REQUETES GÉNÉRIQUES (POUR UN GRAPHIQUE DE BASE DANS LA METHODE 'ONINIT' - CF : LES DIFFÉRENTS 'CHART.COMPONENT') //
    // **************************************************************************************************************** //
    // MÉTHODE GÉNÉRALE
    // getAllFishes(): Observable<Fish[]> {
    //   return this.http.get<Fish[]>('http://localhost:3000/api/fishes');
    // }
    // I> MÉTHODE POUR DATES-CHART (ONINIT)
    FishService.prototype.getAllFishingDates = function () {
        return this.http.get('http://localhost:3000/api/AllFishingDates');
    };
    // II> MÉTHODE POUR SPECIES-CHART (ONINIT)
    FishService.prototype.getAllFishingSpecies = function () {
        return this.http.get('http://localhost:3000/api/AllFishingSpecies');
    };
    // getAllFishingSpecies(date: string): Observable<Fish[]> {
    //   return this.http.get<Fish[]>('http://localhost:3000/api/AllFishingSpecies/' + date);
    // }
    // III> MÉTHODE POUR ZONES-CHART (ONINIT)
    FishService.prototype.getAllFishingZones = function () {
        return this.http.get('http://localhost:3000/api/AllFishingZones');
    };
    // getAllFishingZones(date: string): Observable<Fish[]> {
    //   return this.http.get<Fish[]>('http://localhost:3000/api/AllFishingZones/' + date);
    // }
    // ********************************
    // *************************************************************************************
    // RÉSULTATS DE REQUÊTES DE FORMULAIRE DE RECHERCHE SUR LES GRAPHIQUES
    // MÉTHODE PAR 'END POINTS'
    // *************************************************************************************
    // REQUÊTE 3 B : (SUBMIT)
    FishService.prototype.getAllZones = function (name_specie, zone, date) {
        return this.http.get('http://localhost:3000/api/zones/' + name_specie + '&' + zone + '&' + date);
    };
    // REQUÊTE 3 A (test): (SUBMIT) // UTILISÉE DANS 'CHART-CHANGE-COMPONENT' (= TEST)
    FishService.prototype.getAllZonesTest = function (name_specie, zone, dateend) {
        return this.http.get('http://localhost:3000/api/zones/' + name_specie + '&' + zone + '&' + dateend);
    };
    // ****************
    // REQUÊTE 2 : (SUBMIT)
    FishService.prototype.getAllSpecies = function (name_specie, zone, date) {
        return this.http.get('http://localhost:3000/api/species/' + name_specie + '&' + zone + '&' + date);
    };
    // ****************
    // REQUÊTE 1 B : (SUBMIT)
    FishService.prototype.getAllDates = function (name_specie, zone, datebegin, dateend) {
        return this.http.get('http://localhost:3000/api/dates/' + name_specie + '&' + zone + '&' + datebegin + '&' + dateend);
    };
    // REQUÊTE 1 A : (SUBMIT) // UTILISÉE DANS 'CHART-CHANGE-COMPONENT' (= TEST)
    FishService.prototype.getOneSpecie = function (name_specie, zone, datebegin, dateend) {
        return this.http.get('http://localhost:3000/api/fishes/' + name_specie + '&' + zone + '&' + datebegin + '&' + dateend);
    };
    FishService.ctorParameters = function () { return [
        { type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"] }
    ]; };
    FishService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
            providedIn: 'root'
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"]])
    ], FishService);
    return FishService;
}());



/***/ }),

/***/ "./src/app/todo-data-service/http-error-handler.service.ts":
/*!*****************************************************************!*\
  !*** ./src/app/todo-data-service/http-error-handler.service.ts ***!
  \*****************************************************************/
/*! exports provided: HttpErrorHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpErrorHandler", function() { return HttpErrorHandler; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var _message_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message.service */ "./src/app/todo-data-service/message.service.ts");




/** Handles HttpClient errors */
var HttpErrorHandler = /** @class */ (function () {
    function HttpErrorHandler(messageService) {
        var _this = this;
        this.messageService = messageService;
        /** Create curried handleError function that already knows the service name */
        this.createHandleError = function (serviceName) {
            if (serviceName === void 0) { serviceName = ''; }
            return function (operation, result) {
                if (operation === void 0) { operation = 'operation'; }
                if (result === void 0) { result = {}; }
                return _this.handleError(serviceName, operation, result);
            };
        };
    }
    /**
     * Returns a function that handles Http operation failures.
     * This error handler lets the app continue to run as if no error occurred.
     * @param serviceName = name of the data service that attempted the operation
     * @param operation - name of the operation that failed
     * @param result - optional value to return as the observable result
     */
    HttpErrorHandler.prototype.handleError = function (serviceName, operation, result) {
        var _this = this;
        if (serviceName === void 0) { serviceName = ''; }
        if (operation === void 0) { operation = 'operation'; }
        if (result === void 0) { result = {}; }
        return function (error) {
            // TODO: send the error to remote logging infrastructure
            console.error(error); // log to console instead
            var message = (error.error instanceof ErrorEvent) ?
                error.error.message :
                "server returned code " + error.status + " with body \"" + error.error + "\"";
            // TODO: better job of transforming error for user consumption
            _this.messageService.add(serviceName + ": " + operation + " failed: " + message);
            // Let the app keep running by returning a safe result.
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__["of"])(result);
        };
    };
    HttpErrorHandler.ctorParameters = function () { return [
        { type: _message_service__WEBPACK_IMPORTED_MODULE_3__["MessageService"] }
    ]; };
    HttpErrorHandler = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])(),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_message_service__WEBPACK_IMPORTED_MODULE_3__["MessageService"]])
    ], HttpErrorHandler);
    return HttpErrorHandler;
}());

/*
Copyright Google LLC. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
*/ 


/***/ }),

/***/ "./src/app/todo-data-service/message.service.ts":
/*!******************************************************!*\
  !*** ./src/app/todo-data-service/message.service.ts ***!
  \******************************************************/
/*! exports provided: MessageService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageService", function() { return MessageService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");


var MessageService = /** @class */ (function () {
    function MessageService() {
        this.messages = [];
    }
    MessageService.prototype.add = function (message) {
        this.messages.push(message);
    };
    MessageService.prototype.clear = function () {
        this.messages = [];
    };
    MessageService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
            providedIn: 'root',
        })
    ], MessageService);
    return MessageService;
}());



/***/ }),

/***/ "./src/app/todo-data-service/users.service.ts":
/*!****************************************************!*\
  !*** ./src/app/todo-data-service/users.service.ts ***!
  \****************************************************/
/*! exports provided: UsersService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UsersService", function() { return UsersService; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "./node_modules/rxjs/_esm5/operators/index.js");
/* harmony import */ var _http_error_handler_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./http-error-handler.service */ "./src/app/todo-data-service/http-error-handler.service.ts");
/* harmony import */ var _todo_class_user__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../todo-class/user */ "./src/app/todo-class/user.ts");



// import { delay } from 'rxjs/operators';




// const ALTER_LOGINS = [];
var httpOptions = {
    headers: new _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpHeaders"]({
        'Content-Type': 'application/json',
        'Authorization': 'my-auth-token'
    })
};
var UsersService = /** @class */ (function () {
    function UsersService(http, httpErrorHandler) {
        this.http = http;
        // layer: any;
        this.usersUrl = 'http://localhost:3000/users-api/AllUsers';
        this.handleError = httpErrorHandler.createHandleError('UsersService');
    }
    // **************************************************************************************************************** //
    // REQUETE GÉNÉRIQUE (POUR UN TABLEAU DE BASE DANS LA METHODE 'ONINIT' - CF : LES DIFFÉRENTS 'CHART.COMPONENT') //
    // **************************************************************************************************************** //
    /* le login existe-t'il en BDD ?*/
    // isLoginTaken(login: string): Observable<boolean> {
    //   const isTaken = LOGINS.includes(login);
    //   return of(isTaken).pipe(delay(400));
    // }
    // ********* pour test (delete) :
    UsersService.prototype.getUsers = function () {
        return this.http.get(this.usersUrl)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(this.handleError('getUsers', [])));
    };
    // *********
    // test : MARCHE PAS (PAS DE FILTRAGE DE LA RECHERCHE SUR LE RÉSULTAT DONNÉ PAR L'API...)
    UsersService.prototype.searchUsers = function (term) {
        term = term.trim();
        // Add safe, URL encoded search parameter if there is a search term
        var options = term ? { params: new _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpParams"]().set('login', term) } : {};
        return this.http.get(this.usersUrl, options)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(this.handleError('searchUsers', [])));
    };
    // **********
    UsersService.prototype.getAllUsers = function () {
        return this.http.get('http://localhost:3000/users-api/AllUsers')
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_user__WEBPACK_IMPORTED_MODULE_5__["User"].fromJson(jsonItem); }); }));
        //  .map(res => JSON.stringify(res));
    };
    UsersService.prototype.getLogin = function (login, mail) {
        // let isTaken;
        // const isTaken = ALTER_LOGINS.includes(login);
        // isTaken = this.http.get<User[]>('http://localhost:3000/users-api/SingleLogin/' + login)
        return this.http.get('http://localhost:3000/users-api/SingleLogin/' + login + '&' + mail)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_user__WEBPACK_IMPORTED_MODULE_5__["User"].fromJson(jsonItem); }); }));
        // if(isTaken !== '' || isTaken !== null || isTaken !== undefined) {
        // return of(isTaken).pipe(delay(400));
        // }
    };
    /* insertion : méthode 'GET' */
    UsersService.prototype.getLoginTest = function (login) {
        // let isTaken;
        // const isTaken = ALTER_LOGINS.includes(login);
        // isTaken = this.http.get<User[]>('http://localhost:3000/users-api/SingleLogin/'+ login)
        return this.http.get('http://localhost:3000/users-api/SingleLoginTest/' + login)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_user__WEBPACK_IMPORTED_MODULE_5__["User"].fromJson(jsonItem); }); }));
        // isAlterEgoTaken(alterEgo: string): Observable<boolean> {
        //   const isTaken = ALTER_EGOS.includes(alterEgo);
        //   return of(isTaken).pipe(delay(400));
        // }
    };
    UsersService.prototype.deleteUser = function (user) {
        console.log(user);
        return this.http.post('http://localhost:3000/users-api/DeleteUsers', user, httpOptions)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(this.handleError('deleteUser', user)));
    };
    // MARCHE...
    UsersService.prototype.deleteUser2 = function (user) {
        // deleteUser2 (id_user: number): Observable<{}> {
        // const url = 'http://localhost:3000/users-api/AllUsers' + id_user;
        var url = "http://localhost:3000/users-api/AllUsers2/" + user.id_user;
        console.log(url);
        console.log(user.id_user);
        return this.http.delete(url, httpOptions)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(this.handleError('deleteUser2', user)));
    };
    // MARCHE (autocomplete form)...
    UsersService.prototype.deleteUser3 = function (login) {
        // const url = 'http://localhost:3000/users-api/AllUsers' + id_user;
        var url = this.usersUrl + "/" + login;
        console.log(url);
        console.log(login);
        return this.http.delete(url, httpOptions)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_user__WEBPACK_IMPORTED_MODULE_5__["User"].fromJson(jsonItem); }); }));
    };
    /* insertion user : méthode 'POST' */
    UsersService.prototype.addUser = function (user) {
        console.log(user);
        return this.http.post(this.usersUrl, user, httpOptions)
            // return this.http.post<User>('http://localhost:3000/users-api/SingleLoginTest', user, httpOptions)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(this.handleError('addUser', user)));
    };
    UsersService.prototype.updateUser = function (user) {
        httpOptions.headers = httpOptions.headers.set('Autorization', 'my-new-auth-token');
        return this.http.put(this.usersUrl, user, httpOptions)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["catchError"])(this.handleError('updateUser', user)));
    };
    /* RECHERCHE DE LA DONNÉE ID_USER, AVEC POUR PARAMETRE LE LOGIN DU MEMBRE SÉLECTIONNÉ (TEST : POUR L'UPDATE D'UN LOGIN) : méthode 'GET' */
    UsersService.prototype.getSingleUserLogin = function (login) {
        // let isTaken;
        // const isTaken = ALTER_LOGINS.includes(login);
        // isTaken = this.http.get<User[]>('http://localhost:3000/users-api/SingleLogin/'+ login)
        return this.http.get('http://localhost:3000/users-api/SingleUserLogin/' + login)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_user__WEBPACK_IMPORTED_MODULE_5__["User"].fromJson(jsonItem); }); }));
        // isAlterEgoTaken(alterEgo: string): Observable<boolean> {
        //   const isTaken = ALTER_EGOS.includes(alterEgo);
        //   return of(isTaken).pipe(delay(400));
        // }
    };
    /* RECHERCHE DE LA DONNÉE ID_USER, AVEC POUR PARAMETRE LE MAIL DU MEMBRE SÉLECTIONNÉ (TEST : POUR L'UPDATE D'UN MAIL) : méthode 'GET' */
    UsersService.prototype.getSingleUserMail = function (mail) {
        return this.http.get('http://localhost:3000/users-api/SingleUserMail/' + mail)
            .pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__["map"])(function (jsonArray) { return jsonArray.map(function (jsonItem) { return _todo_class_user__WEBPACK_IMPORTED_MODULE_5__["User"].fromJson(jsonItem); }); }));
    };
    UsersService.ctorParameters = function () { return [
        { type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"] },
        { type: _http_error_handler_service__WEBPACK_IMPORTED_MODULE_4__["HttpErrorHandler"] }
    ]; };
    UsersService = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({
            providedIn: 'root'
        }),
        tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"]("design:paramtypes", [_angular_common_http__WEBPACK_IMPORTED_MODULE_2__["HttpClient"],
            _http_error_handler_service__WEBPACK_IMPORTED_MODULE_4__["HttpErrorHandler"]])
    ], UsersService);
    return UsersService;
}());

// ******************************************
// les autres requetes possibles du CRUD (exemple) :
/*
  insertFish(fish: Fish): Observable<Fish> { // EXEMPLE NON UTILISÉ
    return this.http.post<Fish>('http://localhost:3000/api/fishes/', fish);
  }

  updateFish(fish: Fish): Observable<void> { // EXEMPLE NON UTILISÉ
    return this.http.put<void>('http://localhost:3000/api/fishes/' + fish.name_specie, fish);
  }

  deleteFish(name_specie: string) { // EXEMPLE NON UTILISÉ
    return this.http.delete('http://localhost:3000/api/fishes/' + name_specie);
  }

*/ 


/***/ }),

/***/ "./src/app/todo-directive/login-checked-directive.ts":
/*!***********************************************************!*\
  !*** ./src/app/todo-directive/login-checked-directive.ts ***!
  \***********************************************************/
/*! exports provided: loginUnCheckedValidator, LoginCheckedValidatorDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loginUnCheckedValidator", function() { return loginUnCheckedValidator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginCheckedValidatorDirective", function() { return LoginCheckedValidatorDirective; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");



/* un login ne doit pas être différent de celui souhaité (ex: admin: yatest) */
var loginUnCheckedValidator = function (control) {
    /** EXEMPLE : A hero's name can't match the hero's alter ego */
    // export const identityRevealedValidator: ValidatorFn = (control: FormGroup): ValidationErrors | null => {
    var login = control.get('login');
    console.log(login);
    var mail = control.get('mail');
    console.log(mail);
    // const loginValue = this.userForm.get('login').value;
    // console.log(loginValue);
    var loginCheck = "Kasparov29";
    var mailCheck = "quotauk@gmail.com";
    return login.value !== loginCheck && mail.value !== mailCheck ? { 'loginUnchecked': true } : null;
    // return login && loginCheck && login === login.value ? { 'loginChecked': true } : null;
    // return name && alterEgo && name.value === alterEgo.value ? { 'identityRevealed': true } : null;
};
var LoginCheckedValidatorDirective = /** @class */ (function () {
    function LoginCheckedValidatorDirective() {
    }
    LoginCheckedValidatorDirective_1 = LoginCheckedValidatorDirective;
    // export class IdentityRevealedValidatorDirective implements Validator {
    LoginCheckedValidatorDirective.prototype.validate = function (control) {
        return loginUnCheckedValidator(control);
        // return identityRevealedValidator(control)
    };
    var LoginCheckedValidatorDirective_1;
    LoginCheckedValidatorDirective = LoginCheckedValidatorDirective_1 = tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"]([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"])({
            selector: '[appLoginChecked]',
            // selector: '[appIdentityRevealed]',
            providers: [{ provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__["NG_VALIDATORS"], useExisting: LoginCheckedValidatorDirective_1, multi: true }]
            //   providers: [{ provide: NG_VALIDATORS, useExisting: IdentityRevealedValidatorDirective, multi: true }]
        }),
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injectable"])({ providedIn: 'root' })
    ], LoginCheckedValidatorDirective);
    return LoginCheckedValidatorDirective;
}());

/*
Copyright Google LLC. All Rights Reserved.
Use of this source code is governed by an MIT-style license that
can be found in the LICENSE file at http://angular.io/license
*/ 


/***/ }),

/***/ "./src/environments/environment.ts":
/*!*****************************************!*\
  !*** ./src/environments/environment.ts ***!
  \*****************************************/
/*! exports provided: environment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return environment; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// The file contents for the current environment will overwrite these during build.
// The build system defaults to the dev environment which uses `environment.ts`, but if you do
// `ng build --env=prod` then `environment.prod.ts` will be used instead.
// The list of which env maps to which file can be found in `.angular-cli.json`.

var environment = {
    production: false
};


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polyfills */ "./src/polyfills.ts");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/platform-browser-dynamic */ "./node_modules/@angular/platform-browser-dynamic/fesm5/platform-browser-dynamic.js");
/* harmony import */ var _app_app_module__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./app/app.module */ "./src/app/app.module.ts");
/* harmony import */ var _environments_environment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./environments/environment */ "./src/environments/environment.ts");






if (_environments_environment__WEBPACK_IMPORTED_MODULE_5__["environment"].production) {
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["enableProdMode"])();
}
Object(_angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_3__["platformBrowserDynamic"])().bootstrapModule(_app_app_module__WEBPACK_IMPORTED_MODULE_4__["AppModule"])
    //  .catch(err => console.log(err));
    .then(function (ref) {
    // Ensure Angular destroys itself on hot reloads.
    if (window['ngRef']) {
        window['ngRef'].destroy();
    }
    window['ngRef'] = ref;
    // Otherwise, log the boot error
}).catch(function (err) { return console.error(err); });


/***/ }),

/***/ "./src/polyfills.ts":
/*!**************************!*\
  !*** ./src/polyfills.ts ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/* harmony import */ var zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zone.js/dist/zone */ "./node_modules/zone.js/dist/zone.js");
/* harmony import */ var zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_1__);
/**
 * This file includes polyfills needed by Angular and is loaded before the app.
 * You can add your own extra polyfills to this file.
 *
 * This file is divided into 2 sections:
 *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.
 *   2. Application imports. Files imported after ZoneJS that should be loaded before your main
 *      file.
 *
 * The current setup is for so-called "evergreen" browsers; the last versions of browsers that
 * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),
 * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.
 *
 * Learn more in https://angular.io/docs/ts/latest/guide/browser-support.html
 */

/***************************************************************************************************
 * BROWSER POLYFILLS
 */
/** IE9, IE10 and IE11 requires all of the following polyfills. **/
// import 'core-js/es6/symbol';
// import 'core-js/es6/object';
// import 'core-js/es6/function';
// import 'core-js/es6/parse-int';
// import 'core-js/es6/parse-float';
// import 'core-js/es6/number';
// import 'core-js/es6/math';
// import 'core-js/es6/string';
// import 'core-js/es6/date';
// import 'core-js/es6/array';
// import 'core-js/es6/regexp';
// import 'core-js/es6/map';
// import 'core-js/es6/weak-map';
// import 'core-js/es6/set';
/** IE10 and IE11 requires the following for NgClass support on SVG elements */
// import 'classlist.js';  // Run `npm install --save classlist.js`.
/** IE10 and IE11 requires the following for the Reflect API. */
// import 'core-js/es6/reflect';
/** Evergreen browsers require these. **/
// Used for reflect-metadata in JIT. If you use AOT (and only Angular decorators), you can remove.
/**
 * Required to support Web Animations `@angular/platform-browser/animations`.
 * Needed for: All but Chrome, Firefox and Opera. http://caniuse.com/#feat=web-animation
 **/
// import 'web-animations-js';  // Run `npm install --save web-animations-js`.
/***************************************************************************************************
 * Zone JS is required by default for Angular itself.
 */
 // Included with Angular CLI.
/***************************************************************************************************
 * APPLICATION IMPORTS
 */


/***/ }),

/***/ 0:
/*!***************************!*\
  !*** multi ./src/main.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/yanniscode/Desktop/ukquota.dataviz.fish-z-export-modales-form-connexion-b/src/main.ts */"./src/main.ts");


/***/ })

},[[0,"runtime","vendor"]]]);
//# sourceMappingURL=main.js.map